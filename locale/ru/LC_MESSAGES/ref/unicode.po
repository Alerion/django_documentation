# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2012.
# Sergey Karpenko <serg.karpenko@gmail.com>, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-12-08 11:07+0200\n"
"PO-Revision-Date: 2016-03-17 14:20+0200\n"
"Last-Translator: Sergey Karpenko <serg.karpenko@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 71f84f41706a4129b84d011ecab7c52d
#: ../../ref/unicode.txt:3
msgid "Unicode data"
msgstr "Данные Unicode"

# 97e497a37cb74467b3d0b7c9efe02f78
#: ../../ref/unicode.txt:5
msgid ""
"Django natively supports Unicode data everywhere. Providing your database "
"can somehow store the data, you can safely pass around Unicode strings to "
"templates, models and the database."
msgstr ""
"Django изначально полноценно поддерживает Unicode данные.  Предоставляя "
"вашей базе данных возможность хранить данные как угодно, вы можете безопасно "
"передавать Unicode строки в шаблоны, модели и базу данных."

# 5ef09130e9c649c7ad084e4e5b0c6736
#: ../../ref/unicode.txt:9
msgid ""
"This document tells you what you need to know if you're writing applications "
"that use data or templates that are encoded in something other than ASCII."
msgstr ""
"Этот документ расскажет вам, что вы должны знать, если вы пишете приложения, "
"которые используют данные или шаблоны, закодированные, в что-то отличное от "
"ASCII."

# 61bcff32399b45ffb5d8c07829704756
#: ../../ref/unicode.txt:13
msgid "Creating the database"
msgstr "Создание базы данных"

# fbab3d0211b347c5b46a9e94ab1ebc38
#: ../../ref/unicode.txt:15
msgid ""
"Make sure your database is configured to be able to store arbitrary string "
"data. Normally, this means giving it an encoding of UTF-8 or UTF-16. If you "
"use a more restrictive encoding -- for example, latin1 (iso8859-1) -- you "
"won't be able to store certain characters in the database, and information "
"will be lost."
msgstr ""
"Убедитесь, что ваша база данных настроена с учетом возможности хранить "
"произвольные строковые данные. Обычно, это значит хранение в кодировке UTF-8 "
"или UTF-16. Если вы используете более строгие кодировки -- к примеру latin1 "
"(iso8859-1) -- вы не сможете хранить определенные символы, и информация "
"будет утеряна."

# 77af29d713db4607bf1e1ee1257d5c91
#: ../../ref/unicode.txt:20
msgid ""
"MySQL users, refer to the `MySQL manual`_ for details on how to set or alter "
"the database character set encoding."
msgstr ""
"Пользователи MySQL могут обратиться к `MySQL manual`_ за подробностями, как "
"установить или изменить кодировку базы данных."

# 96ec8576a11940f7837f707c33c9584d
#: ../../ref/unicode.txt:23
msgid ""
"PostgreSQL users, refer to the `PostgreSQL manual`_ (section 22.3.2 in "
"PostgreSQL 9) for details on creating databases with the correct encoding."
msgstr ""
"Пользователи PostgreSQL могут обратиться к `PostgreSQL manual`_ (раздел "
"22.3.2 in PostgreSQL 9) за подробностями по созданию баз данных с правильной "
"кодировкой."

# 77af29d713db4607bf1e1ee1257d5c91
#: ../../ref/unicode.txt:26
msgid ""
"Oracle users, refer to the `Oracle manual`_ for details on how to set "
"(`section 2`_) or alter (`section 11`_) the database character set encoding."
msgstr ""
"Пользователи Oracle могут обратиться к `Oracle manual`_ за подробностями, "
"как установить (`section 2`_) или изменить (`section 11`_) кодировку базы "
"данных."

# fba02cc224574f3d8eb5d75a480807d1
#: ../../ref/unicode.txt:29
msgid ""
"SQLite users, there is nothing you need to do. SQLite always uses UTF-8 for "
"internal encoding."
msgstr ""
"Пользователи SQLite могут ничего не делать. SQLite всегда использует UTF-8 в "
"качестве внутренней кодировки."

# ff2fd663d84847018522d23bbabb7282
#: ../../ref/unicode.txt:38
msgid ""
"All of Django's database backends automatically convert Unicode strings into "
"the appropriate encoding for talking to the database. They also "
"automatically convert strings retrieved from the database into Python "
"Unicode strings. You don't even need to tell Django what encoding your "
"database uses: that is handled transparently."
msgstr ""
"Все бекенды баз данных в Django  автоматически конвертируют Unicode строки в "
"соответствующую кодировку для передачи в базу данных. Они также "
"автоматически конвертируют строки, полученные из базы данных в строки Python "
"Unicode. Вам даже не нужно говорить Django, какую кодировку использует ваша "
"база данных: это прозрачно обрабатывается."

# 15d7447521fa4d3a8f759a5d9652f230
#: ../../ref/unicode.txt:44
msgid "For more, see the section \"The database API\" below."
msgstr "Подробнее смотрите раздел \"API базы данных\" ниже."

# af5f8049c13e44d98199ed0ceceafe98
#: ../../ref/unicode.txt:47
msgid "General string handling"
msgstr "Общая обработка строк"

# eb245fe5d1294e41acf0af8573e05c4d
#: ../../ref/unicode.txt:49
msgid ""
"Whenever you use strings with Django -- e.g., in database lookups, template "
"rendering or anywhere else -- you have two choices for encoding those "
"strings. You can use Unicode strings, or you can use normal strings "
"(sometimes called \"bytestrings\") that are encoded using UTF-8."
msgstr ""
"Всякий раз когда вы используете строки в Django -- к примеру, в поиске по "
"базе данных, рендеринге шаблонов или где-нибудь еще  -- вы имеете два "
"варианта для кодирования таких строк. Вы можете использовать строки Unicode "
"или же вы можете использовать обыкновенные строки (иногда называющиеся  "
"\"байтовыми строками\"), которые кодируются с использованием UTF-8."

# 6142734fcd44462e8cbc332003efd3eb
#: ../../ref/unicode.txt:54
msgid ""
"In Python 3, the logic is reversed, that is normal strings are Unicode, and "
"when you want to specifically create a bytestring, you have to prefix the "
"string with a 'b'. As we are doing in Django code from version 1.5, we "
"recommend that you import ``unicode_literals`` from the __future__ library "
"in your code. Then, when you specifically want to create a bytestring "
"literal, prefix the string with 'b'."
msgstr ""
"В Python 3 логика была изменена, теперь обыкновенные строки являются "
"Unicode, и когда вы хотите создать байтовую строку, вы должны использовать "
"строку начинающуюся с  'b'. Как мы сами делаем в Django, начиная с версии "
"1.5, мы рекомендуем и вам - импортировать ``unicode_literals`` из библиотеки "
"__future__ в вашем коде. И тогда, когда вы захотите специально создать "
"байтовую строку, добавьте префикс 'b'."

# 4207871f7e1d4e07b7e6a54fef8f5d29
#: ../../ref/unicode.txt:61
msgid "Python 2 legacy::"
msgstr "Наследие Python 2::"

# b7ed69b55b6646a58449d15cb2c7c68b
#: ../../ref/unicode.txt:66
msgid "Python 2 with unicode literals or Python 3::"
msgstr "Python 2 с литералами Unicode или Python 3::"

# 3448d02238b544c892d14d7211bcd2e4
#: ../../ref/unicode.txt:73
msgid "See also :doc:`Python 3 compatibility </topics/python3>`."
msgstr "Смотрите также :doc:`Портирование на Python 3 </topics/python3>`."

# a3e2d61ee7d84215ad8a6dba6872fb9b
#: ../../ref/unicode.txt:77
msgid ""
"A bytestring does not carry any information with it about its encoding. For "
"that reason, we have to make an assumption, and Django assumes that all "
"bytestrings are in UTF-8."
msgstr ""
"Байтовые строки не могут содержать информацию о своих кодировках. По этой "
"причине, мы должны делать предположение, и Django  предполагает, что все "
"байтовые строки будут в кодировке UTF-8."

# 2f354764235a4919865608975d77f5f7
#: ../../ref/unicode.txt:81
msgid ""
"If you pass a string to Django that has been encoded in some other format, "
"things will go wrong in interesting ways. Usually, Django will raise a "
"``UnicodeDecodeError`` at some point."
msgstr ""
"Если передать строку в Django, которая была закодирована в каком-то другом "
"формате, все пойдет не так. Как правило Django выбрасывает исключение "
"``UnicodeDecodeError`` в этом месте."

# 7d74f4149fcc49beb09636a6d1339325
#: ../../ref/unicode.txt:85
msgid ""
"If your code only uses ASCII data, it's safe to use your normal strings, "
"passing them around at will, because ASCII is a subset of UTF-8."
msgstr ""
"Если ваш код использует только данные ASCII, это позволяет использовать "
"обыкновенные строки, они будут работать корректно, так как ASCII является "
"подмножеством UTF-8."

# d9f0e1fe17fa4cd7b99b161dfd057d19
#: ../../ref/unicode.txt:88
msgid ""
"Don't be fooled into thinking that if your :setting:`DEFAULT_CHARSET` "
"setting is set to something other than ``'utf-8'`` you can use that other "
"encoding in your bytestrings! :setting:`DEFAULT_CHARSET` only applies to the "
"strings generated as the result of template rendering (and email). Django "
"will always assume UTF-8 encoding for internal bytestrings. The reason for "
"this is that the :setting:`DEFAULT_CHARSET` setting is not actually under "
"your control (if you are the application developer). It's under the control "
"of the person installing and using your application -- and if that person "
"chooses a different setting, your code must still continue to work. Ergo, it "
"cannot rely on that setting."
msgstr ""
"Не обманывайте себя, думая что если ваш параметр :setting:`DEFAULT_CHARSET` "
"установлен в какую-то отличную от ``'utf-8'`` кодировку, то вы можете "
"использовать другую кодировку в ваших байтовых строках. Параметр :setting:"
"`DEFAULT_CHARSET` применяется только к строкам, сгенерированным в результате "
"рендеринга шаблона (или email). Django всегда будет ожидать UTF-8 для "
"внутренних байтовых строк. Причина этого в том, что параметр :setting:"
"`DEFAULT_CHARSET` фактически находится не под вашим контролем (если вы "
"разработчик приложения). Это будет под контролем, того, кто инсталирует и "
"использует ваше приложение -- и даже если будет выбрана другая кодировка, то "
"ваш код обязан продолжать работать. Следовательно это не может зависеть от "
"такого параметра."

# 4cb8fc5871bb4491bf586c0137c7fbd0
#: ../../ref/unicode.txt:98
msgid ""
"In most cases when Django is dealing with strings, it will convert them to "
"Unicode strings before doing anything else. So, as a general rule, if you "
"pass in a bytestring, be prepared to receive a Unicode string back in the "
"result."
msgstr ""
"Во многих случаях, когда Django работает со строками, он будет "
"конвертировать их в строки Unicode перед тем как что-либо делать с ними. "
"Поэтому, общее правило, если вы передаете байтовую строку, будьте готовы "
"получить назад строку Unicode."

# 6954a7bafe354c139f01f37c1df18aac
#: ../../ref/unicode.txt:103
msgid "Translated strings"
msgstr "Переведенные строки"

# 08f2e6041a964e768fa2861754f57b68
#: ../../ref/unicode.txt:105
msgid ""
"Aside from Unicode strings and bytestrings, there's a third type of string-"
"like object you may encounter when using Django. The framework's "
"internationalization features introduce the concept of a \"lazy translation"
"\" -- a string that has been marked as translated but whose actual "
"translation result isn't determined until the object is used in a string. "
"This feature is useful in cases where the translation locale is unknown "
"until the string is used, even though the string might have originally been "
"created when the code was first imported."
msgstr ""
"Немного в стороне от строк Unicode и байтовых строк, есть еще третий тип "
"строковых объектов, с которыми можно столкнуться, используя Django. "
"Особенности интернационализации фреймворка вводят понятие \"ленивого перевода"
"\" -- это строка которая отмечена как переведенная, но чей фактический "
"перевод не определен пока объект используется в строке. Эта особенность "
"полезна в случаях, когда перевод локали не известен пока строка не будет "
"использована, даже при том что строка могла быть первоначально создана когда "
"код был первый раз импортирован."

# 055493ec6177439e91e31e8d2d5f217c
#: ../../ref/unicode.txt:114
msgid ""
"Normally, you won't have to worry about lazy translations. Just be aware "
"that if you examine an object and it claims to be a ``django.utils."
"functional.__proxy__`` object, it is a lazy translation. Calling "
"``unicode()`` with the lazy translation as the argument will generate a "
"Unicode string in the current locale."
msgstr ""
"Обычно, вы не должны беспокоиться о ленивых переводах. Только знайте, что "
"если вы проверяете объект и он утверждает, что он ``django.utils.functional."
"__proxy__`` - это ленивый перевод.  Вызов ``unicode()`` с ленивым переводом "
"в качестве аргумента сгенерирует строку Unicode в текущей локали."

# c490974aa40f48c1825adea420a98bb1
#: ../../ref/unicode.txt:120
msgid ""
"For more details about lazy translation objects, refer to the :doc:"
"`internationalization </topics/i18n/index>` documentation."
msgstr ""
"Для более подробной информации об объектах ленивого перевода вы можете "
"обратиться к документации :doc:`Интернационализация </topics/i18n/index>`. "

# 7c6ed93cc58248a18cc9b33b59fe60d4
#: ../../ref/unicode.txt:124
msgid "Useful utility functions"
msgstr "Полезные утилитарные функции."

# b990b0ba5c734f21af9bce990e5696f8
#: ../../ref/unicode.txt:126
msgid ""
"Because some string operations come up again and again, Django ships with a "
"few useful functions that should make working with Unicode and bytestring "
"objects a bit easier."
msgstr ""
"По причине того, что некоторые строковые операции требуются снова и снова, "
"Django поставляется с несколькими полезными функциями, которые должны "
"сделать работу с Unicode и байтовыми строками немного легче."

# 7c341f68c945438a93e8feae4a38b2cd
#: ../../ref/unicode.txt:131
msgid "Conversion functions"
msgstr "Функции преобразования"

# 3b179dcd3ece4a869033a2fd1a30e3d3
#: ../../ref/unicode.txt:133
msgid ""
"The ``django.utils.encoding`` module contains a few functions that are handy "
"for converting back and forth between Unicode and bytestrings."
msgstr ""
"Модуль ``django.utils.encoding`` содержит несколько функций, которые удобны "
"для прямого и обратного преобразования между строками Unicode и байтовыми "
"строками "

# 839461a5e1734fe592293bfa8ed8f006
#: ../../ref/unicode.txt:136
msgid ""
"``smart_text(s, encoding='utf-8', strings_only=False, errors='strict')`` "
"converts its input to a Unicode string. The ``encoding`` parameter specifies "
"the input encoding. (For example, Django uses this internally when "
"processing form input data, which might not be UTF-8 encoded.) The "
"``strings_only`` parameter, if set to True, will result in Python numbers, "
"booleans and ``None`` not being converted to a string (they keep their "
"original types). The ``errors`` parameter takes any of the values that are "
"accepted by Python's ``unicode()`` function for its error handling."
msgstr ""
"``smart_text(s, encoding='utf-8', strings_only=False, errors='strict')`` "
"преобразовывает входную строку в  Unicode. Параметр ``encoding`` "
"устанавливает входную кодировку. (Так Django использует это внутри при "
"обработке форм входных данных, которые могут быть закодированы не в  UTF-8.) "
"Если параметр ``strings_only`` установлен  в True, то результат для чисел, "
"булевых переменных и ``None`` не  будет преобразован в строку (они сохранят "
"свои начальные типы). Параметр ``errors`` может принимать любые значение, "
"которые передаются в  Python функцию ``unicode()`` для обработки ею ошибок."

# c313ef0bdb3943509dc329a946e985e0
#: ../../ref/unicode.txt:146
msgid ""
"If you pass ``smart_text()`` an object that has a ``__unicode__`` method, it "
"will use that method to do the conversion."
msgstr ""
"Если вы передаете в ``smart_text()`` объект, который имеет метод "
"``__unicode__``, то этот метод будет использован для преобразования."

# 950fea0b97a14305ba0eb9efa2cb3b68
#: ../../ref/unicode.txt:149
msgid ""
"``force_text(s, encoding='utf-8', strings_only=False, errors='strict')`` is "
"identical to ``smart_text()`` in almost all cases. The difference is when "
"the first argument is a :ref:`lazy translation <lazy-translations>` "
"instance. While ``smart_text()`` preserves lazy translations, "
"``force_text()`` forces those objects to a Unicode string (causing the "
"translation to occur). Normally, you'll want to use ``smart_text()``. "
"However, ``force_text()`` is useful in template tags and filters that "
"absolutely *must* have a string to work with, not just something that can be "
"converted to a string."
msgstr ""
"``force_text(s, encoding='utf-8', strings_only=False, errors='strict')`` "
"идентична ``smart_text()``  в большинстве случаев. Отличие лишь в том "
"случае, когда первый аргумент является инстансом :ref:`ленивого перевода "
"<lazy-translations>`. В то время как ``smart_text()`` хранит ленивые "
"переводы, ``force_text()`` форсирует преобразование этих объектов в строки "
"Unicode (в результате чего происходит перевод). Обычно вам будет нужно "
"использовать ``smart_text()``. Но тем не менее ``force_text()`` полезна в "
"шаблонных тегах и фильтрах, которые должны обязательно работать со строками, "
"а не только с тем, что может быть преобразовано в строку."

# 7c874d14b1164add99b5a76ecf616869
#: ../../ref/unicode.txt:159
msgid ""
"``smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict')`` is "
"essentially the opposite of ``smart_text()``. It forces the first argument "
"to a bytestring. The ``strings_only`` parameter has the same behavior as for "
"``smart_text()`` and ``force_text()``. This is slightly different semantics "
"from Python's builtin ``str()`` function, but the difference is needed in a "
"few places within Django's internals."
msgstr ""
"``smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict')`` - "
"это по существу противоположность ``smart_text()``. Она преобразовывает "
"первый аргумент в байтовую строку. Параметр ``strings_only`` имеет такое же "
"поведение, как в ``smart_text()`` и  ``force_text()``. Есть небольшое "
"отличие от семантики встроенной  функции Python ``str()``, но это отличие "
"обусловлено несколькими внутренними особенностями Django."

# 97e5177f126b4102bff9a0fee2561127
#: ../../ref/unicode.txt:166
msgid ""
"Normally, you'll only need to use ``smart_text()``. Call it as early as "
"possible on any input data that might be either Unicode or a bytestring, and "
"from then on, you can treat the result as always being Unicode."
msgstr ""
"Как правило, вам будет нужно использовать только ``smart_text()``. Вызывайте "
"это как можно раньше для любых входных данных, которые могут быть Unicode "
"или байтовой строкой, и после этого вы можете работать с результатом, "
"который всегда будет Unicode."

# c2e00a4aec8449eb9d3fa8513c9a5ff4
#: ../../ref/unicode.txt:173
msgid "URI and IRI handling"
msgstr "Обработка URI и IRI"

# c33570ed0d3b45fb9f3f28a1f02e81e6
#: ../../ref/unicode.txt:175
msgid ""
"Web frameworks have to deal with URLs (which are a type of IRI_). One "
"requirement of URLs is that they are encoded using only ASCII characters. "
"However, in an international environment, you might need to construct a URL "
"from an IRI_ -- very loosely speaking, a URI_ that can contain Unicode "
"characters. Quoting and converting an IRI to URI can be a little tricky, so "
"Django provides some assistance."
msgstr ""
"Веб фреймворки должны взаимодействовать с URL'ами (которые являются "
"разновидностью IRI_). Одно из требований URL'ов - это то, что они должны "
"быть закодированы с использованием только ASCII символов. Тем не менее, в "
"международном окружении, вы можете захотеть обрабатывать URL как IRI_ --  "
"если говорить очень просто, то URI_ могут содержать Unicode символы."
"Экранирование и преобразование IRI в URI  может быть непростым, поэтому "
"Django представляет некоторую помощь для этого."

# 8eb896f3ce6e456296275513d63d640f
#: ../../ref/unicode.txt:182
msgid ""
"The function :func:`django.utils.encoding.iri_to_uri()` implements the "
"conversion from IRI to URI as required by the specification (:rfc:"
"`3987#section-3.1`)."
msgstr ""
"Функция :func:`django.utils.encoding.iri_to_uri()` реализует преобразование "
"из IRI в URI, как этого требует спецификация (:rfc:`3987#section-3.1`)."

# c61223c714924c32a9f815084c79a1cd
#: ../../ref/unicode.txt:185
msgid ""
"The functions :func:`django.utils.http.urlquote()` and :func:`django.utils."
"http.urlquote_plus()` are versions of Python's standard ``urllib.quote()`` "
"and ``urllib.quote_plus()`` that work with non-ASCII characters. (The data "
"is converted to UTF-8 prior to encoding.)"
msgstr ""
"Функции :func:`django.utils.http.urlquote()` и :func:`django.utils.http."
"urlquote_plus()` - это версии Python стандартных  ``urllib.quote()`` и "
"``urllib.quote_plus()``, которые работают с не-ASCII символами. (Данные "
"преобразуются в UTF-8 перед кодированием.)"

# 13f58ab5ea0643a8a0ab96d4ec0a461d
#: ../../ref/unicode.txt:190
msgid ""
"These two groups of functions have slightly different purposes, and it's "
"important to keep them straight. Normally, you would use ``urlquote()`` on "
"the individual portions of the IRI or URI path so that any reserved "
"characters such as '&' or '%' are correctly encoded. Then, you apply "
"``iri_to_uri()`` to the full IRI and it converts any non-ASCII characters to "
"the correct encoded values."
msgstr ""
"Эти две группы функций имеют небольшие различия в назначении, и понимание "
"этого важно для их правильного применения. Как правило вы должны "
"использовать ``urlquote()`` для отдельных частей IRI или URI путей, в "
"результате любые зарезервированные символы как '&' и '%'  будут кодироваться "
"корректно. Затем вы применяете ``iri_to_uri()`` для полного IRI и это "
"преобразует любые не-ASCII символы в правильно закодированные значения."

# 535f8023052f48f38f4baf04ab00e229
#: ../../ref/unicode.txt:198
msgid ""
"Technically, it isn't correct to say that ``iri_to_uri()`` implements the "
"full algorithm in the IRI specification. It doesn't (yet) perform the "
"international domain name encoding portion of the algorithm."
msgstr ""
"Формально, не корректно говорить, что функция ``iri_to_uri()`` реализует "
"полный алгоритм из спецификации IRI. Она (пока) не реализует часть алгоритма "
"для кодирования международных доменных имен."

# aa1ea0876dfc483fab78219720f39be0
#: ../../ref/unicode.txt:202
msgid ""
"The ``iri_to_uri()`` function will not change ASCII characters that are "
"otherwise permitted in a URL. So, for example, the character '%' is not "
"further encoded when passed to ``iri_to_uri()``. This means you can pass a "
"full URL to this function and it will not mess up the query string or "
"anything like that."
msgstr ""
"Функция ``iri_to_uri()`` не будет изменять ASCII символы, которые в "
"противном случае допускаются в URL. Так, например, символ  '%' дополнительно "
"не кодируется когда передается в ``iri_to_uri()``. Это значит вы можете "
"передавать полный URL в эту функцию и это не испортит строку запроса или что-"
"либо подобное ей."

# 64232a8cb67d47f2ba010fd6a86b1078
#: ../../ref/unicode.txt:208
msgid "An example might clarify things here::"
msgstr "Пример поможет прояснить это::"

# a2d3147821824d568d3d3478da36939e
#: ../../ref/unicode.txt:215
msgid ""
"If you look carefully, you can see that the portion that was generated by "
"``urlquote()`` in the second example was not double-quoted when passed to "
"``iri_to_uri()``. This is a very important and useful feature. It means that "
"you can construct your IRI without worrying about whether it contains non-"
"ASCII characters and then, right at the end, call ``iri_to_uri()`` on the "
"result."
msgstr ""
"Если вы посмотрите внимательно, вы сможете увидеть что часть, которая "
"генерируется при помощи ``urlquote()`` во втором примере не обрабатывается "
"дважды когда передается в ``iri_to_uri()``. Это очень важная и полезная "
"особенность. Это означает, что вы можете работать с вашей IRI без "
"беспокойства будeт ли IRI содержать не-ASCII символы и затем правильно ли "
"все в конце, при вызове ``iri_to_uri()``."

#: ../../ref/unicode.txt:222
msgid ""
"Similarly, Django provides :func:`django.utils.encoding.uri_to_iri()` which "
"implements the conversion from URI to IRI as per :rfc:`3987#section-3.2`. It "
"decodes all percent-encodings except those that don't represent a valid "
"UTF-8 sequence."
msgstr ""
"Также Django предоставляет функцию :func:`django.utils.encoding."
"uri_to_iri()`, которая конвертирует URI в IRI, как этого требует "
"спецификация  :rfc:`3987#section-3.2`. Она пытается декодировать возможные "
"UTF-8 символы."

#: ../../ref/unicode.txt:227
msgid "An example to demonstrate::"
msgstr "Примеры::"

#: ../../ref/unicode.txt:234
msgid ""
"In the first example, the UTF-8 characters and reserved characters are "
"unquoted. In the second, the percent-encoding remains unchanged because it "
"lies outside the valid UTF-8 range."
msgstr ""
"В первом примере UTF-8 символы и спецсимволы декодируются. Во втором примере "
"'%' остался без изменений т.к. не представляет валидный код UTF-8 символа."

# 99ccbabc520c45be99af6467dc244b0c
#: ../../ref/unicode.txt:238
msgid ""
"Both ``iri_to_uri()`` and ``uri_to_iri()`` functions are idempotent, which "
"means the following is always true::"
msgstr ""
"Функции ``iri_to_uri()`` и ``uri_to_iri()`` также идемпотентны, это значит "
"что следующее всегда истинно::"

# aef855dee53c4301b9beb9b8c88c7297
#: ../../ref/unicode.txt:244
msgid ""
"So you can safely call it multiple times on the same URI/IRI without risking "
"double-quoting problems."
msgstr ""
"Поэтому вы можете безопасно вызывать функцию множество раз для одного и того "
"же IRI/URI без риска получить проблему двойного экранирования."

# 05dfcc3092ab446d9daf28d5fbfc522f
#: ../../ref/unicode.txt:251
msgid "Models"
msgstr "Модели"

# 9a2f3e969e9949f689feebe80cc92a06
#: ../../ref/unicode.txt:253
#, fuzzy
msgid ""
"Because all strings are returned from the database as Unicode strings, model "
"fields that are character based (CharField, TextField, URLField, etc.) will "
"contain Unicode values when Django retrieves data from the database. This is "
"*always* the case, even if the data could fit into an ASCII bytestring."
msgstr ""
"По причине того, что все строки возвращаются из базы данных как Unicode "
"строки, строковые поля модели (CharField, TextField, URLField и т.д.) будут "
"содержать Unicode значения, когда Django достает данные из базы данных. Это "
"происходит *всегда* , даже если данные содержат только байтовые строки ASCII."

# 8f5168ae54f049678e6c6539fccbdf93
#: ../../ref/unicode.txt:258
msgid ""
"You can pass in bytestrings when creating a model or populating a field, and "
"Django will convert it to Unicode when it needs to."
msgstr ""
"Вы можете передавать данные в байтовых строках, когда создается модель или "
"заполняется поле, и Django будет преобразовывать данные в Unicode когда это "
"будет необходимо."

# 57e09905d740402b9f0afcccf9ab14f6
#: ../../ref/unicode.txt:262
msgid "Choosing between ``__str__()`` and ``__unicode__()``"
msgstr "Выбор между ``__str__()`` и ``__unicode__()``"

# c5cf637947e246b0bbf82278e9682f14
#: ../../ref/unicode.txt:266
msgid ""
"If you are on Python 3, you can skip this section because you'll always "
"create ``__str__()`` rather than ``__unicode__()``. If you'd like "
"compatibility with Python 2, you can decorate your model class with :func:"
"`~django.utils.encoding.python_2_unicode_compatible`."
msgstr ""
"Если вы используете Python 3, можете пропустить эту секцию, потому что вы "
"всегда будете создавать ``__str__()`` вместо ``__unicode__()``. Если вы "
"хотите обеспечить совместимость с Python 2, вы можете декорировать ваш класс "
"модели при помощи :func:`~django.utils.encoding.python_2_unicode_compatible`."

# 3329c6bf1614488d9549be4fa9ebbddb
#: ../../ref/unicode.txt:271
msgid ""
"One consequence of using Unicode by default is that you have to take some "
"care when printing data from the model."
msgstr ""
"Одно из последствий использования Unicode по умолчанию - это то что вы "
"должны проявлять некоторую заботу при распечатке данных из модели. "

# 154174c4da474b919279ddac47bc5de2
#: ../../ref/unicode.txt:274
msgid ""
"In particular, rather than giving your model a ``__str__()`` method, we "
"recommended you implement a ``__unicode__()`` method. In the "
"``__unicode__()`` method, you can quite safely return the values of all your "
"fields without having to worry about whether they fit into a bytestring or "
"not. (The way Python works, the result of ``__str__()`` is *always* a "
"bytestring, even if you accidentally try to return a Unicode object)."
msgstr ""
"В частности, вместо получения ``__str__()``  метода вашей модели, мы "
"рекомендовали вам реализовать ``__unicode__()`` метод. В ``__unicode__()`` "
"методе, вы можете довольно безопасно вернуть значения всех ваших полей без "
"необходимости беспокойства о том будут ли они байтовыми строками или нет. "
"(Путь Python работает, результат ``__str__()`` *всегда* байтовая строка,  "
"даже если вы нечаянно попробуете вернуть Unicode объект)."

# 704a5f0daabc4242bc30a4414ef276d3
#: ../../ref/unicode.txt:281
msgid ""
"You can still create a ``__str__()`` method on your models if you want, of "
"course, but you shouldn't need to do this unless you have a good reason. "
"Django's ``Model`` base class automatically provides a ``__str__()`` "
"implementation that calls ``__unicode__()`` and encodes the result into "
"UTF-8. This means you'll normally only need to implement a ``__unicode__()`` "
"method and let Django handle the coercion to a bytestring when required."
msgstr ""
"Вы можете все же создать метод ``__str__()`` в вашей модели, если хотите, "
"конечно, но вам не нужно этого делать, пока вы не имеете достаточной "
"причины. Базовый класс ``Model`` в Django автоматически предоставляет "
"реализацию ``__str__()``, которая вызывает ``__unicode__()`` и кодирует "
"результат в UTF-8. Это значит, что обычно вам достаточно реализовать метод "
"``__unicode__()`` и дать Django принудительно преобразовать в байтовую "
"строку когда это потребуется."

# bc573647f59e4a429ae9fdfa74272659
#: ../../ref/unicode.txt:289
msgid "Taking care in ``get_absolute_url()``"
msgstr "Будьте осторожны с ``get_absolute_url()``"

# 5a7f720545484df7911fee45f3325b07
#: ../../ref/unicode.txt:291
#, fuzzy
msgid ""
"URLs can only contain ASCII characters. If you're constructing a URL from "
"pieces of data that might be non-ASCII, be careful to encode the results in "
"a way that is suitable for a URL. The :func:`~django.urls.reverse` function "
"handles this for you automatically."
msgstr ""
"URL'ы могут содержать только ASCII символы. Если вы собираете URL из частей, "
"которые могут содержать не-ASCII, будьте осторожны с кодированием "
"результатов,  способом подходящим для URL. Функция :func:`~django.core."
"urlresolvers.reverse`  обрабатывает это для вас автоматически."

# 1201f403616248138a0342ec7b035117
#: ../../ref/unicode.txt:296
msgid ""
"If you're constructing a URL manually (i.e., *not* using the ``reverse()`` "
"function), you'll need to take care of the encoding yourself. In this case, "
"use the ``iri_to_uri()`` and ``urlquote()`` functions that were documented "
"above_. For example::"
msgstr ""
"Если вы собираете URL вручную (то есть *не* используя функцию "
"``reverse()`` ), вам будет нужно заботиться о кодировании самостоятельно. В "
"этом случае,  используйте функции ``iri_to_uri()`` и ``urlquote()`` которые "
"были описаны выше_.  Например::"

# 67fda75a9b304ff18279fc21ab1f6956
#: ../../ref/unicode.txt:308
msgid ""
"This function returns a correctly encoded URL even if ``self.location`` is "
"something like \"Jack visited Paris & Orléans\". (In fact, the "
"``iri_to_uri()`` call isn't strictly necessary in the above example, because "
"all the non-ASCII characters would have been removed in quoting in the first "
"line.)"
msgstr ""
"Функция возвращает корректный кодированный URL, даже если ``self.location`` "
"это что то подобное \"Jack visited Paris & Orléans\". (По факту, вызов "
"``iri_to_uri()`` не строго необходим в примере выше, потому что все не-ASCII "
"символы были бы удалены при экранировании в первой строке.)"

# 022685bb217a447594f4df260ad1b722
#: ../../ref/unicode.txt:316
msgid "The database API"
msgstr "API базы данных"

# 8b847a38115b4b15936a2960bfb6b922
#: ../../ref/unicode.txt:318
msgid ""
"You can pass either Unicode strings or UTF-8 bytestrings as arguments to "
"``filter()`` methods and the like in the database API. The following two "
"querysets are identical::"
msgstr ""
"Вы можете передавать или Unicode строку или UTF-8 байтовую строку в качестве "
"аргументов в методы ``filter()`` и им подобные в API баз данных. Следующие "
"два QuerySets одинаковы:"

# e29ec60154354ff5987dea7a375ee387
#: ../../ref/unicode.txt:328
msgid "Templates"
msgstr "Шаблоны"

# c11d083ca5414108be093f0d3ef1f4e8
#: ../../ref/unicode.txt:330
msgid ""
"You can use either Unicode or bytestrings when creating templates manually::"
msgstr ""
"Вы можете использовать Unicode или байтовые строки когда создаете шаблон "
"вручную."

# 1122ff7ff44940e385c7d90df0d7c72c
#: ../../ref/unicode.txt:337
msgid ""
"But the common case is to read templates from the filesystem, and this "
"creates a slight complication: not all filesystems store their data encoded "
"as UTF-8. If your template files are not stored with a UTF-8 encoding, set "
"the :setting:`FILE_CHARSET` setting to the encoding of the files on disk. "
"When Django reads in a template file, it will convert the data from this "
"encoding to Unicode. (:setting:`FILE_CHARSET` is set to ``'utf-8'`` by "
"default.)"
msgstr ""
"Но в общем случае шаблоны читаются из файловой системы и это создает "
"незначительную сложность: не все файловые системы хранят данные в UTF-8. "
"Если ваши файлы с шаблонами хранятся не в UTF-8, установите параметр :"
"setting:`FILE_CHARSET` в значение кодировки ваших файлов на диске. Когда "
"Django читает файл шаблона, он будет конвертировать данные из указанной "
"кодировки в Unicode.(:setting:`FILE_CHARSET` установлено в ``'utf-8'`` по "
"умолчанию.)"

# 84975e1dcc0244dfaeb4ab6abf00985d
#: ../../ref/unicode.txt:344
msgid ""
"The :setting:`DEFAULT_CHARSET` setting controls the encoding of rendered "
"templates. This is set to UTF-8 by default."
msgstr ""
"Параметр :setting:`DEFAULT_CHARSET` управляет кодировкой сгенерированных "
"шаблонов. Он установлен в UTF-8 по умолчанию."

# caf02266ef594b76bc150c27ed3bf39b
#: ../../ref/unicode.txt:348
msgid "Template tags and filters"
msgstr "Шаблонные теги и фильтры"

# be65434e202d42e38e573d56e0c50ef8
#: ../../ref/unicode.txt:350
msgid ""
"A couple of tips to remember when writing your own template tags and filters:"
msgstr ""
"Несколько подсказок, которые следует помнить когда вы пишите свои теги и "
"фильтры:"

# 481b5d90df1743339ab00e37f31c4000
#: ../../ref/unicode.txt:352
msgid ""
"Always return Unicode strings from a template tag's ``render()`` method and "
"from template filters."
msgstr ""
"Всегда возвращайте Unicode строки из ``render()`` метода шаблонных тегов и "
"из шаблонных фильтров."

# 91ffbc86d42c4d3cbf0c9693ba5de58a
#: ../../ref/unicode.txt:355
msgid ""
"Use ``force_text()`` in preference to ``smart_text()`` in these places. Tag "
"rendering and filter calls occur as the template is being rendered, so there "
"is no advantage to postponing the conversion of lazy translation objects "
"into strings. It's easier to work solely with Unicode strings at that point."
msgstr ""
"Использование ``force_text()`` предпочтительнее ``smart_text()`` в этих "
"местах. Вызовы рендеринга тега и фильтра происходят так же как для "
"отрендереннного шаблона, поэтому нет выгоды в отложенном преобразовании "
"объектов ленивого перевода в строки. Это легче для работы исключительно с "
"Unicode строками в этот момент."

#: ../../ref/unicode.txt:364
msgid "Files"
msgstr "Файлы"

#: ../../ref/unicode.txt:366
msgid ""
"If you intend to allow users to upload files, you must ensure that the "
"environment used to run Django is configured to work with non-ASCII file "
"names. If your environment isn't configured correctly, you'll encounter "
"``UnicodeEncodeError`` exceptions when saving files with file names that "
"contain non-ASCII characters."
msgstr ""
"Если вы позволяете пользователям загружать файлы, убедитесь, что окружение "
"настроено для работы с названиями файлов, которые содержат не ASCII символы. "
"Иначе вы получите ошибку ``UnicodeEncodeError`` при сохранении таких файлов."

#: ../../ref/unicode.txt:372
msgid ""
"Filesystem support for UTF-8 file names varies and might depend on the "
"environment. Check your current configuration in an interactive Python shell "
"by running::"
msgstr ""
"Поддержка файловой системой UTF-8 в названиях файлов зависит от окружения. "
"Проверьте текущие настройки в консоли Python, выполнив::"

#: ../../ref/unicode.txt:379
msgid "This should output \"UTF-8\"."
msgstr "Должно вывести \"UTF-8\"."

#: ../../ref/unicode.txt:381
msgid ""
"The ``LANG`` environment variable is responsible for setting the expected "
"encoding on Unix platforms. Consult the documentation for your operating "
"system and application server for the appropriate syntax and location to set "
"this variable."
msgstr ""
"Переменная окружения ``LANG`` отвечает за кодировку по умолчанию в Unix. "
"Обратитесь к документации вашей операционной системы и сервера, чтобы узнать "
"о настройке этого значения."

#: ../../ref/unicode.txt:386
msgid ""
"In your development environment, you might need to add a setting to your ``~."
"bashrc`` analogous to:::"
msgstr "При разработке вы можете указать настройку в ``~.bashrc``::"

# 49fd815bcaf64c539e2dc96d5e21cdfb
#: ../../ref/unicode.txt:392
msgid "Email"
msgstr "Email"

# cd6a36ea2dd04b7db4b224eeee4a8f54
#: ../../ref/unicode.txt:394
msgid ""
"Django's email framework (in ``django.core.mail``) supports Unicode "
"transparently. You can use Unicode data in the message bodies and any "
"headers. However, you're still obligated to respect the requirements of the "
"email specifications, so, for example, email addresses should use only ASCII "
"characters."
msgstr ""
"Email фреймворк Django (в ``django.core.mail``) прозрачно поддерживает "
"Unicode. Вы можете использовать Unicode данные в теле сообщения и в любых "
"заголовках. Однако, вы все еще обязаны соблюдать требования email "
"спецификаций, так, например, email адрес должен использовать только ASCII "
"символы."

# aaf669b85f19417aa4005509b319ee13
#: ../../ref/unicode.txt:400
msgid ""
"The following code example demonstrates that everything except email "
"addresses can be non-ASCII::"
msgstr ""
"Следующий пример кода демонстрирует, что все, исключая лишь email, адрес "
"может быть не-ASCII::"

# 86d4128f75744f3d97d775a87d9f77e3
#: ../../ref/unicode.txt:415
msgid "Form submission"
msgstr "Отправка формы"

# a6dd550991ab4ba692bd24b1893c042a
#: ../../ref/unicode.txt:417
msgid ""
"HTML form submission is a tricky area. There's no guarantee that the "
"submission will include encoding information, which means the framework "
"might have to guess at the encoding of submitted data."
msgstr ""
"Отправка HTML форм - это сложная область. Нет гарантии, что отправка будет "
"содержать информацию о кодировке, это означает, что фреймворк может только "
"предполагать, в какой кодировке находятся отправленные данные."

# c1d32b412f8646ce9debc6209f81a014
#: ../../ref/unicode.txt:421
msgid ""
"Django adopts a \"lazy\" approach to decoding form data. The data in an "
"``HttpRequest`` object is only decoded when you access it. In fact, most of "
"the data is not decoded at all. Only the ``HttpRequest.GET`` and "
"``HttpRequest.POST`` data structures have any decoding applied to them. "
"Those two fields will return their members as Unicode data. All other "
"attributes and methods of ``HttpRequest`` return data exactly as it was "
"submitted by the client."
msgstr ""
"Django исполузует \"ленивый\" подход для декодирования данных формы. Данные "
"в объекте ``HttpRequest`` декодируются только, когда вы обращаетесь к этому "
"объекту. А фактически многие данные не декодируются вовсе. Только "
"``HttpRequest.GET`` и ``HttpRequest.POST`` структуры могут декодироваться. "
"Эти два поля будут возвращать свои данные в Unicode.  Все остальные атрибуты "
"и методы ``HttpRequest`` возвращают данные так, как их прислал клиент."

# 53436b98a4514d41a8879ced28b99cb6
#: ../../ref/unicode.txt:429
msgid ""
"By default, the :setting:`DEFAULT_CHARSET` setting is used as the assumed "
"encoding for form data. If you need to change this for a particular form, "
"you can set the ``encoding`` attribute on an ``HttpRequest`` instance. For "
"example::"
msgstr ""
"По умолчанию параметр :setting:`DEFAULT_CHARSET` используется как "
"предполагающаяся кодировка для данных формы. Если вам нужно изменить это для "
"части форм, вы можете установить атрибут ``encoding`` для экземпляра "
"``HttpRequest``. Например:"

# bd502faf221f4096bee46ac6a5932c4a
#: ../../ref/unicode.txt:438
msgid ""
"You can even change the encoding after having accessed ``request.GET`` or "
"``request.POST``, and all subsequent accesses will use the new encoding."
msgstr ""
"Вы даже можете изменить кодировку после обращения к  ``request.GET`` или "
"``request.POST``, и все более поздние обращения будут использовать эту новую "
"кодировку."

# 2c9f5a098eb8449db22ca990f0305eee
#: ../../ref/unicode.txt:441
msgid ""
"Most developers won't need to worry about changing form encoding, but this "
"is a useful feature for applications that talk to legacy systems whose "
"encoding you cannot control."
msgstr ""
"Большинство разработчиков не захотят беспокоится об изменении кодировки, но "
"это полезная особенность для приложений, которые работают с устаревшими "
"системами, которые не могут управлять кодировкой."

# cf3ddf54f3514d5c96d8efe846000bb9
#: ../../ref/unicode.txt:445
msgid ""
"Django does not decode the data of file uploads, because that data is "
"normally treated as collections of bytes, rather than strings. Any automatic "
"decoding there would alter the meaning of the stream of bytes."
msgstr ""
"Django не декодирует данные загруженных файлов, потому что их данные обычно "
"обрабатывают как набор байтов, а не как строки. Любое автоматическое "
"декодирование здесь могло бы изменить значение потока байт. "
