# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-02-27 00:21\n"
"PO-Revision-Date: 2013-05-25 21:43+0300\n"
"Last-Translator: aum <compfaculty@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Poedit 1.5.4\n"

# 91f2c09c5e7440cc85073e9ef26d9e64
#: ../../ref/contrib/contenttypes.txt:3
msgid "The contenttypes framework"
msgstr "Фреймворк contenttypes"

# 2c14abe9b02d45a6b2a668317ff8ebd0
#: ../../ref/contrib/contenttypes.txt:8
msgid ""
"Django includes a :mod:`~django.contrib.contenttypes` application that can "
"track all of the models installed in your Django-powered project, providing "
"a high-level, generic interface for working with your models."
msgstr ""
"В Django входит приложение :mod:`~django.contrib.contenttypes`, которое "
"позволяет отслеживать все модели вашего Django проекта. Это приложение "
"предоставляет высокоуровневый, обобщенный интерфейс для работы с вашими "
"моделями."

# 599140c6a2224d1ab24fec29de4854e5
#: ../../ref/contrib/contenttypes.txt:13
msgid "Overview"
msgstr "Обзор"

# 079da12b7f38479eae83474716e7a835
#: ../../ref/contrib/contenttypes.txt:15
msgid ""
"At the heart of the contenttypes application is the :class:`~django.contrib."
"contenttypes.models.ContentType` model, which lives at ``django.contrib."
"contenttypes.models.ContentType``. Instances of :class:`~django.contrib."
"contenttypes.models.ContentType` represent and store information about the "
"models installed in your project, and new instances of :class:`~django."
"contrib.contenttypes.models.ContentType` are automatically created whenever "
"new models are installed."
msgstr ""
"В основе приложения contenttypes лежит модель   :class:`~django.contrib."
"contenttypes.models.ContentType`, которая находится в ``django.contrib."
"contenttypes.models.ContentType``. Экземпляр :class:`~django.contrib."
"contenttypes.models.ContentType` представляет и хранит информацию о "
"моделях,  использующихся в вашем проекте, и новые экземпляры модели :class:"
"`~django.contrib.contenttypes.models.ContentType` создаются автоматически "
"при добавлении новых моделей в проект."

# bd6aca470da845718d9f60dd2392ca0c
#: ../../ref/contrib/contenttypes.txt:23
msgid ""
"Instances of :class:`~django.contrib.contenttypes.models.ContentType` have "
"methods for returning the model classes they represent and for querying "
"objects from those models. :class:`~django.contrib.contenttypes.models."
"ContentType` also has a :ref:`custom manager <custom-managers>` that adds "
"methods for working with :class:`~django.contrib.contenttypes.models."
"ContentType` and for obtaining instances of :class:`~django.contrib."
"contenttypes.models.ContentType` for a particular model."
msgstr ""
"У экземпляров :class:`~django.contrib.contenttypes.models.ContentType` есть "
"методы, позволяющие получить  класс модели, который они представляют или "
"получить объект для этого класса модели. У модели :class:`~django.contrib."
"contenttypes.models.ContentType` имеется также  :ref:`собственный менеджер"
"(custom manager) <custom-managers>`, который предоставляет методы для работы "
"с классом  :class:`~django.contrib.contenttypes.models.ContentType` и для "
"получения экземпляров :class:`~django.contrib.contenttypes.models."
"ContentType` для конкретной модели. "

# 006ba2fd5e6c42609c889239ee1259cd
#: ../../ref/contrib/contenttypes.txt:31
msgid ""
"Relations between your models and :class:`~django.contrib.contenttypes."
"models.ContentType` can also be used to enable \"generic\" relationships "
"between an instance of one of your models and instances of any model you "
"have installed."
msgstr ""
"Взаимосвязь между  :class:`~django.contrib.contenttypes.models.ContentType` "
"и вашими моделями можно использовать для создания \"обобщенных\" (\"generic"
"\" ) отношений между экземпляром вашей модели и экземпляром любой другой "
"модели в проекте."

# dc22997ca6214f129e790192841e7794
#: ../../ref/contrib/contenttypes.txt:37
msgid "Installing the contenttypes framework"
msgstr "Установка и подключение contenttypes"

# f8eaffa7adf44545b65069aba64ed1a3
#: ../../ref/contrib/contenttypes.txt:39
msgid ""
"The contenttypes framework is included in the default :setting:"
"`INSTALLED_APPS` list created by ``django-admin.py startproject``, but if "
"you've removed it or if you manually set up your :setting:`INSTALLED_APPS` "
"list, you can enable it by adding ``'django.contrib.contenttypes'`` to your :"
"setting:`INSTALLED_APPS` setting."
msgstr ""
"Фреймворк contenttypes включен по умолчанию и находится в списке :setting:"
"`INSTALLED_APPS` файла настроек, созданного вызовом команды ``django-admin."
"py startproject``. Если вам необходимо отключить фреймворк или добавить его "
"вручную, просто удалите (или добавьте) в список  :setting:`INSTALLED_APPS` "
"приложение ``'django.contrib.contenttypes'``."

# 0492e79a4c0548f09089b28f79454500
#: ../../ref/contrib/contenttypes.txt:45
msgid ""
"It's generally a good idea to have the contenttypes framework installed; "
"several of Django's other bundled applications require it:"
msgstr ""
"Рекомендуется всегда подключать contenttypes фреймворк в проекте, поскольку "
"его наличие требуется для работы ряда других встроенных приложений Django."

# af475b30542e43c18b34797870eec172
#: ../../ref/contrib/contenttypes.txt:48
msgid ""
"The admin application uses it to log the history of each object added or "
"changed through the admin interface."
msgstr ""
"Встроенное приложение администрирования Django использует contenttypes для "
"ведения логов по добавлению или изменению объектов через админку. "

# f6e766cb603e4fcf8e8773ce07de1910
#: ../../ref/contrib/contenttypes.txt:51
msgid ""
"Django's :mod:`authentication framework <django.contrib.auth>` uses it to "
"tie user permissions to specific models."
msgstr ""
" :mod:`Фреймворк аутентификации <django.contrib.auth>` Django использует его "
"для привязки прав пользователя (user permissions) к определенным моделям."

# 4b64f0c90ee547b4bf51f8fff4e85e3f
#: ../../ref/contrib/contenttypes.txt:54
msgid ""
"Django's comments system (:mod:`django.contrib.comments`) uses it to \"attach"
"\" comments to any installed model."
msgstr ""
"Система комментариев Django (:mod:`django.contrib.comments`) использует "
"contenttypes для \"добавления\" комментариев к моделям."

# 534a223aaa0a452396077f118dafeeb9
#: ../../ref/contrib/contenttypes.txt:60
msgid "The ``ContentType`` model"
msgstr "Модель ``ContentType``"

# 3e9a90daea75445e9776b4d8e0a9546e
#: ../../ref/contrib/contenttypes.txt:64
msgid ""
"Each instance of :class:`~django.contrib.contenttypes.models.ContentType` "
"has three fields which, taken together, uniquely describe an installed model:"
msgstr ""
"Каждый экземпляр :class:`~django.contrib.contenttypes.models.ContentType` "
"содержит три поля, которые вместе уникальным образом описывают каждую модель "
"в приложении. "

# bfa1107e8c9245b999fb3c6ee24e01ff
#: ../../ref/contrib/contenttypes.txt:70
msgid ""
"The name of the application the model is part of. This is taken from the :"
"attr:`app_label` attribute of the model, and includes only the *last* part "
"of the application's Python import path; \"django.contrib.contenttypes\", "
"for example, becomes an :attr:`app_label` of \"contenttypes\"."
msgstr ""
"Первое, это имя приложения в которое входит данная модель. Данные берутся из "
"атрибута :attr:`app_label` модели и включают в себя только  *последнюю* "
"часть пути,  который используется для импорта модели. Н-р, в случае \"django."
"contrib.contenttypes\"  используется значение атрибута  :attr:`app_label` "
"для  \"contenttypes\"."

# f3e6e5847c1f4cc68af529012ba1a1f7
#: ../../ref/contrib/contenttypes.txt:78
msgid "The name of the model class."
msgstr "Имя модели класса"

# 6dadd49c1f3d441d84fa1f19ef928d5b
#: ../../ref/contrib/contenttypes.txt:82
msgid ""
"The human-readable name of the model. This is taken from the :attr:"
"`verbose_name <django.db.models.Field.verbose_name>` attribute of the model."
msgstr ""
"\"Читабельное\" имя модели. Берется из атрибута :attr:`verbose_name <django."
"db.models.Field.verbose_name>` модели."

# 800682d5ed77467f9a8895724b775f5c
#: ../../ref/contrib/contenttypes.txt:86
msgid ""
"Let's look at an example to see how this works. If you already have the :mod:"
"`~django.contrib.contenttypes` application installed, and then add :mod:`the "
"sites application <django.contrib.sites>` to your :setting:`INSTALLED_APPS` "
"setting and run ``manage.py syncdb`` to install it, the model :class:`django."
"contrib.sites.models.Site` will be installed into your database. Along with "
"it a new instance of :class:`~django.contrib.contenttypes.models."
"ContentType` will be created with the following values:"
msgstr ""
"Покажем на примере как это все работает. Если  приложение :mod:`~django."
"contrib.contenttypes` уже установлено, то добавьте  :mod:`приложение sites "
"<django.contrib.sites>` в :setting:`INSTALLED_APPS` файла настроек и "
"выполните команду ``manage.py syncdb`` для создания таблиц и завершения "
"установки модели :class:`django.contrib.sites.models.Site`. Параллельно с "
"этим будет создан новый экземпляр :class:`~django.contrib.contenttypes."
"models.ContentType` со следующими значениями:"

# dea5917c959c45599e35c5bba5b2e9ae
#: ../../ref/contrib/contenttypes.txt:95
msgid ""
":attr:`~django.contrib.contenttypes.models.ContentType.app_label` will be "
"set to ``'sites'`` (the last part of the Python path \"django.contrib.sites"
"\")."
msgstr ""
"Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.app_label` со "
"значением ``'sites'`` (последняя часть the last part of the Python path "
"\"django.contrib.sites\")."

# 87838eb06f0041d6af795d5f9ed1d3c0
#: ../../ref/contrib/contenttypes.txt:99
msgid ""
":attr:`~django.contrib.contenttypes.models.ContentType.model` will be set to "
"``'site'``."
msgstr ""
"Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.model` со "
"значением ``'site'``."

# 085c84d77be547b3b637821d7bb18581
#: ../../ref/contrib/contenttypes.txt:102
msgid ""
":attr:`~django.contrib.contenttypes.models.ContentType.name` will be set to "
"``'site'``."
msgstr ""
"Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.name` со "
"значением ``'site'``."

# 97f9a6a2535e415c949a4a7e8c68495d
#: ../../ref/contrib/contenttypes.txt:108
msgid "Methods on ``ContentType`` instances"
msgstr "Методы экземпляра ``ContentType``"

# d1e2bed065724885918ddc8fa4a7f144
#: ../../ref/contrib/contenttypes.txt:110
msgid ""
"Each :class:`~django.contrib.contenttypes.models.ContentType` instance has "
"methods that allow you to get from a :class:`~django.contrib.contenttypes."
"models.ContentType` instance to the model it represents, or to retrieve "
"objects from that model:"
msgstr ""
"Каждый экземпляр  :class:`~django.contrib.contenttypes.models.ContentType` "
"имеет методы, которые позволяют получить доступ к модели, представленной "
"этим экземпляром :class:`~django.contrib.contenttypes.models.ContentType` , "
"или получить объекты этой модели:"

# 5ad40ab99b424e13b8b432bcfa605a8d
#: ../../ref/contrib/contenttypes.txt:117
msgid ""
"Takes a set of valid :ref:`lookup arguments <field-lookups-intro>` for the "
"model the :class:`~django.contrib.contenttypes.models.ContentType` "
"represents, and does :meth:`a get() lookup <django.db.models.query.QuerySet."
"get>` on that model, returning the corresponding object."
msgstr ""
"Принимает набор корректных :ref:`фильтров полей(lookup arguments) <field-"
"lookups-intro>` для модели, представленной данным :class:`~django.contrib."
"contenttypes.models.ContentType` и выполняет метод :meth:`get() <django.db."
"models.query.QuerySet.get>` этой модели, возвращая соответствующий объект. "

# 13a283caa71a4463a827301d123d535f
#: ../../ref/contrib/contenttypes.txt:125
msgid ""
"Returns the model class represented by this :class:`~django.contrib."
"contenttypes.models.ContentType` instance."
msgstr ""
"Возвращает класс модели, представленной данным экземпляром :class:`~django."
"contrib.contenttypes.models.ContentType`."

# 8b1b323d94254eb8a37c28b39b953adf
#: ../../ref/contrib/contenttypes.txt:128
msgid ""
"For example, we could look up the :class:`~django.contrib.contenttypes."
"models.ContentType` for the :class:`~django.contrib.auth.models.User` model::"
msgstr ""
"Н-р, мы можем получить экземпляр  :class:`~django.contrib.contenttypes."
"models.ContentType` для модели  :class:`~django.contrib.auth.models.User` "
"следующим образом:"

# a2f3e51c42984ed099a81717f9963b15
#: ../../ref/contrib/contenttypes.txt:137
msgid ""
"And then use it to query for a particular :class:`~django.contrib.auth."
"models.User`, or to get access to the ``User`` model class::"
msgstr ""
"А затем использовать полученный результат, чтобы получить модель  :class:"
"`~django.contrib.auth.models.User`, или для непосредственного доступа к "
"классу модели ``User``::"

# 02ae6b09e72447879317680472e085be
#: ../../ref/contrib/contenttypes.txt:146
msgid ""
"Together, :meth:`~django.contrib.contenttypes.models.ContentType."
"get_object_for_this_type` and :meth:`~django.contrib.contenttypes.models."
"ContentType.model_class` enable two extremely important use cases:"
msgstr ""
"Комбинация этих двух методов  :meth:`~django.contrib.contenttypes.models."
"ContentType.get_object_for_this_type` и  :meth:`~django.contrib.contenttypes."
"models.ContentType.model_class`, дает нам два крайне важных и полезных "
"варианта их использования:"

# 94fcf19115e843f8b9cd5b074dc3d836
#: ../../ref/contrib/contenttypes.txt:151
msgid ""
"Using these methods, you can write high-level generic code that performs "
"queries on any installed model -- instead of importing and using a single "
"specific model class, you can pass an ``app_label`` and ``model`` into a :"
"class:`~django.contrib.contenttypes.models.ContentType` lookup at runtime, "
"and then work with the model class or retrieve objects from it."
msgstr ""
"Воспользовавшись этими методами, вы можете писать высокоуровневый , "
"обобщенный(generic) код,  и выполнять запрос к любой установленной в "
"приложении модели. Вместо того, чтобы импортировать конкретные модели \"по "
"одиночке\", вы можете передать нужные параметры  ``app_label`` и ``model`` в "
"класс  :class:`~django.contrib.contenttypes.models.ContentType` во время "
"выполнения, и затем работать с полученной моделью класса или получить "
"конкретные объекты этой модели."

# 71656c76f0934b85be10ad0caf60d22b
#: ../../ref/contrib/contenttypes.txt:158
msgid ""
"You can relate another model to :class:`~django.contrib.contenttypes.models."
"ContentType` as a way of tying instances of it to particular model classes, "
"and use these methods to get access to those model classes."
msgstr ""
"Вы можете использовать :class:`~django.contrib.contenttypes.models."
"ContentType` чтобы связать экземпляр вашей модели с любыми произвольными "
"классами моделей проекта, и использовать указанные методы для доступа к этим "
"моделям. "

# 14bcd38241c344a39cbf5ff6ad24551c
#: ../../ref/contrib/contenttypes.txt:163
msgid ""
"Several of Django's bundled applications make use of the latter technique. "
"For example, :class:`the permissions system <django.contrib.auth.models."
"Permission>` in Django's authentication framework uses a :class:`~django."
"contrib.auth.models.Permission` model with a foreign key to :class:`~django."
"contrib.contenttypes.models.ContentType`; this lets :class:`~django.contrib."
"auth.models.Permission` represent concepts like \"can add blog entry\" or "
"\"can delete news story\"."
msgstr ""
"Некоторые из встроенных приложений Django используют  последний подход. Н-р, "
"в  :class:`системе полномочий( permissions system) <django.contrib.auth."
"models.Permission>`, в фреймворке аутентификации  Django, в модели :class:"
"`~django.contrib.auth.models.Permission` используется внешний ключ(foreign "
"key) к :class:`~django.contrib.contenttypes.models.ContentType`; это "
"позволяет создать обобщенную связь с различными моделями и реализовать "
"концепцию ограничений, такую как \"пользователь может добавить запись в блог"
"\" или \"пользователь может удалить сообщение из новостей\"."

# 0a77d8ee31e6477f854e404a83266b2a
#: ../../ref/contrib/contenttypes.txt:173
msgid "The ``ContentTypeManager``"
msgstr " ``ContentTypeManager``"

# 03039e6e43344154ace1e0883575accb
#: ../../ref/contrib/contenttypes.txt:177
msgid ""
":class:`~django.contrib.contenttypes.models.ContentType` also has a custom "
"manager, :class:`~django.contrib.contenttypes.models.ContentTypeManager`, "
"which adds the following methods:"
msgstr ""
"Класс :class:`~django.contrib.contenttypes.models.ContentType` обладает "
"собственным менеджером, :class:`~django.contrib.contenttypes.models."
"ContentTypeManager`, который включает в себя следующие методы:"

# f44e085a36bd4bdf9954ccb6086f5d08
#: ../../ref/contrib/contenttypes.txt:183
msgid ""
"Clears an internal cache used by :class:`~django.contrib.contenttypes.models."
"ContentType` to keep track of models for which it has created :class:"
"`~django.contrib.contenttypes.models.ContentType` instances. You probably "
"won't ever need to call this method yourself; Django will call it "
"automatically when it's needed."
msgstr ""
"Очищает внутренний кэш, используемый :class:`~django.contrib.contenttypes."
"models.ContentType` для отслеживания моделей, для которых были созданы "
"экземпляры  :class:`~django.contrib.contenttypes.models.ContentType`. "
"Вероятно, вам никогда не придется вызывать этот метод напрямую, поскольку  "
"Django  вызывает его автоматически, при необходимости."

# 7f6994c5b78c4d1c83dfd628c7900e22
#: ../../ref/contrib/contenttypes.txt:192
msgid ""
"Lookup a :class:`~django.contrib.contenttypes.models.ContentType` by ID. "
"Since this method uses the same shared cache as :meth:`~django.contrib."
"contenttypes.models.ContentTypeManager.get_for_model`, it's preferred to use "
"this method over the usual ``ContentType.objects.get(pk=id)``"
msgstr ""
"Получить экземпляр  :class:`~django.contrib.contenttypes.models.ContentType` "
"по идентификатору(ID).  Поскольку метод использует тот же разделяемый кэш, "
"что и метод  :meth:`~django.contrib.contenttypes.models.ContentTypeManager."
"get_for_model`, предпочтительней пользоваться именно им, а не привычным "
"запросом ``ContentType.objects.get(pk=id)``."

# b3846d5c1b1945c1806163a8eae6ca72
#: ../../ref/contrib/contenttypes.txt:200
msgid ""
"Takes either a model class or an instance of a model, and returns the :class:"
"`~django.contrib.contenttypes.models.ContentType` instance representing that "
"model."
msgstr ""
"Принимает в качестве аргумента либо класс модели, либо экземпляр модели, и "
"возвращает экземпляр :class:`~django.contrib.contenttypes.models."
"ContentType`, представляющего данную модель."

# 746fd992b5174587b81d0c9d793d0bda
#: ../../ref/contrib/contenttypes.txt:206
msgid ""
"Takes a variadic number of model classes, and returns a dictionary mapping "
"the model classes to the :class:`~django.contrib.contenttypes.models."
"ContentType` instances representing them."
msgstr ""
"Принимает в качестве аргумента произвольное число классов модели и "
"возвращает словарь с отображением класса модели на экземпляр  :class:"
"`~django.contrib.contenttypes.models.ContentType`, представляющего данную "
"модель."

# 1cec42baac0b4352bbb804489d2dbaaa
#: ../../ref/contrib/contenttypes.txt:213
msgid ""
"Returns the :class:`~django.contrib.contenttypes.models.ContentType` "
"instance uniquely identified by the given application label and model name. "
"The primary purpose of this method is to allow :class:`~django.contrib."
"contenttypes.models.ContentType` objects to be referenced via a :ref:"
"`natural key<topics-serialization-natural-keys>` during deserialization."
msgstr ""
"Возвращает экземпляр  :class:`~django.contrib.contenttypes.models."
"ContentType`,  определенный уникальным образом для переданных аргументов: "
"имя приложения(application label) и имя модели(model name). Главное "
"назначение этого метода, дать возможность ссылаться на объекты  :class:"
"`~django.contrib.contenttypes.models.ContentType` посредством :ref:"
"`натуральных ключей(natural key)<topics-serialization-natural-keys>` в "
"процессе десериализации. "

# c76b1a724db744c58d5a42f458c8e4c2
#: ../../ref/contrib/contenttypes.txt:220
msgid ""
"The :meth:`~ContentTypeManager.get_for_model()` method is especially useful "
"when you know you need to work with a :class:`ContentType <django.contrib."
"contenttypes.models.ContentType>` but don't want to go to the trouble of "
"obtaining the model's metadata to perform a manual lookup::"
msgstr ""
"Метод  :meth:`~ContentTypeManager.get_for_model()` особенно полезен, когда "
"вам необходимо работать с  :class:`ContentType <django.contrib.contenttypes."
"models.ContentType>`, но вы не хотите \"заморачиваться\" с получением "
"метаданных модели для  поиска вручную::"

# d68684b8f9b04461acbbe1d241e7444f
#: ../../ref/contrib/contenttypes.txt:237
msgid ""
"Prior to Django 1.5, :meth:`~django.contrib.contenttypes.models."
"ContentTypeManager.get_for_model` and :meth:`~django.contrib.contenttypes."
"models.ContentTypeManager.get_for_models` always returned the :class:"
"`~django.contrib.contenttypes.models.ContentType` associated with the "
"concrete model of the specified one(s). That means there was no way to "
"retrieve the :class:`~django.contrib.contenttypes.models.ContentType` of a "
"proxy model using those methods. As of Django 1.5 you can now pass a boolean "
"flag – ``for_concrete_model`` and ``for_concrete_models`` respectively – to "
"specify wether or not you want to retrieve the :class:`~django.contrib."
"contenttypes.models.ContentType` for the concrete or direct model."
msgstr ""
"До Django 1.5, методы :meth:`~django.contrib.contenttypes.models."
"ContentTypeManager.get_for_model` и :meth:`~django.contrib.contenttypes."
"models.ContentTypeManager.get_for_models` всегда возвращали :class:`~django."
"contrib.contenttypes.models.ContentType`, связанный с конкретной указанной "
"моделью или моделями.  Это означало, что нет возможности получить :class:"
"`~django.contrib.contenttypes.models.ContentType` прокси-модели(proxy "
"model), используя данные методы. В Django 1.5  вы можете передать флажок с "
"булевым значением  – ``for_concrete_model`` и ``for_concrete_models`` "
"соответственно, чтобы указать желаете ли вы или нет получить экземпляр :"
"class:`~django.contrib.contenttypes.models.ContentType` для конкретной или "
"прямой модели(direct model)."

# 412196fce96143ba9bb7d99b53b127a4
#: ../../ref/contrib/contenttypes.txt:251
msgid "Generic relations"
msgstr "Обобщенные связи(generic relations)"

# 53a3a3133ef3443fb0c097f71b9b1341
#: ../../ref/contrib/contenttypes.txt:253
msgid ""
"Adding a foreign key from one of your own models to :class:`~django.contrib."
"contenttypes.models.ContentType` allows your model to effectively tie itself "
"to another model class, as in the example of the :class:`~django.contrib."
"auth.models.Permission` model above. But it's possible to go one step "
"further and use :class:`~django.contrib.contenttypes.models.ContentType` to "
"enable truly generic (sometimes called \"polymorphic\") relationships "
"between models."
msgstr ""
"Вы можете создать в вашей модели внешний ключ на  :class:`~django.contrib."
"contenttypes.models.ContentType`, что позволит связать вашу модель с любой "
"другой моделью, как это было описано выше на  примере :class:`~django."
"contrib.auth.models.Permission`. Но можно пойти еще дальше и использовать  :"
"class:`~django.contrib.contenttypes.models.ContentType` для реализации "
"абсолютно обобщенных (иногда говорят \"полиморфных\") отношений между "
"моделями. "

# 1788c3c02ac2491686f0db33450f8bc8
#: ../../ref/contrib/contenttypes.txt:261
msgid "A simple example is a tagging system, which might look like this::"
msgstr ""
"Вот простой пример: реализуем систему тэгов(ярлычков), которая могла бы "
"выглядеть так ::"

# df84598472a0406f8911f0ec0dcdd84f
#: ../../ref/contrib/contenttypes.txt:276
msgid ""
"A normal :class:`~django.db.models.ForeignKey` can only \"point to\" one "
"other model, which means that if the ``TaggedItem`` model used a :class:"
"`~django.db.models.ForeignKey` it would have to choose one and only one "
"model to store tags for. The contenttypes application provides a special "
"field type (``GenericForeignKey``) which works around this and allows the "
"relationship to be with any model:"
msgstr ""
"Обычное поле  :class:`~django.db.models.ForeignKey` может  \"указывать\" "
"только на одну модель, что означает, - если в модели ``TaggedItem``  есть "
"поле :class:`~django.db.models.ForeignKey`, его можно \"связать\" с одной и "
"только одной моделью, для которой и будут сохраняться тэги. Приложение "
"contenttypes предоставляет нам поле специального типа "
"(``GenericForeignKey``), которое решает обозначенную выше проблему и "
"позволяет создать связь с любой моделью:"

# 2cef3b75b18a47779340663c6a3cd0a0
#: ../../ref/contrib/contenttypes.txt:286
msgid ""
"There are three parts to setting up a :class:`~django.contrib.contenttypes."
"generic.GenericForeignKey`:"
msgstr ""
"Существуют три правила по созданию и настройке :class:`~django.contrib."
"contenttypes.generic.GenericForeignKey`:"

# d20dd6083d6f47f9be98d85b46b47b13
#: ../../ref/contrib/contenttypes.txt:289
msgid ""
"Give your model a :class:`~django.db.models.ForeignKey` to :class:`~django."
"contrib.contenttypes.models.ContentType`. The usual name for this field is "
"\"content_type\"."
msgstr ""
"Создайте в вашей модели поле  типа :class:`~django.db.models.ForeignKey`, "
"указав в качестве внешней модели :class:`~django.contrib.contenttypes.models."
"ContentType`. Обычно такому полю дают имя \"content_type\"."

# b27f2459683b4c9ca10e24b869b3c84b
#: ../../ref/contrib/contenttypes.txt:293
msgid ""
"Give your model a field that can store primary key values from the models "
"you'll be relating to. For most models, this means a :class:`~django.db."
"models.PositiveIntegerField`. The usual name for this field is \"object_id\"."
msgstr ""
"Создайте в вашей модели поле, которое будет хранить значения первичных "
"ключей экземпляров модели, с которой вы создаете связь. Для большинства "
"моделей, это поле типа  :class:`~django.db.models.PositiveIntegerField`. "
"Обычно такому полю дают имя \"object_id\"."

# df4263a031fe4a7e9137db231f98c103
#: ../../ref/contrib/contenttypes.txt:298
msgid ""
"Give your model a :class:`~django.contrib.contenttypes.generic."
"GenericForeignKey`, and pass it the names of the two fields described above. "
"If these fields are named \"content_type\" and \"object_id\", you can omit "
"this -- those are the default field names :class:`~django.contrib."
"contenttypes.generic.GenericForeignKey` will look for."
msgstr ""
"Создайте в вашей модели поле типа :class:`~django.contrib.contenttypes."
"generic.GenericForeignKey`, и передайте ему в качестве аргументов,  имена "
"полей созданных ранее. Если эти поля названы \"content_type\" и \"object_id"
"\", вы можете не передавать их, -- эти имена используются в :class:`~django."
"contrib.contenttypes.generic.GenericForeignKey` по умолчанию."

# 1b2af1f608734cb088e1baba68ad168b
#: ../../ref/contrib/contenttypes.txt:308
msgid ""
"The \"object_id\" field doesn't have to be the same type as the primary key "
"fields on the related models, but their primary key values must be coercible "
"to the same type as the \"object_id\" field by its :meth:`~django.db.models."
"Field.get_db_prep_value` method."
msgstr ""
"Поле \"object_id\" не обязательно должно быть того же типа, что и у "
"первичного ключа в привязанной модели, но должно соблюдаться условие, что "
"значения первичного ключа могут быть приведены к тому же типу, что и у поля  "
"\"object_id \" методом :meth:`~django.db.models.Field.get_db_prep_value`."

# 2c31082624a84c93bc7940020fd66ad9
#: ../../ref/contrib/contenttypes.txt:313
msgid ""
"For example, if you want to allow generic relations to models with either :"
"class:`~django.db.models.IntegerField` or :class:`~django.db.models."
"CharField` primary key fields, you can use :class:`~django.db.models."
"CharField` for the \"object_id\" field on your model since integers can be "
"coerced to strings by :meth:`~django.db.models.Field.get_db_prep_value`."
msgstr ""
"Н-р, если вы хотите создать обобщенные отношения с моделями, использующими в "
"качестве первичных ключей типы :class:`~django.db.models.IntegerField` или :"
"class:`~django.db.models.CharField`, вы можете использовать тип :class:"
"`~django.db.models.CharField` для вашего поля  \"object_id\", поскольку "
"целочисленные значения могут быть корректно приведены к строковым методом :"
"meth:`~django.db.models.Field.get_db_prep_value`."

# f6f1493e1187427f85f967d66651f038
#: ../../ref/contrib/contenttypes.txt:320
msgid ""
"For maximum flexibility you can use a :class:`~django.db.models.TextField` "
"which doesn't have a maximum length defined, however this may incur "
"significant performance penalties depending on your database backend."
msgstr ""
"Для максимальной гибкости можно использовать тип :class:`~django.db.models."
"TextField`, который не накладывает ограничения на длину строки, но такое "
"решение может негативно отразиться на производительности, в зависимости от "
"используемой  базы данных."

# 33b84b4ebc664521b03f3cae6ccfb001
#: ../../ref/contrib/contenttypes.txt:325
msgid ""
"There is no one-size-fits-all solution for which field type is best. You "
"should evaluate the models you expect to be pointing to and determine which "
"solution will be most effective for your use case."
msgstr ""
"Не  существует универсального решения для выбора наилучшего типа поля. Вы "
"должны изучить модели с которыми собираетесь работать, и на основании этого "
"принять решение о выборе типа для поля, руководствуясь принципами "
"эффективности."

# 70fc4a6975e74ccf90ffec2156fb46bc
#: ../../ref/contrib/contenttypes.txt:331
msgid ""
"If you're serializing data (for example, when generating :class:`~django."
"test.TestCase.fixtures`) from a model that implements generic relations, you "
"should probably be using a natural key to uniquely identify related :class:"
"`~django.contrib.contenttypes.models.ContentType` objects. See :ref:`natural "
"keys<topics-serialization-natural-keys>` and :djadminopt:`dumpdata --natural "
"<--natural>` for more information."
msgstr ""
"При сериализации данных модели (н-р, при создании :class:`~django.test."
"TestCase.fixtures`) , которая имеет обобщенные связи, вам вероятно "
"необходимо будет воспользоваться натуральным ключем, чтобы корректно "
"определить связи с объектами  :class:`~django.contrib.contenttypes.models."
"ContentType`. Смотрите :ref:`натуральные ключи(natural keys)<topics-"
"serialization-natural-keys>` и :djadminopt:`dumpdata --natural <--natural>` "
"для дополнительной информации."

# 69f4abbb26c34545b3ef1bd6d3db6638
#: ../../ref/contrib/contenttypes.txt:338
msgid ""
"This will enable an API similar to the one used for a normal :class:`~django."
"db.models.ForeignKey`; each ``TaggedItem`` will have a ``content_object`` "
"field that returns the object it's related to, and you can also assign to "
"that field or use it when creating a ``TaggedItem``::"
msgstr ""
"После создания связи мы можем использовать  API, похожий на тот, что "
"используется в обычном   :class:`~django.db.models.ForeignKey`; каждый "
"``TaggedItem`` содержит поле ``content_object``, которое возвращает "
"связанный с ним объект. Мы можем присвоить этому полю произвольный объект, "
"или указать этот объект при создании ``TaggedItem``::"

# b78caf773d994e5abf15e368f48d7b9a
#: ../../ref/contrib/contenttypes.txt:351
msgid ""
"Due to the way :class:`~django.contrib.contenttypes.generic."
"GenericForeignKey` is implemented, you cannot use such fields directly with "
"filters (``filter()`` and ``exclude()``, for example) via the database API. "
"Because a :class:`~django.contrib.contenttypes.generic.GenericForeignKey` "
"isn't a normal field object, these examples will *not* work::"
msgstr ""
"Из-за особенностей реализации :class:`~django.contrib.contenttypes.generic."
"GenericForeignKey`, вы не можете использовать такое поле с фильтрами "
"(``filter()`` и  ``exclude()``, н-р) в запросах API базы данных. Поскольку  :"
"class:`~django.contrib.contenttypes.generic.GenericForeignKey` это не совсем "
"\"обычное\" поле,примеры ниже  *не будут работать*::"

# 4681d81cdc714fe5a13cfc63fdf52463
#: ../../ref/contrib/contenttypes.txt:363
msgid "Reverse generic relations"
msgstr "Обратная обобщенная связь(reverse generic relations)"

# e2f739f4d56b43dcaba71eebd060443d
#: ../../ref/contrib/contenttypes.txt:367
msgid ""
"If you know which models you'll be using most often, you can also add a "
"\"reverse\" generic relationship to enable an additional API. For example::"
msgstr ""
"Если модель, с которой предстоит работать наиболее часто, известна заранее, "
"вы можете добавить \"обратную\" обобщенную связь между моделями и "
"использовать дополнительные возможности API. Н-р::"

# 052a8835037244cd94ff61232ef32707
#: ../../ref/contrib/contenttypes.txt:374
msgid ""
"``Bookmark`` instances will each have a ``tags`` attribute, which can be "
"used to retrieve their associated ``TaggedItems``::"
msgstr ""
"Каждый экземпляр ``Bookmark`` имеет атрибут ``tags``, который можно "
"использовать чтобы получить доступ к связанному с ним ``TaggedItems``::"

# 972e3b39cb0b4e6596ff185d0e39eac5
#: ../../ref/contrib/contenttypes.txt:386
msgid ""
"Just as :class:`~django.contrib.contenttypes.generic.GenericForeignKey` "
"accepts the names of the content-type and object-ID fields as arguments, so "
"too does :class:`~django.contrib.contenttypes.generic.GenericRelation`; if "
"the model which has the generic foreign key is using non-default names for "
"those fields, you must pass the names of the fields when setting up a :class:"
"`.GenericRelation` to it. For example, if the ``TaggedItem`` model referred "
"to above used fields named ``content_type_fk`` and ``object_primary_key`` to "
"create its generic foreign key, then a :class:`.GenericRelation` back to it "
"would need to be defined like so::"
msgstr ""
"Также как :class:`~django.contrib.contenttypes.generic.GenericForeignKey`, :"
"class:`~django.contrib.contenttypes.generic.GenericRelation` принимает "
"аргументами имена полей content-type и object-ID  . Если модель, имеющая "
"обобщенный внешний ключ *не* использует имена по-умолчанию для этих полей, а "
"любые другие, -- вы должны передать эти имена полей в  :class:`."
"GenericRelation` при его инициализации. Н-р, если бы мы использовали в "
"модели ``TaggedItem`` поля с именами ``content_type_fk`` и "
"``object_primary_key`` при создании внешнего ключа, то поле :class:`."
"GenericRelation` следовало бы определить таким образом::"

# fbb28a284f304a5a8ab5b5ce6b9bccc3
#: ../../ref/contrib/contenttypes.txt:401
msgid ""
"Of course, if you don't add the reverse relationship, you can do the same "
"types of lookups manually::"
msgstr ""
"Ну и конечно, если вы не захотите добавить обратную связь, вы можете "
"получить доступ к объекту  и \"обходным путем\"::"

# 8d569027a05042ec891357b5cdf7dfda
#: ../../ref/contrib/contenttypes.txt:410
msgid ""
"Note that if the model in a :class:`~django.contrib.contenttypes.generic."
"GenericRelation` uses a non-default value for ``ct_field`` or ``fk_field`` "
"in its :class:`~django.contrib.contenttypes.generic.GenericForeignKey` (e.g. "
"the :mod:`django.contrib.comments` app uses ``ct_field=\"object_pk\"``), "
"you'll need to set ``content_type_field`` and/or ``object_id_field`` in the :"
"class:`~django.contrib.contenttypes.generic.GenericRelation` to match the "
"``ct_field`` and ``fk_field``, respectively, in the :class:`~django.contrib."
"contenttypes.generic.GenericForeignKey`::"
msgstr ""
"Обратите внимание, если в модели с  :class:`~django.contrib.contenttypes."
"generic.GenericRelation` не используются значения по умолчанию для "
"``ct_field`` или ``fk_field`` для :class:`~django.contrib.contenttypes."
"generic.GenericForeignKey` (н-р, в  приложении :mod:`django.contrib."
"comments` используются ``ct_field=\"object_pk\"``), вам необходимо "
"установить  ``content_type_field`` и/или ``object_id_field`` таким образом, "
"чтобы значения  ``ct_field`` и ``fk_field`` в :class:`~django.contrib."
"contenttypes.generic.GenericRelation` соответствовали  значениям  для "
"``ct_field`` и ``fk_field`` в модели содержащей  :class:`~django.contrib."
"contenttypes.generic.GenericForeignKey`::"

# d08f2da79a6f436bab2ddce6c9e80fcd
#: ../../ref/contrib/contenttypes.txt:422
msgid ""
"Note also, that if you delete an object that has a :class:`~django.contrib."
"contenttypes.generic.GenericRelation`, any objects which have a :class:"
"`~django.contrib.contenttypes.generic.GenericForeignKey` pointing at it will "
"be deleted as well. In the example above, this means that if a ``Bookmark`` "
"object were deleted, any ``TaggedItem`` objects pointing at it would be "
"deleted at the same time."
msgstr ""
"Также обратите внимание, что в случае удаления объекта, имеющего поле :class:"
"`~django.contrib.contenttypes.generic.GenericRelation`, все объекты у "
"которых :class:`~django.contrib.contenttypes.generic.GenericForeignKey` "
"указывает на этот удаляемый объект,  тоже будут удалены. Для примера выше "
"это значит, что если удалить объект ``Bookmark``, то любые ``TaggedItem``, "
"связанные с ним, будут удалены вместе с ним."

# acf377f93f2a462c8c7604514fdd3897
#: ../../ref/contrib/contenttypes.txt:429
msgid ""
"Unlike :class:`~django.db.models.ForeignKey`, :class:`~django.contrib."
"contenttypes.generic.GenericForeignKey` does not accept an :attr:`~django.db."
"models.ForeignKey.on_delete` argument to customize this behavior; if "
"desired, you can avoid the cascade-deletion simply by not using :class:"
"`~django.contrib.contenttypes.generic.GenericRelation`, and alternate "
"behavior can be provided via the :data:`~django.db.models.signals."
"pre_delete` signal."
msgstr ""
"В отличии от обычного  :class:`~django.db.models.ForeignKey`, тип  :class:"
"`~django.contrib.contenttypes.generic.GenericForeignKey` не принимает "
"аргумент :attr:`~django.db.models.ForeignKey.on_delete` для расширения "
"поведения модели; если это необходимо, вы можете избежать каскадного "
"удаления связанных объектов просто не используя :class:`~django.contrib."
"contenttypes.generic.GenericRelation`,  и указать необходимое поведение с "
"помощью сигнала :data:`~django.db.models.signals.pre_delete`."

# eef5bbe015824a048689cb9114c55b4f
#: ../../ref/contrib/contenttypes.txt:438
msgid "Generic relations and aggregation"
msgstr "Обобщенные связи и агрегация"

# 1ba53a312b0d4d0e8f0df34e1185fa61
#: ../../ref/contrib/contenttypes.txt:440
msgid ""
":doc:`Django's database aggregation API </topics/db/aggregation>` doesn't "
"work with a :class:`~django.contrib.contenttypes.generic.GenericRelation`. "
"For example, you might be tempted to try something like::"
msgstr ""
":doc:`API агрегации Django для баз данных </topics/db/aggregation>` не "
"работает с :class:`~django.contrib.contenttypes.generic.GenericRelation`. Н-"
"р, у вас могло бы возникнуть желание попытаться сделать нечто подобное::"

# d81ec2c1b1024ae88387c6f571bc2f66
#: ../../ref/contrib/contenttypes.txt:447
msgid ""
"This will not work correctly, however. The generic relation adds extra "
"filters to the queryset to ensure the correct content type, but the :meth:"
"`~django.db.models.query.QuerySet.aggregate` method doesn't take them into "
"account. For now, if you need aggregates on generic relations, you'll need "
"to calculate them without using the aggregation API."
msgstr ""
"Тем не менее, это не сработает так,  как вы ожидаете.  Обобщенные связи "
"используют дополнительные фильтры в запросе(queryset), чтобы гарантировать "
"непротиворечивость контентного типа, но метод  :meth:`~django.db.models."
"query.QuerySet.aggregate` не принимает это в расчет. К настоящему моменту, "
"если вам необходимо выполнить агрегирующие запросы с объектами с обобщенной "
"связью, вы должны выполнить это другими методами, не используя  возможности "
"API для агрегации. "

# 328c1d1a58814a7ba03e57b28efaa225
#: ../../ref/contrib/contenttypes.txt:454
msgid "Generic relations in forms and admin"
msgstr "Обобщенные связи в формах и администрировании"

# ac3cbbcf9fbe4bc0a32c9357407a8fd9
#: ../../ref/contrib/contenttypes.txt:456
msgid "The :mod:`django.contrib.contenttypes.generic` module provides:"
msgstr ""
"Модуль :mod:`django.contrib.contenttypes.generic` предлагает нам следующее:"

# 2489514b9b3845079c975c111ee870ce
#: ../../ref/contrib/contenttypes.txt:458
msgid "``BaseGenericInlineFormSet``"
msgstr "``BaseGenericInlineFormSet``"

# dcb91af1e319456b9eac1f2a0bc55aa2
#: ../../ref/contrib/contenttypes.txt:459
msgid ""
":class:`~django.contrib.contenttypes.generic.GenericTabularInline` and :"
"class:`~django.contrib.contenttypes.generic.GenericStackedInline` "
"(subclasses of :class:`~django.contrib.contenttypes.generic."
"GenericInlineModelAdmin`)"
msgstr ""
"Классы :class:`~django.contrib.contenttypes.generic.GenericTabularInline` и :"
"class:`~django.contrib.contenttypes.generic.GenericStackedInline` "
"(подклассы  :class:`~django.contrib.contenttypes.generic."
"GenericInlineModelAdmin`)"

# 07c4b940aa564ec38441ba867366d44c
#: ../../ref/contrib/contenttypes.txt:463
msgid ""
"A formset factory, :func:`generic_inlineformset_factory`, for use with :"
"class:`GenericForeignKey`"
msgstr ""
"Набор форм, :func:`generic_inlineformset_factory`, для использования с :"
"class:`GenericForeignKey`"

# df340e0f994b4004902b05aedc152128
#: ../../ref/contrib/contenttypes.txt:466
msgid ""
"These classes and functions enable the use of generic relations in forms and "
"the admin. See the :doc:`model formset </topics/forms/modelforms>` and :ref:"
"`admin <using-generic-relations-as-an-inline>` documentation for more "
"information."
msgstr ""
"Эти классы и функции позволяют использовать обобщенные отношения объектов "
"при создании форм и в админке Django. За дополнительной информацией "
"обратитесь к  :doc:`модель набора форм </topics/forms/modelforms>` и :ref:"
"`admin <using-generic-relations-as-an-inline>` ."

# 1afefc476ad34f268ba7d1dbed48e4ba
#: ../../ref/contrib/contenttypes.txt:473
msgid ""
"The :class:`~django.contrib.contenttypes.generic.GenericInlineModelAdmin` "
"class inherits all properties from an :class:`~django.contrib.admin."
"InlineModelAdmin` class. However, it adds a couple of its own for working "
"with the generic relation:"
msgstr ""
"Класс :class:`~django.contrib.contenttypes.generic.GenericInlineModelAdmin` "
"наследует все свойства класса :class:`~django.contrib.admin."
"InlineModelAdmin`. Но также имеет ряд собственных атрибутов для работы с "
"обобщенными связями:"

# 77542e530d1e4d59829b55f58410cd41
#: ../../ref/contrib/contenttypes.txt:480
msgid ""
"The name of the :class:`~django.contrib.contenttypes.models.ContentType` "
"foreign key field on the model. Defaults to ``content_type``."
msgstr ""
"Имя поля внешнего ключа :class:`~django.contrib.contenttypes.models."
"ContentType` модели. По умолчанию ``content_type``."

# 9135be9a61844c9b99d5d3b772d3bbf8
#: ../../ref/contrib/contenttypes.txt:486
msgid ""
"The name of the integer field that represents the ID of the related object. "
"Defaults to ``object_id``."
msgstr ""
"Имя целочисленного поля, которое хранит идентификатор конкретного объекта "
"связанной модели. По умолчанию ``object_id``."

# 72c63dad6bae424f819ed3972c22c1dc
#: ../../ref/contrib/contenttypes.txt:492
msgid ""
"Subclasses of :class:`GenericInlineModelAdmin` with stacked and tabular "
"layouts, respectively."
msgstr ""
"Подклассы  :class:`GenericInlineModelAdmin` позволяющие настраивать "
"отображение данных в сложенном(stacked) или табличном(tabular) виде, "
"соответственно."

# 5a8f6401216b4a7887bb98050e582790
#: ../../ref/contrib/contenttypes.txt:497
msgid ""
"Returns a ``GenericInlineFormSet`` using :func:`~django.forms.models."
"modelformset_factory`."
msgstr ""
"Возвращает ``GenericInlineFormSet``, используя :func:`~django.forms.models."
"modelformset_factory`."

# 5242e05ea32f470fad100c82c4f1bd99
#: ../../ref/contrib/contenttypes.txt:500
msgid ""
"You must provide ``ct_field`` and ``object_id`` if they different from the "
"defaults, ``content_type`` and ``object_id`` respectively. Other parameters "
"are similar to those documented in :func:`~django.forms.models."
"modelformset_factory` and :func:`~django.forms.models.inlineformset_factory`."
msgstr ""
"Вы должны предоставить имена для ``ct_field`` и ``object_id`` если они "
"отличаются от значений по умолчанию, - ``content_type`` и ``object_id``.  "
"Прочие параметры похожи на те, что описываются в  :func:`~django.forms."
"models.modelformset_factory` и :func:`~django.forms.models."
"inlineformset_factory`."
