# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2012.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-16 11:56+0200\n"
"PO-Revision-Date: 2017-11-17 17:57+0200\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 91f2c09c5e7440cc85073e9ef26d9e64
#: ../../ref/contrib/contenttypes.txt:3
msgid "The contenttypes framework"
msgstr "Фреймворк contenttypes"

# 2c14abe9b02d45a6b2a668317ff8ebd0
#: ../../ref/contrib/contenttypes.txt:8
msgid ""
"Django includes a :mod:`~django.contrib.contenttypes` application that can "
"track all of the models installed in your Django-powered project, providing "
"a high-level, generic interface for working with your models."
msgstr ""
"В Django входит приложение :mod:`~django.contrib.contenttypes`, которое "
"позволяет отслеживать все модели вашего Django проекта. Это приложение "
"предоставляет высокоуровневый, обобщенный интерфейс для работы с вашими "
"моделями."

# 599140c6a2224d1ab24fec29de4854e5
#: ../../ref/contrib/contenttypes.txt:13
msgid "Overview"
msgstr "Обзор"

# 079da12b7f38479eae83474716e7a835
#: ../../ref/contrib/contenttypes.txt:15
msgid ""
"At the heart of the contenttypes application is the :class:`~django.contrib."
"contenttypes.models.ContentType` model, which lives at ``django.contrib."
"contenttypes.models.ContentType``. Instances of :class:`~django.contrib."
"contenttypes.models.ContentType` represent and store information about the "
"models installed in your project, and new instances of :class:`~django."
"contrib.contenttypes.models.ContentType` are automatically created whenever "
"new models are installed."
msgstr ""
"В основе приложения contenttypes лежит модель   :class:`~django.contrib."
"contenttypes.models.ContentType`, которая находится в ``django.contrib."
"contenttypes.models.ContentType``. Экземпляр :class:`~django.contrib."
"contenttypes.models.ContentType` представляет и хранит информацию о "
"моделях,  использующихся в вашем проекте, и новые экземпляры модели :class:"
"`~django.contrib.contenttypes.models.ContentType` создаются автоматически "
"при добавлении новых моделей в проект."

# bd6aca470da845718d9f60dd2392ca0c
#: ../../ref/contrib/contenttypes.txt:23
msgid ""
"Instances of :class:`~django.contrib.contenttypes.models.ContentType` have "
"methods for returning the model classes they represent and for querying "
"objects from those models. :class:`~django.contrib.contenttypes.models."
"ContentType` also has a :ref:`custom manager <custom-managers>` that adds "
"methods for working with :class:`~django.contrib.contenttypes.models."
"ContentType` and for obtaining instances of :class:`~django.contrib."
"contenttypes.models.ContentType` for a particular model."
msgstr ""
"У экземпляров :class:`~django.contrib.contenttypes.models.ContentType` есть "
"методы, позволяющие получить  класс модели, который они представляют или "
"получить объект для этого класса модели. У модели :class:`~django.contrib."
"contenttypes.models.ContentType` имеется также  :ref:`собственный "
"менеджер(custom manager) <custom-managers>`, который предоставляет методы "
"для работы с классом  :class:`~django.contrib.contenttypes.models."
"ContentType` и для получения экземпляров :class:`~django.contrib."
"contenttypes.models.ContentType` для конкретной модели. "

# 006ba2fd5e6c42609c889239ee1259cd
#: ../../ref/contrib/contenttypes.txt:31
msgid ""
"Relations between your models and :class:`~django.contrib.contenttypes."
"models.ContentType` can also be used to enable \"generic\" relationships "
"between an instance of one of your models and instances of any model you "
"have installed."
msgstr ""
"Взаимосвязь между  :class:`~django.contrib.contenttypes.models.ContentType` "
"и вашими моделями можно использовать для создания \"обобщенных\" (\"generic"
"\" ) отношений между экземпляром вашей модели и экземпляром любой другой "
"модели в проекте."

# dc22997ca6214f129e790192841e7794
#: ../../ref/contrib/contenttypes.txt:37
msgid "Installing the contenttypes framework"
msgstr "Установка и подключение contenttypes"

# f8eaffa7adf44545b65069aba64ed1a3
#: ../../ref/contrib/contenttypes.txt:39
msgid ""
"The contenttypes framework is included in the default :setting:"
"`INSTALLED_APPS` list created by ``django-admin startproject``, but if "
"you've removed it or if you manually set up your :setting:`INSTALLED_APPS` "
"list, you can enable it by adding ``'django.contrib.contenttypes'`` to your :"
"setting:`INSTALLED_APPS` setting."
msgstr ""
"Фреймворк contenttypes включен по умолчанию и находится в списке :setting:"
"`INSTALLED_APPS` файла настроек, созданного вызовом команды ``django-admin "
"startproject``. Если вам необходимо отключить фреймворк или добавить его "
"вручную, просто удалите (или добавьте) в список  :setting:`INSTALLED_APPS` "
"приложение ``'django.contrib.contenttypes'``."

# 0492e79a4c0548f09089b28f79454500
#: ../../ref/contrib/contenttypes.txt:45
msgid ""
"It's generally a good idea to have the contenttypes framework installed; "
"several of Django's other bundled applications require it:"
msgstr ""
"Рекомендуется всегда подключать contenttypes фреймворк в проекте, поскольку "
"его наличие требуется для работы ряда других встроенных приложений Django."

# af475b30542e43c18b34797870eec172
#: ../../ref/contrib/contenttypes.txt:48
msgid ""
"The admin application uses it to log the history of each object added or "
"changed through the admin interface."
msgstr ""
"Встроенное приложение администрирования Django использует contenttypes для "
"ведения логов по добавлению или изменению объектов через админку. "

# f6e766cb603e4fcf8e8773ce07de1910
#: ../../ref/contrib/contenttypes.txt:51
msgid ""
"Django's :mod:`authentication framework <django.contrib.auth>` uses it to "
"tie user permissions to specific models."
msgstr ""
" :mod:`Фреймворк аутентификации <django.contrib.auth>` Django использует его "
"для привязки прав пользователя (user permissions) к определенным моделям."

# 534a223aaa0a452396077f118dafeeb9
#: ../../ref/contrib/contenttypes.txt:57
msgid "The ``ContentType`` model"
msgstr "Модель ``ContentType``"

# 3e9a90daea75445e9776b4d8e0a9546e
#: ../../ref/contrib/contenttypes.txt:61
msgid ""
"Each instance of :class:`~django.contrib.contenttypes.models.ContentType` "
"has two fields which, taken together, uniquely describe an installed model:"
msgstr ""
"Каждый экземпляр :class:`~django.contrib.contenttypes.models.ContentType` "
"содержит два поля, которые вместе уникальным образом описывают каждую модель "
"в приложении:"

# bfa1107e8c9245b999fb3c6ee24e01ff
#: ../../ref/contrib/contenttypes.txt:67
msgid ""
"The name of the application the model is part of. This is taken from the :"
"attr:`app_label` attribute of the model, and includes only the *last* part "
"of the application's Python import path; ``django.contrib.contenttypes``, "
"for example, becomes an :attr:`app_label` of ``contenttypes``."
msgstr ""
"Имя приложения в которое входит данная модель. Данные берутся из атрибута :"
"attr:`app_label` модели и включают в себя только  *последнюю* часть пути,  "
"который используется для импорта модели. Н-р, в случае \"django.contrib."
"contenttypes\"  используется значение атрибута  :attr:`app_label` для  "
"\"contenttypes\"."

# f3e6e5847c1f4cc68af529012ba1a1f7
#: ../../ref/contrib/contenttypes.txt:75
msgid "The name of the model class."
msgstr "Имя модели класса"

#: ../../ref/contrib/contenttypes.txt:77
msgid "Additionally, the following property is available:"
msgstr "Также доступны следующие свойства:"

# 6dadd49c1f3d441d84fa1f19ef928d5b
#: ../../ref/contrib/contenttypes.txt:81
msgid ""
"The human-readable name of the content type. This is taken from the :attr:"
"`verbose_name <django.db.models.Field.verbose_name>` attribute of the model."
msgstr ""
"\"Читабельное\" имя модели. Берется из атрибута :attr:`verbose_name <django."
"db.models.Field.verbose_name>` модели."

# 800682d5ed77467f9a8895724b775f5c
#: ../../ref/contrib/contenttypes.txt:85
msgid ""
"Let's look at an example to see how this works. If you already have the :mod:"
"`~django.contrib.contenttypes` application installed, and then add :mod:`the "
"sites application <django.contrib.sites>` to your :setting:`INSTALLED_APPS` "
"setting and run ``manage.py migrate`` to install it, the model :class:"
"`django.contrib.sites.models.Site` will be installed into your database. "
"Along with it a new instance of :class:`~django.contrib.contenttypes.models."
"ContentType` will be created with the following values:"
msgstr ""
"Покажем на примере как это все работает. Если  приложение :mod:`~django."
"contrib.contenttypes` уже установлено, то добавьте  :mod:`приложение sites "
"<django.contrib.sites>` в :setting:`INSTALLED_APPS` файла настроек и "
"выполните команду ``manage.py migrate`` для создания таблиц и завершения "
"установки модели :class:`django.contrib.sites.models.Site`. Параллельно с "
"этим будет создан новый экземпляр :class:`~django.contrib.contenttypes."
"models.ContentType` со следующими значениями:"

# dea5917c959c45599e35c5bba5b2e9ae
#: ../../ref/contrib/contenttypes.txt:94
msgid ""
":attr:`~django.contrib.contenttypes.models.ContentType.app_label` will be "
"set to ``'sites'`` (the last part of the Python path ``django.contrib."
"sites``)."
msgstr ""
"Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.app_label` со "
"значением ``'sites'`` (последняя часть ``django.contrib.sites``)."

# 87838eb06f0041d6af795d5f9ed1d3c0
#: ../../ref/contrib/contenttypes.txt:98
msgid ""
":attr:`~django.contrib.contenttypes.models.ContentType.model` will be set to "
"``'site'``."
msgstr ""
"Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.model` со "
"значением ``'site'``."

# 97f9a6a2535e415c949a4a7e8c68495d
#: ../../ref/contrib/contenttypes.txt:102
msgid "Methods on ``ContentType`` instances"
msgstr "Методы экземпляра ``ContentType``"

# d1e2bed065724885918ddc8fa4a7f144
#: ../../ref/contrib/contenttypes.txt:104
msgid ""
"Each :class:`~django.contrib.contenttypes.models.ContentType` instance has "
"methods that allow you to get from a :class:`~django.contrib.contenttypes."
"models.ContentType` instance to the model it represents, or to retrieve "
"objects from that model:"
msgstr ""
"Каждый экземпляр  :class:`~django.contrib.contenttypes.models.ContentType` "
"имеет методы, которые позволяют получить доступ к модели, представленной "
"этим экземпляром :class:`~django.contrib.contenttypes.models.ContentType` , "
"или получить объекты этой модели:"

# 5ad40ab99b424e13b8b432bcfa605a8d
#: ../../ref/contrib/contenttypes.txt:111
msgid ""
"Takes a set of valid :ref:`lookup arguments <field-lookups-intro>` for the "
"model the :class:`~django.contrib.contenttypes.models.ContentType` "
"represents, and does :meth:`a get() lookup <django.db.models.query.QuerySet."
"get>` on that model, returning the corresponding object."
msgstr ""
"Принимает набор корректных :ref:`фильтров полей(lookup arguments) <field-"
"lookups-intro>` для модели, представленной данным :class:`~django.contrib."
"contenttypes.models.ContentType` и выполняет метод :meth:`get() <django.db."
"models.query.QuerySet.get>` этой модели, возвращая соответствующий объект. "

# 13a283caa71a4463a827301d123d535f
#: ../../ref/contrib/contenttypes.txt:119
msgid ""
"Returns the model class represented by this :class:`~django.contrib."
"contenttypes.models.ContentType` instance."
msgstr ""
"Возвращает класс модели, представленной данным экземпляром :class:`~django."
"contrib.contenttypes.models.ContentType`."

# 8b1b323d94254eb8a37c28b39b953adf
#: ../../ref/contrib/contenttypes.txt:122
msgid ""
"For example, we could look up the :class:`~django.contrib.contenttypes."
"models.ContentType` for the :class:`~django.contrib.auth.models.User` model::"
msgstr ""
"Н-р, мы можем получить экземпляр  :class:`~django.contrib.contenttypes."
"models.ContentType` для модели  :class:`~django.contrib.auth.models.User` "
"следующим образом:"

# a2f3e51c42984ed099a81717f9963b15
#: ../../ref/contrib/contenttypes.txt:130
msgid ""
"And then use it to query for a particular :class:`~django.contrib.auth."
"models.User`, or to get access to the ``User`` model class::"
msgstr ""
"А затем использовать полученный результат, чтобы получить модель  :class:"
"`~django.contrib.auth.models.User`, или для непосредственного доступа к "
"классу модели ``User``::"

# 02ae6b09e72447879317680472e085be
#: ../../ref/contrib/contenttypes.txt:139
msgid ""
"Together, :meth:`~django.contrib.contenttypes.models.ContentType."
"get_object_for_this_type` and :meth:`~django.contrib.contenttypes.models."
"ContentType.model_class` enable two extremely important use cases:"
msgstr ""
"Комбинация этих двух методов  :meth:`~django.contrib.contenttypes.models."
"ContentType.get_object_for_this_type` и  :meth:`~django.contrib.contenttypes."
"models.ContentType.model_class`, дает нам два крайне важных и полезных "
"варианта их использования:"

# 94fcf19115e843f8b9cd5b074dc3d836
#: ../../ref/contrib/contenttypes.txt:144
msgid ""
"Using these methods, you can write high-level generic code that performs "
"queries on any installed model -- instead of importing and using a single "
"specific model class, you can pass an ``app_label`` and ``model`` into a :"
"class:`~django.contrib.contenttypes.models.ContentType` lookup at runtime, "
"and then work with the model class or retrieve objects from it."
msgstr ""
"Воспользовавшись этими методами, вы можете писать высокоуровневый , "
"обобщенный(generic) код,  и выполнять запрос к любой установленной в "
"приложении модели. Вместо того, чтобы импортировать конкретные модели \"по "
"одиночке\", вы можете передать нужные параметры  ``app_label`` и ``model`` в "
"класс  :class:`~django.contrib.contenttypes.models.ContentType` во время "
"выполнения, и затем работать с полученной моделью класса или получить "
"конкретные объекты этой модели."

# 71656c76f0934b85be10ad0caf60d22b
#: ../../ref/contrib/contenttypes.txt:151
msgid ""
"You can relate another model to :class:`~django.contrib.contenttypes.models."
"ContentType` as a way of tying instances of it to particular model classes, "
"and use these methods to get access to those model classes."
msgstr ""
"Вы можете использовать :class:`~django.contrib.contenttypes.models."
"ContentType` чтобы связать экземпляр вашей модели с любыми произвольными "
"классами моделей проекта, и использовать указанные методы для доступа к этим "
"моделям. "

# 14bcd38241c344a39cbf5ff6ad24551c
#: ../../ref/contrib/contenttypes.txt:156
msgid ""
"Several of Django's bundled applications make use of the latter technique. "
"For example, :class:`the permissions system <django.contrib.auth.models."
"Permission>` in Django's authentication framework uses a :class:`~django."
"contrib.auth.models.Permission` model with a foreign key to :class:`~django."
"contrib.contenttypes.models.ContentType`; this lets :class:`~django.contrib."
"auth.models.Permission` represent concepts like \"can add blog entry\" or "
"\"can delete news story\"."
msgstr ""
"Некоторые из встроенных приложений Django используют  последний подход. Н-р, "
"в  :class:`системе полномочий( permissions system) <django.contrib.auth."
"models.Permission>`, в фреймворке аутентификации  Django, в модели :class:"
"`~django.contrib.auth.models.Permission` используется внешний ключ(foreign "
"key) к :class:`~django.contrib.contenttypes.models.ContentType`; это "
"позволяет создать обобщенную связь с различными моделями и реализовать "
"концепцию ограничений, такую как \"пользователь может добавить запись в блог"
"\" или \"пользователь может удалить сообщение из новостей\"."

# 0a77d8ee31e6477f854e404a83266b2a
#: ../../ref/contrib/contenttypes.txt:166
msgid "The ``ContentTypeManager``"
msgstr " ``ContentTypeManager``"

# 03039e6e43344154ace1e0883575accb
#: ../../ref/contrib/contenttypes.txt:170
msgid ""
":class:`~django.contrib.contenttypes.models.ContentType` also has a custom "
"manager, :class:`~django.contrib.contenttypes.models.ContentTypeManager`, "
"which adds the following methods:"
msgstr ""
"Класс :class:`~django.contrib.contenttypes.models.ContentType` обладает "
"собственным менеджером, :class:`~django.contrib.contenttypes.models."
"ContentTypeManager`, который включает в себя следующие методы:"

# f44e085a36bd4bdf9954ccb6086f5d08
#: ../../ref/contrib/contenttypes.txt:176
msgid ""
"Clears an internal cache used by :class:`~django.contrib.contenttypes.models."
"ContentType` to keep track of models for which it has created :class:"
"`~django.contrib.contenttypes.models.ContentType` instances. You probably "
"won't ever need to call this method yourself; Django will call it "
"automatically when it's needed."
msgstr ""
"Очищает внутренний кэш, используемый :class:`~django.contrib.contenttypes."
"models.ContentType` для отслеживания моделей, для которых были созданы "
"экземпляры  :class:`~django.contrib.contenttypes.models.ContentType`. "
"Вероятно, вам никогда не придется вызывать этот метод напрямую, поскольку  "
"Django  вызывает его автоматически, при необходимости."

# 7f6994c5b78c4d1c83dfd628c7900e22
#: ../../ref/contrib/contenttypes.txt:185
msgid ""
"Lookup a :class:`~django.contrib.contenttypes.models.ContentType` by ID. "
"Since this method uses the same shared cache as :meth:`~django.contrib."
"contenttypes.models.ContentTypeManager.get_for_model`, it's preferred to use "
"this method over the usual ``ContentType.objects.get(pk=id)``"
msgstr ""
"Получить экземпляр  :class:`~django.contrib.contenttypes.models.ContentType` "
"по идентификатору(ID).  Поскольку метод использует тот же разделяемый кэш, "
"что и метод  :meth:`~django.contrib.contenttypes.models.ContentTypeManager."
"get_for_model`, предпочтительней пользоваться именно им, а не привычным "
"запросом ``ContentType.objects.get(pk=id)``."

# b3846d5c1b1945c1806163a8eae6ca72
#: ../../ref/contrib/contenttypes.txt:193
msgid ""
"Takes either a model class or an instance of a model, and returns the :class:"
"`~django.contrib.contenttypes.models.ContentType` instance representing that "
"model. ``for_concrete_model=False`` allows fetching the :class:`~django."
"contrib.contenttypes.models.ContentType` of a proxy model."
msgstr ""
"Принимает в качестве аргумента либо класс модели, либо экземпляр модели, и "
"возвращает экземпляр :class:`~django.contrib.contenttypes.models."
"ContentType`, представляющего данную модель. ``for_concrete_model=False`` "
"позволяет получить :class:`~django.contrib.contenttypes.models.ContentType` "
"для прокси-модели."

# 746fd992b5174587b81d0c9d793d0bda
#: ../../ref/contrib/contenttypes.txt:201
msgid ""
"Takes a variadic number of model classes, and returns a dictionary mapping "
"the model classes to the :class:`~django.contrib.contenttypes.models."
"ContentType` instances representing them. ``for_concrete_models=False`` "
"allows fetching the :class:`~django.contrib.contenttypes.models.ContentType` "
"of proxy models."
msgstr ""
"Принимает в качестве аргумента произвольное число классов модели и "
"возвращает словарь с отображением класса модели на экземпляр  :class:"
"`~django.contrib.contenttypes.models.ContentType`, представляющего данную "
"модель. ``for_concrete_model=False`` позволяет получить :class:`~django."
"contrib.contenttypes.models.ContentType` для прокси-модели."

# 1cec42baac0b4352bbb804489d2dbaaa
#: ../../ref/contrib/contenttypes.txt:210
msgid ""
"Returns the :class:`~django.contrib.contenttypes.models.ContentType` "
"instance uniquely identified by the given application label and model name. "
"The primary purpose of this method is to allow :class:`~django.contrib."
"contenttypes.models.ContentType` objects to be referenced via a :ref:"
"`natural key<topics-serialization-natural-keys>` during deserialization."
msgstr ""
"Возвращает экземпляр  :class:`~django.contrib.contenttypes.models."
"ContentType`,  определенный уникальным образом для переданных аргументов: "
"имя приложения(application label) и имя модели(model name). Главное "
"назначение этого метода, дать возможность ссылаться на объекты  :class:"
"`~django.contrib.contenttypes.models.ContentType` посредством :ref:"
"`натуральных ключей(natural key)<topics-serialization-natural-keys>` в "
"процессе десериализации. "

# c76b1a724db744c58d5a42f458c8e4c2
#: ../../ref/contrib/contenttypes.txt:217
msgid ""
"The :meth:`~ContentTypeManager.get_for_model()` method is especially useful "
"when you know you need to work with a :class:`ContentType <django.contrib."
"contenttypes.models.ContentType>` but don't want to go to the trouble of "
"obtaining the model's metadata to perform a manual lookup::"
msgstr ""
"Метод  :meth:`~ContentTypeManager.get_for_model()` особенно полезен, когда "
"вам необходимо работать с  :class:`ContentType <django.contrib.contenttypes."
"models.ContentType>`, но вы не хотите \"заморачиваться\" с получением "
"метаданных модели для  поиска вручную::"

# 412196fce96143ba9bb7d99b53b127a4
#: ../../ref/contrib/contenttypes.txt:232
msgid "Generic relations"
msgstr "Обобщенные связи(generic relations)"

# 53a3a3133ef3443fb0c097f71b9b1341
#: ../../ref/contrib/contenttypes.txt:234
msgid ""
"Adding a foreign key from one of your own models to :class:`~django.contrib."
"contenttypes.models.ContentType` allows your model to effectively tie itself "
"to another model class, as in the example of the :class:`~django.contrib."
"auth.models.Permission` model above. But it's possible to go one step "
"further and use :class:`~django.contrib.contenttypes.models.ContentType` to "
"enable truly generic (sometimes called \"polymorphic\") relationships "
"between models."
msgstr ""
"Вы можете создать в вашей модели внешний ключ на  :class:`~django.contrib."
"contenttypes.models.ContentType`, что позволит связать вашу модель с любой "
"другой моделью, как это было описано выше на  примере :class:`~django."
"contrib.auth.models.Permission`. Но можно пойти еще дальше и использовать  :"
"class:`~django.contrib.contenttypes.models.ContentType` для реализации "
"абсолютно обобщенных (иногда говорят \"полиморфных\") отношений между "
"моделями. "

# 1788c3c02ac2491686f0db33450f8bc8
#: ../../ref/contrib/contenttypes.txt:242
msgid "A simple example is a tagging system, which might look like this::"
msgstr ""
"Вот простой пример: реализуем систему тэгов(ярлычков), которая могла бы "
"выглядеть так ::"

# df84598472a0406f8911f0ec0dcdd84f
#: ../../ref/contrib/contenttypes.txt:257
msgid ""
"A normal :class:`~django.db.models.ForeignKey` can only \"point to\" one "
"other model, which means that if the ``TaggedItem`` model used a :class:"
"`~django.db.models.ForeignKey` it would have to choose one and only one "
"model to store tags for. The contenttypes application provides a special "
"field type (``GenericForeignKey``) which works around this and allows the "
"relationship to be with any model:"
msgstr ""
"Обычное поле  :class:`~django.db.models.ForeignKey` может  \"указывать\" "
"только на одну модель, что означает, - если в модели ``TaggedItem``  есть "
"поле :class:`~django.db.models.ForeignKey`, его можно \"связать\" с одной и "
"только одной моделью, для которой и будут сохраняться тэги. Приложение "
"contenttypes предоставляет нам поле специального типа "
"(``GenericForeignKey``), которое решает обозначенную выше проблему и "
"позволяет создать связь с любой моделью:"

# 2cef3b75b18a47779340663c6a3cd0a0
#: ../../ref/contrib/contenttypes.txt:267
msgid ""
"There are three parts to setting up a :class:`~django.contrib.contenttypes."
"fields.GenericForeignKey`:"
msgstr ""
"Существуют три правила по созданию и настройке :class:`~django.contrib."
"contenttypes.fields.GenericForeignKey`:"

# d20dd6083d6f47f9be98d85b46b47b13
#: ../../ref/contrib/contenttypes.txt:270
msgid ""
"Give your model a :class:`~django.db.models.ForeignKey` to :class:`~django."
"contrib.contenttypes.models.ContentType`. The usual name for this field is "
"\"content_type\"."
msgstr ""
"Создайте в вашей модели поле  типа :class:`~django.db.models.ForeignKey`, "
"указав в качестве внешней модели :class:`~django.contrib.contenttypes.models."
"ContentType`. Обычно такому полю дают имя \"content_type\"."

# b27f2459683b4c9ca10e24b869b3c84b
#: ../../ref/contrib/contenttypes.txt:274
msgid ""
"Give your model a field that can store primary key values from the models "
"you'll be relating to. For most models, this means a :class:`~django.db."
"models.PositiveIntegerField`. The usual name for this field is \"object_id\"."
msgstr ""
"Создайте в вашей модели поле, которое будет хранить значения первичных "
"ключей экземпляров модели, с которой вы создаете связь. Для большинства "
"моделей, это поле типа  :class:`~django.db.models.PositiveIntegerField`. "
"Обычно такому полю дают имя \"object_id\"."

# df4263a031fe4a7e9137db231f98c103
#: ../../ref/contrib/contenttypes.txt:279
msgid ""
"Give your model a :class:`~django.contrib.contenttypes.fields."
"GenericForeignKey`, and pass it the names of the two fields described above. "
"If these fields are named \"content_type\" and \"object_id\", you can omit "
"this -- those are the default field names :class:`~django.contrib."
"contenttypes.fields.GenericForeignKey` will look for."
msgstr ""
"Создайте в вашей модели поле типа :class:`~django.contrib.contenttypes."
"fields.GenericForeignKey`, и передайте ему в качестве аргументов,  имена "
"полей созданных ранее. Если эти поля названы \"content_type\" и \"object_id"
"\", вы можете не передавать их, -- эти имена используются в :class:`~django."
"contrib.contenttypes.fields.GenericForeignKey` по умолчанию."

# eb9e6ef08caf483fa5036d0a43f248dd
#: ../../ref/contrib/contenttypes.txt:289
msgid ""
"If ``False``, the field will be able to reference proxy models. Default is "
"``True``. This mirrors the ``for_concrete_model`` argument to :meth:`~django."
"contrib.contenttypes.models.ContentTypeManager.get_for_model`."
msgstr ""
"При ``False``, поле может ссылаться на прокси-модель. Отображает аргумент "
"``for_concrete_model`` метода :meth:`~django.contrib.contenttypes.models."
"ContentTypeManager.get_for_model`. По умолчанию равно ``True``."

# 3ebd696ff4b240bda28efd76779025e0
#: ../../ref/contrib/contenttypes.txt:293
msgid "Primary key type compatibility"
msgstr "Тип первичного ключа"

# 1b2af1f608734cb088e1baba68ad168b
#: ../../ref/contrib/contenttypes.txt:295
msgid ""
"The \"object_id\" field doesn't have to be the same type as the primary key "
"fields on the related models, but their primary key values must be coercible "
"to the same type as the \"object_id\" field by its :meth:`~django.db.models."
"Field.get_db_prep_value` method."
msgstr ""
"Поле \"object_id\" не обязательно должно быть того же типа, что и у "
"первичного ключа в привязанной модели, но должно соблюдаться условие, что "
"значения первичного ключа могут быть приведены к тому же типу, что и у поля  "
"\"object_id \" методом :meth:`~django.db.models.Field.get_db_prep_value`."

# 2c31082624a84c93bc7940020fd66ad9
#: ../../ref/contrib/contenttypes.txt:300
msgid ""
"For example, if you want to allow generic relations to models with either :"
"class:`~django.db.models.IntegerField` or :class:`~django.db.models."
"CharField` primary key fields, you can use :class:`~django.db.models."
"CharField` for the \"object_id\" field on your model since integers can be "
"coerced to strings by :meth:`~django.db.models.Field.get_db_prep_value`."
msgstr ""
"Н-р, если вы хотите создать обобщенные отношения с моделями, использующими в "
"качестве первичных ключей типы :class:`~django.db.models.IntegerField` или :"
"class:`~django.db.models.CharField`, вы можете использовать тип :class:"
"`~django.db.models.CharField` для вашего поля  \"object_id\", поскольку "
"целочисленные значения могут быть корректно приведены к строковым методом :"
"meth:`~django.db.models.Field.get_db_prep_value`."

# f6f1493e1187427f85f967d66651f038
#: ../../ref/contrib/contenttypes.txt:307
msgid ""
"For maximum flexibility you can use a :class:`~django.db.models.TextField` "
"which doesn't have a maximum length defined, however this may incur "
"significant performance penalties depending on your database backend."
msgstr ""
"Для максимальной гибкости можно использовать тип :class:`~django.db.models."
"TextField`, который не накладывает ограничения на длину строки, но такое "
"решение может негативно отразиться на производительности, в зависимости от "
"используемой  базы данных."

# 33b84b4ebc664521b03f3cae6ccfb001
#: ../../ref/contrib/contenttypes.txt:312
msgid ""
"There is no one-size-fits-all solution for which field type is best. You "
"should evaluate the models you expect to be pointing to and determine which "
"solution will be most effective for your use case."
msgstr ""
"Не  существует универсального решения для выбора наилучшего типа поля. Вы "
"должны изучить модели с которыми собираетесь работать, и на основании этого "
"принять решение о выборе типа для поля, руководствуясь принципами "
"эффективности."

# 9b2222b281524409ab0aa1318d7fe4a7
#: ../../ref/contrib/contenttypes.txt:316
msgid "Serializing references to ``ContentType`` objects"
msgstr "Сериализация связей с ``ContentType``"

# 70fc4a6975e74ccf90ffec2156fb46bc
#: ../../ref/contrib/contenttypes.txt:318
msgid ""
"If you're serializing data (for example, when generating :class:`~django."
"test.TransactionTestCase.fixtures`) from a model that implements generic "
"relations, you should probably be using a natural key to uniquely identify "
"related :class:`~django.contrib.contenttypes.models.ContentType` objects. "
"See :ref:`natural keys<topics-serialization-natural-keys>` and :option:"
"`dumpdata --natural-foreign` for more information."
msgstr ""
"При сериализации данных модели (например, при создании :class:`~django.test."
"TransactionTestCase.fixtures`) , которая имеет обобщенные связи, вам "
"вероятно необходимо будет воспользоваться натуральным ключом, чтобы "
"корректно определить связи с объектами  :class:`~django.contrib.contenttypes."
"models.ContentType`. Смотрите :ref:`натуральные ключи <topics-serialization-"
"natural-keys>` и :option:`dumpdata --natural-foreign` для дополнительной "
"информации."

# 69f4abbb26c34545b3ef1bd6d3db6638
#: ../../ref/contrib/contenttypes.txt:325
msgid ""
"This will enable an API similar to the one used for a normal :class:`~django."
"db.models.ForeignKey`; each ``TaggedItem`` will have a ``content_object`` "
"field that returns the object it's related to, and you can also assign to "
"that field or use it when creating a ``TaggedItem``::"
msgstr ""
"После создания связи мы можем использовать  API, похожий на тот, что "
"используется в обычном   :class:`~django.db.models.ForeignKey`; каждый "
"``TaggedItem`` содержит поле ``content_object``, которое возвращает "
"связанный с ним объект. Мы можем присвоить этому полю произвольный объект, "
"или указать этот объект при создании ``TaggedItem``::"

#: ../../ref/contrib/contenttypes.txt:338
msgid ""
"If the related object is deleted, the ``content_type`` and ``object_id`` "
"fields remain set to their original values and the ``GenericForeignKey`` "
"returns ``None``::"
msgstr ""
"Если связанный объект удален, поля ``content_type`` и ``object_id`` получат "
"начальные значения и ``GenericForeignKey`` вернет ``None``::"

# b78caf773d994e5abf15e368f48d7b9a
#: ../../ref/contrib/contenttypes.txt:345
msgid ""
"Due to the way :class:`~django.contrib.contenttypes.fields."
"GenericForeignKey` is implemented, you cannot use such fields directly with "
"filters (``filter()`` and ``exclude()``, for example) via the database API. "
"Because a :class:`~django.contrib.contenttypes.fields.GenericForeignKey` "
"isn't a normal field object, these examples will *not* work::"
msgstr ""
"Из-за особенностей реализации :class:`~django.contrib.contenttypes.fields."
"GenericForeignKey`, вы не можете использовать такое поле с фильтрами "
"(``filter()`` и  ``exclude()``, н-р) в запросах API базы данных. Поскольку  :"
"class:`~django.contrib.contenttypes.fields.GenericForeignKey` это не совсем "
"\"обычное\" поле,примеры ниже  *не будут работать*::"

# 9357fe3b64d449bebdf553840ec21093
#: ../../ref/contrib/contenttypes.txt:356
msgid ""
"Likewise, :class:`~django.contrib.contenttypes.fields.GenericForeignKey`\\s "
"does not appear in :class:`~django.forms.ModelForm`\\s."
msgstr ""
"Также :class:`~django.contrib.contenttypes.fields.GenericForeignKey`\\s не "
"отображется в :class:`~django.forms.ModelForm`\\s."

# 4681d81cdc714fe5a13cfc63fdf52463
#: ../../ref/contrib/contenttypes.txt:360
msgid "Reverse generic relations"
msgstr "Обратная обобщенная связь(reverse generic relations)"

# ec6824ca892e475482b1e566e3975ea1
#: ../../ref/contrib/contenttypes.txt:366
msgid ""
"The relation on the related object back to this object doesn't exist by "
"default. Setting ``related_query_name`` creates a relation from the related "
"object back to this one. This allows querying and filtering from the related "
"object."
msgstr ""
"По умолчанию обратная связь не создается. Чтобы создать такую связь, укажите "
"параметр ``related_query_name`` поля. Это позволять получить связанные "
"объекты и использовать поле для фильтрации результатов запроса."

# e2f739f4d56b43dcaba71eebd060443d
#: ../../ref/contrib/contenttypes.txt:371
msgid ""
"If you know which models you'll be using most often, you can also add a "
"\"reverse\" generic relationship to enable an additional API. For example::"
msgstr ""
"Если модель, с которой предстоит работать наиболее часто, известна заранее, "
"вы можете добавить \"обратную\" обобщенную связь между моделями и "
"использовать дополнительные возможности API. Н-р::"

# 052a8835037244cd94ff61232ef32707
#: ../../ref/contrib/contenttypes.txt:381
msgid ""
"``Bookmark`` instances will each have a ``tags`` attribute, which can be "
"used to retrieve their associated ``TaggedItems``::"
msgstr ""
"Каждый экземпляр ``Bookmark`` имеет атрибут ``tags``, который можно "
"использовать чтобы получить доступ к связанному с ним ``TaggedItems``::"

# e8a322b83cb1470a82e8c26713c8254d
#: ../../ref/contrib/contenttypes.txt:393
msgid ""
"Defining :class:`~django.contrib.contenttypes.fields.GenericRelation` with "
"``related_query_name`` set allows querying from the related object::"
msgstr ""
"Создав :class:`~django.contrib.contenttypes.fields.GenericRelation` с "
"``related_query_name``, можно использовать связь в запросах::"

# 1842c03993914238904c695240c73216
#: ../../ref/contrib/contenttypes.txt:398
msgid ""
"This enables filtering, ordering, and other query operations on ``Bookmark`` "
"from ``TaggedItem``::"
msgstr ""
"Это позволяет фильтровать, сортировать и выполнять запросы по ``Bookmark`` "
"из ``TaggedItem``::"

# fbb28a284f304a5a8ab5b5ce6b9bccc3
#: ../../ref/contrib/contenttypes.txt:405
msgid ""
"Of course, if you don't add the reverse relationship, you can do the same "
"types of lookups manually::"
msgstr ""
"Ну и конечно, если вы не захотите добавить обратную связь, вы можете "
"получить доступ к объекту  и \"обходным путем\"::"

# 972e3b39cb0b4e6596ff185d0e39eac5
#: ../../ref/contrib/contenttypes.txt:413
msgid ""
"Just as :class:`~django.contrib.contenttypes.fields.GenericForeignKey` "
"accepts the names of the content-type and object-ID fields as arguments, so "
"too does :class:`~django.contrib.contenttypes.fields.GenericRelation`; if "
"the model which has the generic foreign key is using non-default names for "
"those fields, you must pass the names of the fields when setting up a :class:"
"`.GenericRelation` to it. For example, if the ``TaggedItem`` model referred "
"to above used fields named ``content_type_fk`` and ``object_primary_key`` to "
"create its generic foreign key, then a :class:`.GenericRelation` back to it "
"would need to be defined like so::"
msgstr ""
"Также как :class:`~django.contrib.contenttypes.fields.GenericForeignKey`, :"
"class:`~django.contrib.contenttypes.fields.GenericRelation` принимает "
"аргументами имена полей content-type и object-ID  . Если модель, имеющая "
"обобщенный внешний ключ *не* использует имена по-умолчанию для этих полей, а "
"любые другие, -- вы должны передать эти имена полей в  :class:`."
"GenericRelation` при его инициализации. Н-р, если бы мы использовали в "
"модели ``TaggedItem`` поля с именами ``content_type_fk`` и "
"``object_primary_key`` при создании внешнего ключа, то поле :class:`."
"GenericRelation` следовало бы определить таким образом::"

# d08f2da79a6f436bab2ddce6c9e80fcd
#: ../../ref/contrib/contenttypes.txt:430
msgid ""
"Note also, that if you delete an object that has a :class:`~django.contrib."
"contenttypes.fields.GenericRelation`, any objects which have a :class:"
"`~django.contrib.contenttypes.fields.GenericForeignKey` pointing at it will "
"be deleted as well. In the example above, this means that if a ``Bookmark`` "
"object were deleted, any ``TaggedItem`` objects pointing at it would be "
"deleted at the same time."
msgstr ""
"Также обратите внимание, что в случае удаления объекта, имеющего поле :class:"
"`~django.contrib.contenttypes.fields.GenericRelation`, все объекты у "
"которых :class:`~django.contrib.contenttypes.fields.GenericForeignKey` "
"указывает на этот удаляемый объект,  тоже будут удалены. Для примера выше "
"это значит, что если удалить объект ``Bookmark``, то любые ``TaggedItem``, "
"связанные с ним, будут удалены вместе с ним."

# acf377f93f2a462c8c7604514fdd3897
#: ../../ref/contrib/contenttypes.txt:437
msgid ""
"Unlike :class:`~django.db.models.ForeignKey`, :class:`~django.contrib."
"contenttypes.fields.GenericForeignKey` does not accept an :attr:`~django.db."
"models.ForeignKey.on_delete` argument to customize this behavior; if "
"desired, you can avoid the cascade-deletion simply by not using :class:"
"`~django.contrib.contenttypes.fields.GenericRelation`, and alternate "
"behavior can be provided via the :data:`~django.db.models.signals."
"pre_delete` signal."
msgstr ""
"В отличии от обычного  :class:`~django.db.models.ForeignKey`, тип  :class:"
"`~django.contrib.contenttypes.fields.GenericForeignKey` не принимает "
"аргумент :attr:`~django.db.models.ForeignKey.on_delete` для расширения "
"поведения модели; если это необходимо, вы можете избежать каскадного "
"удаления связанных объектов просто не используя :class:`~django.contrib."
"contenttypes.fields.GenericRelation`,  и указать необходимое поведение с "
"помощью сигнала :data:`~django.db.models.signals.pre_delete`."

# eef5bbe015824a048689cb9114c55b4f
#: ../../ref/contrib/contenttypes.txt:446
msgid "Generic relations and aggregation"
msgstr "Обобщенные связи и агрегация"

# 1ba53a312b0d4d0e8f0df34e1185fa61
#: ../../ref/contrib/contenttypes.txt:448
msgid ""
":doc:`Django's database aggregation API </topics/db/aggregation>` works with "
"a :class:`~django.contrib.contenttypes.fields.GenericRelation`. For example, "
"you can find out how many tags all the bookmarks have::"
msgstr ""
":doc:`API агрегации Django для баз данных </topics/db/aggregation>` работает "
"с :class:`~django.contrib.contenttypes.fields.GenericRelation`. Например, вы "
"можете получить количество тегов для всех закладок::"

# 328c1d1a58814a7ba03e57b28efaa225
#: ../../ref/contrib/contenttypes.txt:458
msgid "Generic relation in forms"
msgstr "Обобщенные связи в формах"

# ac3cbbcf9fbe4bc0a32c9357407a8fd9
#: ../../ref/contrib/contenttypes.txt:460
msgid "The :mod:`django.contrib.contenttypes.forms` module provides:"
msgstr ""
"Модуль :mod:`django.contrib.contenttypes.forms` предлагает нам следующее:"

# 2489514b9b3845079c975c111ee870ce
#: ../../ref/contrib/contenttypes.txt:462
msgid ":class:`BaseGenericInlineFormSet`"
msgstr ":class:`BaseGenericInlineFormSet`"

# 07c4b940aa564ec38441ba867366d44c
#: ../../ref/contrib/contenttypes.txt:463
msgid ""
"A formset factory, :func:`generic_inlineformset_factory`, for use with :"
"class:`~django.contrib.contenttypes.fields.GenericForeignKey`."
msgstr ""
"Набор форм, :func:`generic_inlineformset_factory`, для использования с :"
"class:`~django.contrib.contenttypes.fields.GenericForeignKey`"

# 5a8f6401216b4a7887bb98050e582790
#: ../../ref/contrib/contenttypes.txt:470
msgid ""
"Returns a ``GenericInlineFormSet`` using :func:`~django.forms.models."
"modelformset_factory`."
msgstr ""
"Возвращает ``GenericInlineFormSet``, используя :func:`~django.forms.models."
"modelformset_factory`."

# 5242e05ea32f470fad100c82c4f1bd99
#: ../../ref/contrib/contenttypes.txt:473
msgid ""
"You must provide ``ct_field`` and ``fk_field`` if they are different from "
"the defaults, ``content_type`` and ``object_id`` respectively. Other "
"parameters are similar to those documented in :func:`~django.forms.models."
"modelformset_factory` and :func:`~django.forms.models.inlineformset_factory`."
msgstr ""
"Вы должны предоставить имена для ``ct_field`` и ``object_id`` если они "
"отличаются от значений по умолчанию, - ``content_type`` и ``object_id``.  "
"Прочие параметры аналогичны тем, что описаны в  :func:`~django.forms.models."
"modelformset_factory` и :func:`~django.forms.models.inlineformset_factory`."

# 77542e530d1e4d59829b55f58410cd41
#: ../../ref/contrib/contenttypes.txt:479
msgid ""
"The ``for_concrete_model`` argument corresponds to the :class:`~django."
"contrib.contenttypes.fields.GenericForeignKey.for_concrete_model` argument "
"on ``GenericForeignKey``."
msgstr ""
"Аргумент ``for_concrete_model`` соответствует параметру :class:`~django."
"contrib.contenttypes.fields.GenericForeignKey.for_concrete_model`  для "
"``GenericForeignKey``."

# 328c1d1a58814a7ba03e57b28efaa225
#: ../../ref/contrib/contenttypes.txt:486
msgid "Generic relations in admin"
msgstr "Обобщенные связи в админке"

# dcb91af1e319456b9eac1f2a0bc55aa2
#: ../../ref/contrib/contenttypes.txt:488
msgid ""
"The :mod:`django.contrib.contenttypes.admin` module provides :class:`~django."
"contrib.contenttypes.admin.GenericTabularInline` and :class:`~django.contrib."
"contenttypes.admin.GenericStackedInline` (subclasses of :class:`~django."
"contrib.contenttypes.admin.GenericInlineModelAdmin`)"
msgstr ""
"Модуль :mod:`django.contrib.contenttypes.admin` предоставляет :class:"
"`~django.contrib.contenttypes.admin.GenericTabularInline` и :class:`~django."
"contrib.contenttypes.admin.GenericStackedInline` (дочерние классы :class:"
"`~django.contrib.contenttypes.admin.GenericInlineModelAdmin`)"

# df340e0f994b4004902b05aedc152128
#: ../../ref/contrib/contenttypes.txt:493
msgid ""
"These classes and functions enable the use of generic relations in forms and "
"the admin. See the :doc:`model formset </topics/forms/modelforms>` and :ref:"
"`admin <using-generic-relations-as-an-inline>` documentation for more "
"information."
msgstr ""
"Эти классы и функции позволяют использовать обобщенные отношения объектов "
"при создании форм и в админке Django. За дополнительной информацией "
"обратитесь к  :doc:`модель набора форм </topics/forms/modelforms>` и :ref:"
"`admin <using-generic-relations-as-an-inline>` ."

# 1afefc476ad34f268ba7d1dbed48e4ba
#: ../../ref/contrib/contenttypes.txt:500
msgid ""
"The :class:`~django.contrib.contenttypes.admin.GenericInlineModelAdmin` "
"class inherits all properties from an :class:`~django.contrib.admin."
"InlineModelAdmin` class. However, it adds a couple of its own for working "
"with the generic relation:"
msgstr ""
"Класс :class:`~django.contrib.contenttypes.admin.GenericInlineModelAdmin` "
"наследует все свойства класса :class:`~django.contrib.admin."
"InlineModelAdmin`. Но также имеет ряд собственных атрибутов для работы с "
"обобщенными связями:"

# 77542e530d1e4d59829b55f58410cd41
#: ../../ref/contrib/contenttypes.txt:507
msgid ""
"The name of the :class:`~django.contrib.contenttypes.models.ContentType` "
"foreign key field on the model. Defaults to ``content_type``."
msgstr ""
"Имя поля внешнего ключа :class:`~django.contrib.contenttypes.models."
"ContentType` модели. По умолчанию ``content_type``."

# 9135be9a61844c9b99d5d3b772d3bbf8
#: ../../ref/contrib/contenttypes.txt:513
msgid ""
"The name of the integer field that represents the ID of the related object. "
"Defaults to ``object_id``."
msgstr ""
"Имя целочисленного поля, которое хранит идентификатор конкретного объекта "
"связанной модели. По умолчанию ``object_id``."

# 72c63dad6bae424f819ed3972c22c1dc
#: ../../ref/contrib/contenttypes.txt:519
msgid ""
"Subclasses of :class:`GenericInlineModelAdmin` with stacked and tabular "
"layouts, respectively."
msgstr ""
"Подклассы  :class:`GenericInlineModelAdmin` позволяющие настраивать "
"отображение данных в сложенном(stacked) или табличном(tabular) виде, "
"соответственно."

#~ msgid ""
#~ "Before Django 1.8, the ``name`` property was a real field on the "
#~ "``ContentType`` model."
#~ msgstr "До Django 1.8 свойство ``name`` было полем модели ``ContentType``."

# 8d569027a05042ec891357b5cdf7dfda
#~ msgid ""
#~ "Note that if the model in a :class:`~django.contrib.contenttypes.fields."
#~ "GenericRelation` uses a non-default value for ``ct_field`` or "
#~ "``fk_field`` in its :class:`~django.contrib.contenttypes.fields."
#~ "GenericForeignKey` (for example, if you had a ``Comment`` model that uses "
#~ "``ct_field=\"object_pk\"``), you'll need to set ``content_type_field`` "
#~ "and/or ``object_id_field`` in the :class:`~django.contrib.contenttypes."
#~ "fields.GenericRelation` to match the ``ct_field`` and ``fk_field``, "
#~ "respectively, in the :class:`~django.contrib.contenttypes.fields."
#~ "GenericForeignKey`::"
#~ msgstr ""
#~ "Обратите внимание, если в модели с  :class:`~django.contrib.contenttypes."
#~ "fields.GenericRelation` не используются значения по умолчанию для "
#~ "``ct_field`` или ``fk_field`` для :class:`~django.contrib.contenttypes."
#~ "fields.GenericForeignKey` (например, у вас есть модель ``Comment`` с "
#~ "``ct_field=\"object_pk\"``), вам необходимо установить  "
#~ "``content_type_field`` и/или ``object_id_field`` таким образом, чтобы "
#~ "значения  ``ct_field`` и ``fk_field`` в :class:`~django.contrib."
#~ "contenttypes.fields.GenericRelation` соответствовали  значениям  для "
#~ "``ct_field`` и ``fk_field`` в модели содержащей  :class:`~django.contrib."
#~ "contenttypes.fields.GenericForeignKey`::"

#~ msgid ""
#~ "Works analogously to :attr:`ForeignKey.allow_unsaved_instance_assignment "
#~ "<django.db.models.ForeignKey.allow_unsaved_instance_assignment>`."
#~ msgstr ""
#~ "Работает аналогично :attr:`ForeignKey.allow_unsaved_instance_assignment "
#~ "<django.db.models.ForeignKey.allow_unsaved_instance_assignment>`."

# ac3cbbcf9fbe4bc0a32c9357407a8fd9
#~ msgid ""
#~ "This class used to be defined in ``django.contrib.contenttypes.generic``. "
#~ "Support for importing from this old location will be removed in Django "
#~ "1.9."
#~ msgstr ""
#~ "Этот класс ранее был определен в ``django.contrib.contenttypes.generic``. "
#~ "Импорт по этому пути будет удален в Django 1.9."

# d81ec2c1b1024ae88387c6f571bc2f66
#~ msgid ""
#~ "This will not work correctly, however. The generic relation adds extra "
#~ "filters to the queryset to ensure the correct content type, but the :meth:"
#~ "`~django.db.models.query.QuerySet.aggregate` method doesn't take them "
#~ "into account. For now, if you need aggregates on generic relations, "
#~ "you'll need to calculate them without using the aggregation API."
#~ msgstr ""
#~ "Тем не менее, это не сработает так,  как вы ожидаете.  Обобщенные связи "
#~ "используют дополнительные фильтры в запросе(queryset), чтобы "
#~ "гарантировать непротиворечивость контентного типа, но метод  :meth:"
#~ "`~django.db.models.query.QuerySet.aggregate` не принимает это в расчет. К "
#~ "настоящему моменту, если вам необходимо выполнить агрегирующие запросы с "
#~ "объектами с обобщенной связью, вы должны выполнить это другими методами, "
#~ "не используя  возможности API для агрегации. "

# ac3cbbcf9fbe4bc0a32c9357407a8fd9
#~ msgid ""
#~ "This function used to be defined in ``django.contrib.contenttypes."
#~ "generic``. Support for importing from this old location will be removed "
#~ "in Django 1.9."
#~ msgstr ""
#~ "Эта функция ранее была определена в ``django.contrib.contenttypes."
#~ "generic``. Импорт из этого модуля будет удален в Django 1.9."

# 2f4059da4de34ed380a5899a7449bcca
#~ msgid "``min_num`` and ``validate_min`` were added."
#~ msgstr "Были добавлены аргументы ``min_num`` и ``validate_min``."

# ac3cbbcf9fbe4bc0a32c9357407a8fd9
#~ msgid ""
#~ "These classes used to be defined in ``django.contrib.contenttypes."
#~ "generic``. Support for importing from this old location will be removed "
#~ "in Django 1.9."
#~ msgstr ""
#~ "Эти классы были определены в ``django.contrib.contenttypes.generic``. "
#~ "Импорт из этого модуля будет удален в Django 1.9."

# 4b64f0c90ee547b4bf51f8fff4e85e3f
#~ msgid ""
#~ "Django's comments system (:mod:`django.contrib.comments`) uses it to "
#~ "\"attach\" comments to any installed model."
#~ msgstr ""
#~ "Система комментариев Django (:mod:`django.contrib.comments`) использует "
#~ "contenttypes для \"добавления\" комментариев к моделям."

# 085c84d77be547b3b637821d7bb18581
#~ msgid ""
#~ ":attr:`~django.contrib.contenttypes.models.ContentType.name` will be set "
#~ "to ``'site'``."
#~ msgstr ""
#~ "Атрибут :attr:`~django.contrib.contenttypes.models.ContentType.name` со "
#~ "значением ``'site'``."

# d68684b8f9b04461acbbe1d241e7444f
#~ msgid ""
#~ "Prior to Django 1.5, :meth:`~django.contrib.contenttypes.models."
#~ "ContentTypeManager.get_for_model` and :meth:`~django.contrib.contenttypes."
#~ "models.ContentTypeManager.get_for_models` always returned the :class:"
#~ "`~django.contrib.contenttypes.models.ContentType` associated with the "
#~ "concrete model of the specified one(s). That means there was no way to "
#~ "retrieve the :class:`~django.contrib.contenttypes.models.ContentType` of "
#~ "a proxy model using those methods. As of Django 1.5 you can now pass a "
#~ "boolean flag – ``for_concrete_model`` and ``for_concrete_models`` "
#~ "respectively – to specify wether or not you want to retrieve the :class:"
#~ "`~django.contrib.contenttypes.models.ContentType` for the concrete or "
#~ "direct model."
#~ msgstr ""
#~ "До Django 1.5, методы :meth:`~django.contrib.contenttypes.models."
#~ "ContentTypeManager.get_for_model` и :meth:`~django.contrib.contenttypes."
#~ "models.ContentTypeManager.get_for_models` всегда возвращали :class:"
#~ "`~django.contrib.contenttypes.models.ContentType`, связанный с конкретной "
#~ "указанной моделью или моделями.  Это означало, что нет возможности "
#~ "получить :class:`~django.contrib.contenttypes.models.ContentType` прокси-"
#~ "модели(proxy model), используя данные методы. В Django 1.5  вы можете "
#~ "передать флажок с булевым значением  – ``for_concrete_model`` и "
#~ "``for_concrete_models`` соответственно, чтобы указать желаете ли вы или "
#~ "нет получить экземпляр :class:`~django.contrib.contenttypes.models."
#~ "ContentType` для конкретной или прямой модели(direct model)."
