# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-13 22:13+0300\n"
"PO-Revision-Date: 2015-03-19 15:06+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../ref/contrib/postgres/fields.txt:3
msgid "PostgreSQL specific model fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:5
msgid ""
"All of these fields are available from the ``django.contrib.postgres."
"fields`` module."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:11
msgid "Indexing these fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:13
msgid ""
":class:`~django.db.models.Index` and :attr:`.Field.db_index` both create a B-"
"tree index, which isn't particularly helpful when querying complex data "
"types. Indexes such as :class:`~django.contrib.postgres.indexes.GinIndex` "
"and :class:`~django.contrib.postgres.indexes.GistIndex` are better suited, "
"though the index choice is dependent on the queries that you're using. "
"Generally, GiST may be a good choice for the :ref:`range fields <range-"
"fields>` and :class:`HStoreField`, and GIN may be helpful for :class:"
"`ArrayField` and :class:`JSONField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:23
msgid "``ArrayField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:27
msgid ""
"A field for storing lists of data. Most field types can be used, and you "
"pass another field instance as the :attr:`base_field <ArrayField."
"base_field>`. You may also specify a :attr:`size <ArrayField.size>`. "
"``ArrayField`` can be nested to store multi-dimensional arrays."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:33
msgid ""
"If you give the field a :attr:`~django.db.models.Field.default`, ensure it's "
"a callable such as ``list`` (for an empty default) or a callable that "
"returns a list (such as a function). Incorrectly using ``default=[]`` "
"creates a mutable default that is shared between all instances of "
"``ArrayField``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:41
msgid "This is a required argument."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:43
msgid ""
"Specifies the underlying data type and behavior for the array. It should be "
"an instance of a subclass of :class:`~django.db.models.Field`. For example, "
"it could be an :class:`~django.db.models.IntegerField` or a :class:`~django."
"db.models.CharField`. Most field types are permitted, with the exception of "
"those handling relational data (:class:`~django.db.models.ForeignKey`, :"
"class:`~django.db.models.OneToOneField` and :class:`~django.db.models."
"ManyToManyField`)."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:53
msgid ""
"It is possible to nest array fields - you can specify an instance of "
"``ArrayField`` as the ``base_field``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:68
msgid ""
"Transformation of values between the database and the model, validation of "
"data and configuration, and serialization are all delegated to the "
"underlying base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:74
msgid "This is an optional argument."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:76
msgid ""
"If passed, the array will have a maximum size as specified. This will be "
"passed to the database, although PostgreSQL at present does not enforce the "
"restriction."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:82
msgid ""
"When nesting ``ArrayField``, whether you use the `size` parameter or not, "
"PostgreSQL requires that the arrays are rectangular::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:103
msgid ""
"If irregular shapes are required, then the underlying field should be made "
"nullable and the values padded with ``None``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:107
msgid "Querying ``ArrayField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:109
msgid ""
"There are a number of custom lookups and transforms for :class:`ArrayField`. "
"We will use the following example model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:125
#: ../../ref/contrib/postgres/fields.txt:362
#: ../../ref/contrib/postgres/fields.txt:742
msgid "``contains``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:127
msgid ""
"The :lookup:`contains` lookup is overridden on :class:`ArrayField`. The "
"returned objects will be those where the values passed are a subset of the "
"data. It uses the SQL operator ``@>``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:147
#: ../../ref/contrib/postgres/fields.txt:382
#: ../../ref/contrib/postgres/fields.txt:750
msgid "``contained_by``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:149
msgid ""
"This is the inverse of the :lookup:`contains <arrayfield.contains>` lookup - "
"the objects returned will be those where the data is a subset of the values "
"passed. It uses the SQL operator ``<@``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:166
#: ../../ref/contrib/postgres/fields.txt:771
msgid "``overlap``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:168
msgid ""
"Returns objects where the data shares any results with the values passed. "
"Uses the SQL operator ``&&``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:184
msgid "``len``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:186
msgid ""
"Returns the length of the array. The lookups available afterwards are those "
"available for :class:`~django.db.models.IntegerField`. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:198
msgid "Index transforms"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:200
msgid ""
"Index transforms index into the array. Any non-negative integer can be used. "
"There are no errors if it exceeds the :attr:`size <ArrayField.size>` of the "
"array. The lookups available after the transform are those from the :attr:"
"`base_field <ArrayField.base_field>`. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:219
msgid ""
"PostgreSQL uses 1-based indexing for array fields when writing raw SQL. "
"However these indexes and those used in :lookup:`slices <arrayfield.slice>` "
"use 0-based indexing to be consistent with Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:226
msgid "Slice transforms"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:228
msgid ""
"Slice transforms take a slice of the array. Any two non-negative integers "
"can be used, separated by a single underscore. The lookups available after "
"the transform do not change. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:244
msgid ""
"PostgreSQL uses 1-based indexing for array fields when writing raw SQL. "
"However these slices and those used in :lookup:`indexes <arrayfield.index>` "
"use 0-based indexing to be consistent with Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:248
msgid "Multidimensional arrays with indexes and slices"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:250
msgid ""
"PostgreSQL has some rather esoteric behavior when using indexes and slices "
"on multidimensional arrays. It will always work to use indexes to reach down "
"to the final underlying data, but most other slices behave strangely at the "
"database level and cannot be supported in a logical, consistent fashion by "
"Django."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:257
msgid "``CIText`` fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:261
msgid ""
"A mixin to create case-insensitive text fields backed by the citext_ type. "
"Read about `the performance considerations`_ prior to using it."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:264
msgid ""
"To use ``citext``, use the :class:`.CITextExtension` operation to :ref:"
"`setup the citext extension <create-postgresql-extensions>` in PostgreSQL "
"before the first ``CreateModel`` migration operation."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:268
msgid ""
"If you're using an :class:`~django.contrib.postgres.fields.ArrayField` of "
"``CIText`` fields, you must add ``'django.contrib.postgres'`` in your :"
"setting:`INSTALLED_APPS`, otherwise field values will appear as strings like "
"``'{thoughts,django}'``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:273
msgid "Several fields that use the mixin are provided:"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:279
msgid ""
"These fields subclass :class:`~django.db.models.CharField`, :class:`~django."
"db.models.EmailField`, and :class:`~django.db.models.TextField`, "
"respectively."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:283
msgid ""
"``max_length`` won't be enforced in the database since ``citext`` behaves "
"similar to PostgreSQL's ``text`` type."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:290
msgid "``HStoreField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:294
msgid ""
"A field for storing key-value pairs. The Python data type used is a "
"``dict``. Keys must be strings, and values may be either strings or nulls "
"(``None`` in Python)."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:298
msgid "To use this field, you'll need to:"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:300
msgid "Add ``'django.contrib.postgres'`` in your :setting:`INSTALLED_APPS`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:301
msgid ""
":ref:`Setup the hstore extension <create-postgresql-extensions>` in "
"PostgreSQL."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:304
msgid ""
"You'll see an error like ``can't adapt type 'dict'`` if you skip the first "
"step, or ``type \"hstore\" does not exist`` if you skip the second."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:309
msgid ""
"On occasions it may be useful to require or restrict the keys which are "
"valid for a given field. This can be done using the :class:`~django.contrib."
"postgres.validators.KeysValidator`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:314
msgid "Querying ``HStoreField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:316
msgid ""
"In addition to the ability to query by key, there are a number of custom "
"lookups available for ``HStoreField``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:319
#: ../../ref/contrib/postgres/fields.txt:523
msgid "We will use the following example model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:334
msgid "Key lookups"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:336
msgid ""
"To query based on a given key, you can use that key as the lookup name::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:344
msgid "You can chain other lookups after key lookups::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:349
msgid ""
"If the key you wish to query by clashes with the name of another lookup, you "
"need to use the :lookup:`hstorefield.contains` lookup instead."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:354
msgid ""
"Since any string could be a key in a hstore value, any lookup other than "
"those listed below will be interpreted as a key lookup. No errors are "
"raised. Be extra careful for typing mistakes, and always check your queries "
"work as you intend."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:364
msgid ""
"The :lookup:`contains` lookup is overridden on :class:`~django.contrib."
"postgres.fields.HStoreField`. The returned objects are those where the given "
"``dict`` of key-value pairs are all contained in the field. It uses the SQL "
"operator ``@>``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:384
msgid ""
"This is the inverse of the :lookup:`contains <hstorefield.contains>` lookup "
"- the objects returned will be those where the key-value pairs on the object "
"are a subset of those in the value passed. It uses the SQL operator ``<@``. "
"For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:402
msgid "``has_key``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:404
msgid ""
"Returns objects where the given key is in the data. Uses the SQL operator ``?"
"``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:416
msgid "``has_any_keys``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:418
msgid ""
"Returns objects where any of the given keys are in the data. Uses the SQL "
"operator ``?|``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:431
msgid "``has_keys``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:433
msgid ""
"Returns objects where all of the given keys are in the data. Uses the SQL "
"operator ``?&``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:445
msgid "``keys``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:447
msgid ""
"Returns objects where the array of keys is the given value. Note that the "
"order is not guaranteed to be reliable, so this transform is mainly useful "
"for using in conjunction with lookups on :class:`~django.contrib.postgres."
"fields.ArrayField`. Uses the SQL function ``akeys()``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:462
msgid "``values``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:464
msgid ""
"Returns objects where the array of values is the given value. Note that the "
"order is not guaranteed to be reliable, so this transform is mainly useful "
"for using in conjunction with lookups on :class:`~django.contrib.postgres."
"fields.ArrayField`. Uses the SQL function ``avalues()``. For example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:477
msgid "``JSONField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:481
msgid ""
"A field for storing JSON encoded data. In Python the data is represented in "
"its Python native format: dictionaries, lists, strings, numbers, booleans "
"and ``None``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:487
msgid ""
"An optional JSON-encoding class to serialize data types not supported by the "
"standard JSON serializer (``datetime``, ``uuid``, etc.). For example, you "
"can use the :class:`~django.core.serializers.json.DjangoJSONEncoder` class "
"or any other :py:class:`json.JSONEncoder` subclass."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:493
msgid ""
"When the value is retrieved from the database, it will be in the format "
"chosen by the custom encoder (most often a string), so you'll need to take "
"extra steps to convert the value back to the initial data type (:meth:`Model."
"from_db() <django.db.models.Model.from_db>` and :meth:`Field.from_db_value() "
"<django.db.models.Field.from_db_value>` are two possible hooks for that "
"purpose). Your deserialization may need to account for the fact that you "
"can't be certain of the input type. For example, you run the risk of "
"returning a ``datetime`` that was actually a string that just happened to be "
"in the same format chosen for ``datetime``\\s."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:504
msgid ""
"If you give the field a :attr:`~django.db.models.Field.default`, ensure it's "
"a callable such as ``dict`` (for an empty default) or a callable that "
"returns a dict (such as a function). Incorrectly using ``default={}`` "
"creates a mutable default that is shared between all instances of "
"``JSONField``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:512
msgid ""
"PostgreSQL has two native JSON based data types: ``json`` and ``jsonb``. The "
"main difference between them is how they are stored and how they can be "
"queried. PostgreSQL's ``json`` field is stored as the original string "
"representation of the JSON and must be decoded on the fly when queried based "
"on keys. The ``jsonb`` field is stored based on the actual structure of the "
"JSON which allows indexing. The trade-off is a small additional cost on "
"writing to the ``jsonb`` field. ``JSONField`` uses ``jsonb``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:521
msgid "Querying ``JSONField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:538
msgid "Key, index, and path lookups"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:540
msgid ""
"To query based on a given dictionary key, use that key as the lookup name::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:556
msgid "Multiple keys can be chained together to form a path lookup::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:561
msgid ""
"If the key is an integer, it will be interpreted as an index lookup in an "
"array::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:567
msgid ""
"If the key you wish to query by clashes with the name of another lookup, use "
"the :lookup:`jsonfield.contains` lookup instead."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:570
msgid ""
"If only one key or index is used, the SQL operator ``->`` is used. If "
"multiple operators are used then the ``#>`` operator is used."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:573
msgid "To query for ``null`` in JSON data, use ``None`` as a value::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:578
msgid "To query for missing keys, use the ``isnull`` lookup::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:586
msgid ""
"Since any string could be a key in a JSON object, any lookup other than "
"those listed below will be interpreted as a key lookup. No errors are "
"raised. Be extra careful for typing mistakes, and always check your queries "
"work as you intend."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:592
msgid "Containment and key operations"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:600
msgid ""
":class:`~django.contrib.postgres.fields.JSONField` shares lookups relating "
"to containment and keys with :class:`~django.contrib.postgres.fields."
"HStoreField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:603
msgid ""
":lookup:`contains <hstorefield.contains>` (accepts any JSON rather than just "
"a dictionary of strings)"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:605
msgid ""
":lookup:`contained_by <hstorefield.contained_by>` (accepts any JSON rather "
"than just a dictionary of strings)"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:607
msgid ":lookup:`has_key <hstorefield.has_key>`"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:608
msgid ":lookup:`has_any_keys <hstorefield.has_any_keys>`"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:609
msgid ":lookup:`has_keys <hstorefield.has_keys>`"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:614
msgid "Range Fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:616
msgid ""
"There are five range field types, corresponding to the built-in range types "
"in PostgreSQL. These fields are used to store a range of values; for example "
"the start and end timestamps of an event, or the range of ages an activity "
"is suitable for."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:621
msgid ""
"All of the range fields translate to :ref:`psycopg2 Range objects <psycopg2:"
"adapt-range>` in Python, but also accept tuples as input if no bounds "
"information is necessary. The default is lower bound included, upper bound "
"excluded; that is, ``[)``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:627
msgid "``IntegerRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:631
msgid ""
"Stores a range of integers. Based on an :class:`~django.db.models."
"IntegerField`. Represented by an ``int4range`` in the database and a :class:"
"`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:636
#: ../../ref/contrib/postgres/fields.txt:650
#: ../../ref/contrib/postgres/fields.txt:698
msgid ""
"Regardless of the bounds specified when saving the data, PostgreSQL always "
"returns a range in a canonical form that includes the lower bound and "
"excludes the upper bound; that is ``[)``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:641
msgid "``BigIntegerRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:645
msgid ""
"Stores a range of large integers. Based on a :class:`~django.db.models."
"BigIntegerField`. Represented by an ``int8range`` in the database and a :"
"class:`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:655
msgid "``DecimalRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:661
msgid ""
"Stores a range of floating point values. Based on a :class:`~django.db."
"models.DecimalField`. Represented by a ``numrange`` in the database and a :"
"class:`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:667
msgid "``FloatRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:671
msgid ""
"Stores a range of floating point values. Based on a :class:`~django.db."
"models.FloatField`. Represented by a ``numrange`` in the database and a :"
"class:`~psycopg2:psycopg2.extras.NumericRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:677
msgid "Use :class:`DecimalRangeField` instead."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:680
msgid "``DateTimeRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:684
msgid ""
"Stores a range of timestamps. Based on a :class:`~django.db.models."
"DateTimeField`. Represented by a ``tstzrange`` in the database and a :class:"
"`~psycopg2:psycopg2.extras.DateTimeTZRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:690
msgid "``DateRangeField``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:694
msgid ""
"Stores a range of dates. Based on a :class:`~django.db.models.DateField`. "
"Represented by a ``daterange`` in the database and a :class:`~psycopg2:"
"psycopg2.extras.DateRange` in Python."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:703
msgid "Querying Range Fields"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:705
msgid ""
"There are a number of custom lookups and transforms for range fields. They "
"are available on all the above fields, but we will use the following example "
"model::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:720
msgid "We will also use the following example objects::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:728
msgid "and ``NumericRange``:"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:733
msgid "Containment functions"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:735
msgid ""
"As with other PostgreSQL fields, there are three standard containment "
"operators: ``contains``, ``contained_by`` and ``overlap``, using the SQL "
"operators ``@>``, ``<@``, and ``&&`` respectively."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:755
msgid ""
"The ``contained_by`` lookup is also available on the non-range field types: :"
"class:`~django.db.models.IntegerField`, :class:`~django.db.models."
"BigIntegerField`, :class:`~django.db.models.FloatField`, :class:`~django.db."
"models.DateField`, and :class:`~django.db.models.DateTimeField`. For "
"example::"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:777
msgid "Comparison functions"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:779
msgid ""
"Range fields support the standard lookups: :lookup:`lt`, :lookup:`gt`, :"
"lookup:`lte` and :lookup:`gte`. These are not particularly helpful - they "
"compare the lower bounds first and then the upper bounds only if necessary. "
"This is also the strategy used to order by a range field. It is better to "
"use the specific range comparison operators."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:788
msgid "``fully_lt``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:790
msgid ""
"The returned ranges are strictly less than the passed range. In other words, "
"all the points in the returned range are less than all those in the passed "
"range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:800
msgid "``fully_gt``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:802
msgid ""
"The returned ranges are strictly greater than the passed range. In other "
"words, the all the points in the returned range are greater than all those "
"in the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:812
msgid "``not_lt``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:814
msgid ""
"The returned ranges do not contain any points less than the passed range, "
"that is the lower bound of the returned range is at least the lower bound of "
"the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:824
msgid "``not_gt``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:826
msgid ""
"The returned ranges do not contain any points greater than the passed range, "
"that is the upper bound of the returned range is at most the upper bound of "
"the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:836
msgid "``adjacent_to``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:838
msgid "The returned ranges share a bound with the passed range."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:844
msgid "Querying using the bounds"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:846
msgid ""
"There are three transforms available for use in queries. You can extract the "
"lower or upper bound, or query based on emptiness."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:852
msgid "``startswith``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:854
msgid ""
"Returned objects have the given lower bound. Can be chained to valid lookups "
"for the base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:863
msgid "``endswith``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:865
msgid ""
"Returned objects have the given upper bound. Can be chained to valid lookups "
"for the base field."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:874
msgid "``isempty``"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:876
msgid ""
"Returned objects are empty ranges. Can be chained to valid lookups for a :"
"class:`~django.db.models.BooleanField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:883
msgid "Defining your own range types"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:885
msgid ""
"PostgreSQL allows the definition of custom range types. Django's model and "
"form field implementations use base classes below, and psycopg2 provides a :"
"func:`~psycopg2:psycopg2.extras.register_range` to allow use of custom range "
"types."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:892
msgid "Base class for model range fields."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:896
msgid "The model field class to use."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:900
#: ../../ref/contrib/postgres/fields.txt:917
msgid "The psycopg2 range type to use."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:904
msgid ""
"The form field class to use. Should be a subclass of :class:`django.contrib."
"postgres.forms.BaseRangeField`."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:909
msgid "Base class for form range fields."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:913
msgid "The form field to use."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:920
msgid "Range operators"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:926
msgid ""
"PostgreSQL provides a set of SQL operators that can be used together with "
"the range data types (see `the PostgreSQL documentation for the full details "
"of range operators <https://www.postgresql.org/docs/current/ functions-range."
"html#RANGE-OPERATORS-TABLE>`_). This class is meant as a convenient method "
"to avoid typos. The operator names overlap with the names of corresponding "
"lookups."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:948
msgid "RangeBoundary() expressions"
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:956
msgid ""
"If ``True`` (default), the lower bound is inclusive ``'['``, otherwise it's "
"exclusive ``'('``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:961
msgid ""
"If ``False`` (default), the upper bound is exclusive ``')'``, otherwise it's "
"inclusive ``']'``."
msgstr ""

#: ../../ref/contrib/postgres/fields.txt:964
msgid ""
"A ``RangeBoundary()`` expression represents the range boundaries. It can be "
"used with a custom range functions that expected boundaries, for example to "
"define :class:`~django.contrib.postgres.constraints.ExclusionConstraint`. "
"See `the PostgreSQL documentation for the full details <https://www."
"postgresql.org/ docs/current/rangetypes.html#RANGETYPES-INCLUSIVITY>`_."
msgstr ""
