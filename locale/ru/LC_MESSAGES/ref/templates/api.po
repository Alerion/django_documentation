# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2014, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-05 11:28+0300\n"
"PO-Revision-Date: 2016-03-22 16:26+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 1d201004172a46e59165f832c52481b4
#: ../../ref/templates/api.txt:3
msgid "The Django template language: for Python programmers"
msgstr "Язык шаблонов Django: для Python программистов"

# 523ab89fd9274fffacba647757a590b2
#: ../../ref/templates/api.txt:7
msgid ""
"This document explains the Django template system from a technical "
"perspective -- how it works and how to extend it. If you're just looking for "
"reference on the language syntax, see :doc:`/ref/templates/language`."
msgstr ""
"Этот раздел описывает систему шаблонов Django с технической стороны -- как "
"она работает и как расширить её. Если вы ищите просто описание синтаксиса "
"шаблонов, смотрите :doc:`/ref/templates/language`."

#: ../../ref/templates/api.txt:11
msgid ""
"It assumes an understanding of templates, contexts, variables, tags, and "
"rendering. Start with the :ref:`introduction to the Django template language "
"<template-language-intro>` if you aren't familiar with these concepts."
msgstr ""
"Этот документ подразумевает, что вы уже знакомы с шаблонами, контекстом, "
"переменными, тегами и рендерингом. Если вам не знакомы эти концепции, "
"начните с :ref:`вступления в систему шаблонов Django <template-language-"
"intro>`."

#: ../../ref/templates/api.txt:16
msgid "Overview"
msgstr "Введение"

# c9a0b776484849c28ce22782f30c9e28
#: ../../ref/templates/api.txt:18
msgid "Using the template system in Python is a three-step process:"
msgstr "Система шаблонов в Python работает в два этапа:"

#: ../../ref/templates/api.txt:20
msgid "You configure an :class:`Engine`."
msgstr "Вы настраиваете :class:`Engine`."

# 3cbf75ced2e046d8b1ba15e0ff119d06
#: ../../ref/templates/api.txt:21
msgid "You compile template code into a :class:`Template`."
msgstr "Сначала вы компилируете код шаблона в объект :class:`Template`."

#: ../../ref/templates/api.txt:22
msgid "You render the template with a :class:`Context`."
msgstr "Вы рендерите шаблон с :class:`Context`."

#: ../../ref/templates/api.txt:24
msgid ""
"Django projects generally rely on the :ref:`high level, backend agnostic "
"APIs <template-engines>` for each of these steps instead of the template "
"system's lower level APIs:"
msgstr ""
"Django использует :ref:`высокоуровневый API, который не привязан к "
"конкретному бэкенду <template-engines>`:"

#: ../../ref/templates/api.txt:28
msgid ""
"For each :class:`~django.template.backends.django.DjangoTemplates` backend "
"in the :setting:`TEMPLATES` setting, Django instantiates an :class:"
"`Engine`. :class:`~django.template.backends.django.DjangoTemplates` wraps :"
"class:`Engine` and adapts it to the common template backend API."
msgstr ""
"Для каждого бэкенда :class:`~django.template.backends.django."
"DjangoTemplates` из настройки the :setting:`TEMPLATES`, Django создает "
"экземпляр :class:`Engine`. :class:`~django.template.backends.django."
"DjangoTemplates` оборачивает :class:`Engine`, чтобы адаптировать его под API "
"конкретного бэкенда шаблонов."

#: ../../ref/templates/api.txt:32
msgid ""
"The :mod:`django.template.loader` module provides functions such as :func:"
"`~django.template.loader.get_template` for loading templates. They return a "
"``django.template.backends.django.Template`` which wraps the actual :class:"
"`django.template.Template`."
msgstr ""
"Модуль :mod:`django.template.loader` предоставляет функции, такие как :func:"
"`~django.template.loader.get_template`, для загрузки шаблонов. Они "
"возвращают ``django.template.backends.django.Template``, который "
"оборачивает :class:`django.template.Template`."

#: ../../ref/templates/api.txt:36
msgid ""
"The ``Template`` obtained in the previous step has a :meth:`~django.template."
"backends.base.Template.render` method which marshals a context and possibly "
"a request into a :class:`Context` and delegates the rendering to the "
"underlying :class:`Template`."
msgstr ""
"``Template``, полученный на предыдущем шаге, содержит метод :meth:`~django."
"template.backends.base.Template.render`, который оборачивает контекст и "
"запрос в :class:`Context` и делегирует рендеринг основному объекту :class:"
"`Template`."

#: ../../ref/templates/api.txt:42
msgid "Configuring an engine"
msgstr "Настройка бэкенда"

#: ../../ref/templates/api.txt:44
msgid ""
"If you are simply using the :class:`~django.template.backends.django."
"DjangoTemplates` backend, this probably isn't the documentation you're "
"looking for. An instance of the ``Engine`` class described below is "
"accessible using the ``engine`` attribute of that backend and any attribute "
"defaults mentioned below are overridden by what's passed by :class:`~django."
"template.backends.django.DjangoTemplates`."
msgstr ""
"Если вы просто используете :class:`~django.template.backends.django."
"DjangoTemplates` бэкенд, возможно вам не обязательно читать этот раздел. "
"Экземпляр ``Engine``, описанный ниже, доступен через атрибут ``engine`` "
"бэкенда, и все все атрибуты описанные ниже переопределены в :class:`~django."
"template.backends.django.DjangoTemplates`."

#: ../../ref/templates/api.txt:53
msgid ""
"When instantiating an ``Engine`` all arguments must be passed as keyword "
"arguments:"
msgstr ""
"При создании ``Engine`` все аргументы должны передаваться как именованные:"

#: ../../ref/templates/api.txt:56
msgid ""
"``dirs`` is a list of directories where the engine should look for template "
"source files. It is used to configure :class:`filesystem.Loader <django."
"template.loaders.filesystem.Loader>`."
msgstr ""
"``dirs`` -- это список каталого, в которых бэкенд ищет файлы шаблонов. "
"Используется для настройки :class:`filesystem.Loader <django.template."
"loaders.filesystem.Loader>`."

#: ../../ref/templates/api.txt:60 ../../ref/templates/api.txt:83
msgid "It defaults to an empty list."
msgstr "По умолчанию равен пустому списку."

#: ../../ref/templates/api.txt:62
msgid "``app_dirs`` only affects the default value of ``loaders``. See below."
msgstr ""
"``app_dirs`` влияет только на значение ``loaders`` по умолчанию. Смотрите "
"ниже."

#: ../../ref/templates/api.txt:64 ../../ref/templates/api.txt:92
msgid "It defaults to ``False``."
msgstr "По умолчанию ``False``."

#: ../../ref/templates/api.txt:66
msgid "``autoescape`` controls whether HTML autoescaping is enabled."
msgstr ""

#: ../../ref/templates/api.txt:68
#, fuzzy
msgid "It defaults to ``True``."
msgstr "По умолчанию ``False``."

#: ../../ref/templates/api.txt:72
msgid "Only set it to ``False`` if you're rendering non-HTML templates!"
msgstr ""

# 2b7bc73d3b6a4a659b522027cfbe1dac
# 6a6aa759374d427fbae438f7138f704e
#: ../../ref/templates/api.txt:76
#, fuzzy
msgid "The ``autoescape`` option was added."
msgstr "Был добавлен аргумент ``dirs``."

#: ../../ref/templates/api.txt:78
msgid ""
"``context_processors`` is a list of dotted Python paths to callables that "
"are used to populate the context when a template is rendered with a request. "
"These callables take a request object as their argument and return a :class:"
"`dict` of items to be merged into the context."
msgstr ""
"``context_processors`` -- список путей Python для импорта функций, которые "
"используются для наполнения контекста шаблонов, если он рендерится с "
"объектом запроса. Эти функции принимают объект запроса и возвращают :class:"
"`dict` значений, которые будут добавлены в контекст."

#: ../../ref/templates/api.txt:85
msgid "See :class:`~django.template.RequestContext` for more information."
msgstr ""
"Подробности смотрите в описании :class:`~django.template.RequestContext`."

#: ../../ref/templates/api.txt:87
msgid ""
"``debug`` is a boolean that turns on/off template debug mode. If it is "
"``True``, the template engine will store additional debug information which "
"can be used to display a detailed report for any exception raised during "
"template rendering."
msgstr ""
"``debug`` -- булево значение, которое включает и выключает режим отладки. "
"При ``True`` шаблонизатор сохраняет дополнительную отладочную информацию, "
"которая может использоваться для отображения информации ошибки, которая "
"возникла во время рендеринга."

#: ../../ref/templates/api.txt:94
msgid ""
"``loaders`` is a list of template loader classes, specified as strings. Each "
"``Loader`` class knows how to import templates from a particular source. "
"Optionally, a tuple can be used instead of a string. The first item in the "
"tuple should be the ``Loader`` class name, subsequent items are passed to "
"the ``Loader`` during initialization."
msgstr ""
"``loaders`` -- список загрузчиков шаблонов, указанных строками. Каждый класс "
"``Loader`` знает как загрузить шаблоны из определенного источника. Вместо "
"строки можно указать кортеж. Первым элементом должен быть путь к классу "
"``Loader``, вторым -- параметры, которые будут переданы в ``Loader`` при "
"инициализации."

#: ../../ref/templates/api.txt:100
msgid "It defaults to a list containing:"
msgstr "По умолчанию содержит список:"

# 5edff49860f9475dac1d179479ec492c
#: ../../ref/templates/api.txt:102
msgid "``'django.template.loaders.filesystem.Loader'``"
msgstr "``'django.template.loaders.filesystem.Loader'``"

# 2aba8252bf3a4176a6e476db0436377a
#: ../../ref/templates/api.txt:103
msgid ""
"``'django.template.loaders.app_directories.Loader'`` if and only if "
"``app_dirs`` is ``True``."
msgstr ""
"``'django.template.loaders.app_directories.Loader'``, только если "
"``app_dirs`` равен ``True``."

#: ../../ref/templates/api.txt:106
msgid ""
"If ``debug`` is ``False``, these loaders are wrapped in :class:`django."
"template.loaders.cached.Loader`."
msgstr ""

#: ../../ref/templates/api.txt:109
msgid "See :ref:`template-loaders` for details."
msgstr "Подробности смотрите в :ref:`template-loaders`."

#: ../../ref/templates/api.txt:113
msgid ""
"Enabling of the cached template loader when ``debug`` is ``False`` was added."
msgstr ""

#: ../../ref/templates/api.txt:116
msgid ""
"``string_if_invalid`` is the output, as a string, that the template system "
"should use for invalid (e.g. misspelled) variables."
msgstr ""
"``string_if_invalid`` значение, которые шаблонизатор выведет вместо "
"неправильной переменной(например, с опечаткой в назчании)."

#: ../../ref/templates/api.txt:119
msgid "It defaults to the empty string."
msgstr "По умолчанию -- пустая строка."

#: ../../ref/templates/api.txt:121
msgid "See :ref:`invalid-template-variables` for details."
msgstr "Смотрите подробности в :ref:`invalid-template-variables`."

#: ../../ref/templates/api.txt:123
msgid "``file_charset`` is the charset used to read template files on disk."
msgstr ""
"``file_charset`` -- кодировка, которая используется при чтении файла шаблона "
"с диска."

#: ../../ref/templates/api.txt:125
msgid "It defaults to ``'utf-8'``."
msgstr "По умолчанию ``'utf-8'``."

#: ../../ref/templates/api.txt:127
msgid ""
"``'libraries'``: A dictionary of labels and dotted Python paths of template "
"tag modules to register with the template engine. This is used to add new "
"libraries or provide alternate labels for existing ones. For example::"
msgstr ""
"``'libraries'``: список названий и путей Python к модулям с тегами, которые "
"будут зарегистрированы в бэкенде шаблонизатора. Используется, чтобы добавить "
"новые библиотеки, или поменять названия для существующих. Например::"

#: ../../ref/templates/api.txt:138
msgid ""
"Libraries can be loaded by passing the corresponding dictionary key to the :"
"ttag:`{% load %}<load>` tag."
msgstr ""
"Библиотеки могут быть импортированы с помощью тега :ttag:`{% load %}<load>`, "
"передав указанный в словаре ключ."

#: ../../ref/templates/api.txt:141
msgid ""
"``'builtins'``: A list of dotted Python paths of template tag modules to add "
"to :doc:`built-ins </ref/templates/builtins>`. For example::"
msgstr ""
"``'builtins'``: Список путей Python к модулям с тегами, которые будут "
"добавлены к :doc:`встроенным </ref/templates/builtins>`. Например::"

#: ../../ref/templates/api.txt:148
msgid ""
"Tags and filters from built-in libraries can be used without first calling "
"the :ttag:`{% load %}<load>` tag."
msgstr ""
"Теги и фильтры из этих модулей можно использовать без вызова тега :ttag:`{% "
"load %}<load>`."

#: ../../ref/templates/api.txt:153
msgid ""
"When a Django project configures one and only one :class:`~django.template."
"backends.django.DjangoTemplates` engine, this method returns the underlying :"
"class:`Engine`. In other circumstances it will raise :exc:`~django.core."
"exceptions.ImproperlyConfigured`."
msgstr ""
"Если проект настроен на использование :class:`~django.template.backends."
"django.DjangoTemplates` и только его, этот метод вернет соответствующий :"
"class:`Engine`. Иначе вызовет исключение :exc:`~django.core.exceptions."
"ImproperlyConfigured`."

#: ../../ref/templates/api.txt:158
msgid ""
"It's required for preserving APIs that rely on a globally available, "
"implicitly configured engine. Any other use is strongly discouraged."
msgstr ""
"Необходим для совместимости API, который рассчитывает на глобальный, неявно "
"настроенный механизм шаблонов. Не следует использовать для других ситуаций."

# 3cbf75ced2e046d8b1ba15e0ff119d06
#: ../../ref/templates/api.txt:163
msgid ""
"Compiles the given template code and returns a :class:`Template` object."
msgstr "Сначала вы компилируете код шаблона в объект :class:`Template`."

#: ../../ref/templates/api.txt:167
msgid ""
"Loads a template with the given name, compiles it and returns a :class:"
"`Template` object."
msgstr ""
"Загружает шаблон с указанным названием, компилирует его и возвращает объект :"
"class:`Template`."

# 1d9e88c402fa41e283ac3ada1911811e
#: ../../ref/templates/api.txt:172
msgid ""
"Like :meth:`~Engine.get_template`, except it takes a list of names and "
"returns the first template that was found."
msgstr ""
"Похож на :meth:`~Engine.get_template`, но принимает список шаблонов и "
"возвращает первый доступный шаблон из списка."

# d81d691eb3f547c1977948b7ce189443
#: ../../ref/templates/api.txt:176
msgid "Loading a template"
msgstr "Загрузка шаблонов"

#: ../../ref/templates/api.txt:178
msgid ""
"The recommended way to create a :class:`Template` is by calling the factory "
"methods of the :class:`Engine`: :meth:`~Engine.get_template`, :meth:`~Engine."
"select_template` and :meth:`~Engine.from_string`."
msgstr ""
"Рекомендуемый метод создать :class:`Template` -- использовать методы-"
"фабрики :class:`Engine`: :meth:`~Engine.get_template`, :meth:`~Engine."
"select_template` и :meth:`~Engine.from_string`."

#: ../../ref/templates/api.txt:182
msgid ""
"In a Django project where the :setting:`TEMPLATES` setting defines exactly "
"one :class:`~django.template.backends.django.DjangoTemplates` engine, it's "
"possible to instantiate a :class:`Template` directly."
msgstr ""
"В проекте, где настройка :setting:`TEMPLATES` содержит только :class:"
"`~django.template.backends.django.DjangoTemplates`, можно создать экземпляр :"
"class:`Template` напрямую."

# 3f5bf22c215040838bdbfffa2ce09e7c
#: ../../ref/templates/api.txt:188
msgid ""
"This class lives at ``django.template.Template``. The constructor takes one "
"argument — the raw template code::"
msgstr ""
"Класс находится в ``django.template.Template``. Конструктор принимает один "
"аргумент -- \"сырой\" код шаблона::"

# c4fa321944fc4da2839f042590efbdee
#: ../../ref/templates/api.txt:195
msgid "Behind the scenes"
msgstr "За кулисами"

# 16370177e41b436ba9e84d2c26c74ce2
#: ../../ref/templates/api.txt:197
msgid ""
"The system only parses your raw template code once -- when you create the "
"``Template`` object. From then on, it's stored internally as a tree "
"structure for performance."
msgstr ""
"Система парсит код шаблона один раз -- когда вы создаете объект "
"``Template``. Результат для оптимизации сохраняется в памяти как древовидная "
"структура."

# f3631b1d934e4066a9dbfc9b4f180c45
#: ../../ref/templates/api.txt:201
msgid ""
"Even the parsing itself is quite fast. Most of the parsing happens via a "
"single call to a single, short, regular expression."
msgstr ""
"Сам по себе парсинг работает достаточно быстро, обычно с помощью небольших "
"регулярных выражений."

# b8479b83e5e5453f8d8cff47b5354942
#: ../../ref/templates/api.txt:205
msgid "Rendering a context"
msgstr "Рендеринг контекста"

# 96e15b84123d4e208b76a62fc6ff5c21
#: ../../ref/templates/api.txt:207
msgid ""
"Once you have a compiled :class:`Template` object, you can render a context "
"with it. You can reuse the same template to render it several times with "
"different contexts."
msgstr ""
"Скомпилировав объект :class:`Template`, вы можете отрендерить с его помощью "
"контекст. Вы можете использовать один и тот же объект шаблона, чтобы "
"отрендерить несколько контекстов."

#: ../../ref/templates/api.txt:213
msgid ""
"This class lives at ``django.template.Context``. The constructor takes two "
"optional arguments:"
msgstr ""
"Класс контекста находит в ``django.template.Context``. Конструктор принимает "
"два необязательных аргумента:"

# 685166cfc97c469f9943fb9fc4bdfea4
#: ../../ref/templates/api.txt:216
msgid "A dictionary mapping variable names to variable values."
msgstr "Словарь с переменными и их значениями."

# b141f02d72c74a32a9c8fb67ad0ba180
#: ../../ref/templates/api.txt:218
msgid ""
"The name of the current application. This application name is used to help :"
"ref:`resolve namespaced URLs<topics-http-reversing-url-namespaces>`. If "
"you're not using namespaced URLs, you can ignore this argument."
msgstr ""
"Название текущего приложения. Оно помогает :ref:`определить текущее "
"пространство имен для URL-ов<topics-http-reversing-url-namespaces>`. Если вы "
"не используете пространство имен для URL-ов, можете игнорировать этот "
"аргумент."

#: ../../ref/templates/api.txt:222
msgid "For details, see :ref:`playing-with-context` below."
msgstr "Подробности смотрте ниже в :ref:`playing-with-context`."

# b31114656a0b4c80babfe0969e50845a
#: ../../ref/templates/api.txt:226
msgid ""
"Call the :class:`Template` object's ``render()`` method with a :class:"
"`Context` to \"fill\" the template::"
msgstr ""
"Вызовите метод ``render()`` объекта :class:`Template` с контекстом, чтобы "
"\"выполнить\" шаблон::"

# cc11f714920c4b97b81da1e1a20bc41f
#: ../../ref/templates/api.txt:241
msgid "Variables and lookups"
msgstr "Переменные"

# ce8561cad1fe4615bc3131708270eaec
#: ../../ref/templates/api.txt:243
msgid ""
"Variable names must consist of any letter (A-Z), any digit (0-9), an "
"underscore (but they must not start with an underscore) or a dot."
msgstr ""
"Название переменной может состоять из букв (A-Z), цифр (0-9), подчеркивания "
"(но не начинаться с подчеркивания) или точки."

# 054cdf9dc0af4943be66560c80e3de26
#: ../../ref/templates/api.txt:246
msgid ""
"Dots have a special meaning in template rendering. A dot in a variable name "
"signifies a **lookup**. Specifically, when the template system encounters a "
"dot in a variable name, it tries the following lookups, in this order:"
msgstr ""
"У точки особое значение. Точка в названии переменной означает **поиск**. "
"Встретив точку в названии переменной, система шаблонов пытается найти "
"значение в следующем подряке:"

# f75b61bd2d1c49b4ba3d6d3ec3b26663
#: ../../ref/templates/api.txt:250
msgid "Dictionary lookup. Example: ``foo[\"bar\"]``"
msgstr "Поиск в словаре. Например: ``foo[\"bar\"]``"

# 55b4428f26fd4a25a21963417dc54b41
#: ../../ref/templates/api.txt:251
msgid "Attribute lookup. Example: ``foo.bar``"
msgstr "Поиск атрибута. Например: ``foo.bar``"

# bbceeff1118e4da2b909562d35269a50
#: ../../ref/templates/api.txt:252
msgid "List-index lookup. Example: ``foo[bar]``"
msgstr "Поиск в списке. Напрмиер: ``foo[bar]``"

# 89f6aba887d045ca8d5e264414da949f
#: ../../ref/templates/api.txt:254
msgid ""
"Note that \"bar\" in a template expression like ``{{ foo.bar }}`` will be "
"interpreted as a literal string and not using the value of the variable \"bar"
"\", if one exists in the template context."
msgstr ""
"Обратите внимание, \"bar\" в выражении ``{{ foo.bar }}`` будет "
"интепретировано как строка \"bar\", а не переменная с названием \"bar\"."

# db5e81b0818e4544b5ccd7019f45cc7c
#: ../../ref/templates/api.txt:258
msgid ""
"The template system uses the first lookup type that works. It's short-"
"circuit logic. Here are a few examples::"
msgstr ""
"Система шаблонов будет использовать первое найденное значение. Вот несколько "
"примеров::"

# ae9a3a25971f49bebd4170bbd0bc8b2d
#: ../../ref/templates/api.txt:279
msgid ""
"If any part of the variable is callable, the template system will try "
"calling it. Example::"
msgstr ""
"Если найдена функция, или любой другой вызываемый объект, шаблон попытается "
"вызвать её. Например::"

# 1ed4d072fd0f4472a42f3e8a5d4ddfae
#: ../../ref/templates/api.txt:289
msgid ""
"Callable variables are slightly more complex than variables which only "
"require straight lookups. Here are some things to keep in mind:"
msgstr ""
"Вызываемые переменные работают немного сложнее. Вам следует помнить о "
"следующем:"

# 5b6dd06f94af43c599facef6e0c51bbc
#: ../../ref/templates/api.txt:292
msgid ""
"If the variable raises an exception when called, the exception will be "
"propagated, unless the exception has an attribute "
"``silent_variable_failure`` whose value is ``True``. If the exception *does* "
"have a ``silent_variable_failure`` attribute whose value is ``True``, the "
"variable will render as the value of the engine's ``string_if_invalid`` "
"configuration option (an empty string, by default). Example::"
msgstr ""
"Если выполнение функции вызвало исключение, это приведет к ошибке при "
"выполнении шаблона, если только исключение не содержит атрибут "
"``silent_variable_failure`` равный ``True``. В таком случае переменная будет "
"отрендерена со значением опции ``string_if_invalid`` шаблонизатора (пустая "
"строка по умолчанию). Например::"

# 592dd2e2a3e644c5a8e800ed2c959a50
#: ../../ref/templates/api.txt:319
msgid ""
"Note that :exc:`django.core.exceptions.ObjectDoesNotExist`, which is the "
"base class for all Django database API ``DoesNotExist`` exceptions, has "
"``silent_variable_failure = True``. So if you're using Django templates with "
"Django model objects, any ``DoesNotExist`` exception will fail silently."
msgstr ""
"Обратите внимание, :exc:`django.core.exceptions.ObjectDoesNotExist`, который "
"является родительским для всех ошибок ``DoesNotExist`` в ORM, содержит "
"``silent_variable_failure = True``. Поэтому, если вы используете объекты "
"модели в шаблонах, исключение ``DoesNotExist`` будет проигнорировано."

# d73f22c8b1954859b58e4f27ef4eb2aa
#: ../../ref/templates/api.txt:325
msgid ""
"A variable can only be called if it has no required arguments. Otherwise, "
"the system will return the value of the engine's ``string_if_invalid`` "
"option."
msgstr ""
"Функция из переменной может быть вызвана, только если не требует "
"обязательных аргументов. В таком случае шаблон вставит вместо переменной "
"значение ``string_if_invalid``."

# c776f677bf8146da8b35d2c9fc7053aa
#: ../../ref/templates/api.txt:331
msgid ""
"Obviously, there can be side effects when calling some variables, and it'd "
"be either foolish or a security hole to allow the template system to access "
"them."
msgstr ""
"Очевидно, что вызов функций может выполнять различные побочные действия, "
"которые могут привести к уязвимостям, было бы глупо позволять шаблону "
"выполнять их."

# a9cbe2f62d254a07861264c91cd668b0
#: ../../ref/templates/api.txt:335
msgid ""
"A good example is the :meth:`~django.db.models.Model.delete` method on each "
"Django model object. The template system shouldn't be allowed to do "
"something like this::"
msgstr ""
"Хороший пример -- метод :meth:`~django.db.models.Model.delete` модели. "
"Нельзя позволять шаблонам выполнять следующее::"

# 9f926c76e557480ba20683c4b3d012ee
#: ../../ref/templates/api.txt:341
msgid ""
"To prevent this, set an ``alters_data`` attribute on the callable variable. "
"The template system won't call a variable if it has ``alters_data=True`` "
"set, and will instead replace the variable with ``string_if_invalid``, "
"unconditionally.  The dynamically-generated :meth:`~django.db.models.Model."
"delete` and :meth:`~django.db.models.Model.save` methods on Django model "
"objects get ``alters_data=True`` automatically. Example::"
msgstr ""
"Чтобы избежать этого, укажите атрибут ``alters_data`` в функции или методе. "
"Шаблон не будет вызывать переменную, если значение содержит "
"``alters_data=True``, и будет использовать значение настройки "
"``string_if_invalid``. Встроенные методы :meth:`~django.db.models.Model."
"delete` и :meth:`~django.db.models.Model.save` модели содержат атрибут "
"``alters_data=True``. Например::"

# 7945e0cd774e4dc295d7cd6d3274882b
#: ../../ref/templates/api.txt:353
msgid ""
"Occasionally you may want to turn off this feature for other reasons, and "
"tell the template system to leave a variable uncalled no matter what.  To do "
"so, set a ``do_not_call_in_templates`` attribute on the callable with the "
"value ``True``.  The template system then will act as if your variable is "
"not callable (allowing you to access attributes of the callable, for "
"example)."
msgstr ""
"В некоторых случая может понадобится отключить вызов переменной и "
"использовать значение как есть. Для этого укажите атрибут "
"``do_not_call_in_templates`` со значением ``True``. Шаблон будет "
"интерпретировать такую функцию как не вызываемое значение (позволяя "
"обратиться к её атрибутам, например)."

# 5998286e9ce14a5bb7f17386be8846bd
#: ../../ref/templates/api.txt:363
msgid "How invalid variables are handled"
msgstr "Как обрабатываются неправильные переменные"

# fa0bd15decb2475abc38d172aeff627f
#: ../../ref/templates/api.txt:365
msgid ""
"Generally, if a variable doesn't exist, the template system inserts the "
"value of the engine's ``string_if_invalid`` configuration option, which is "
"set to ``''`` (the empty string) by default."
msgstr ""
"Если переменная не найдена в шаблоне, будет использоваться значение опции "
"``string_if_invalid`` шаблонизатора, равной по умолчанию ``''`` (пустая "
"строка)."

# 00f8c67b48fc45b1b82a7d080d450bb4
#: ../../ref/templates/api.txt:369
msgid ""
"Filters that are applied to an invalid variable will only be applied if "
"``string_if_invalid`` is set to ``''`` (the empty string). If "
"``string_if_invalid`` is set to any other value, variable filters will be "
"ignored."
msgstr ""
"Фильтры, которые указаны для переменной, будут применяться, только если "
"``string_if_invalid`` равна ``''`` (пустая строка). Если "
"``string_if_invalid`` равна другому значению, фильтры будут проигнорированы."

# 83b13b0c542440c6ae29aa4550e1d850
#: ../../ref/templates/api.txt:374
msgid ""
"This behavior is slightly different for the ``if``, ``for`` and ``regroup`` "
"template tags. If an invalid variable is provided to one of these template "
"tags, the variable will be interpreted as ``None``. Filters are always "
"applied to invalid variables within these template tags."
msgstr ""
"Теги ``if``, ``for`` и ``regroup`` работают немного по другому. Если указать "
"неправильную переменную, будет использоваться значение ``None``. Фильтры "
"всегда применяются к переменной в этих тегах."

# c93e99e5e7ad4341803113e86569f0ec
#: ../../ref/templates/api.txt:379
msgid ""
"If ``string_if_invalid`` contains a ``'%s'``, the format marker will be "
"replaced with the name of the invalid variable."
msgstr ""
"Если ``string_if_invalid`` содержит ``'%s'``, будет подставлено название "
"переменной."

# db5d94cc6e2b415998cd320a5665670b
#: ../../ref/templates/api.txt:382
msgid "For debug purposes only!"
msgstr "Только для отладки!"

# 5fe77ee37a764c9a9d21afc4af1dd96a
#: ../../ref/templates/api.txt:384
msgid ""
"While ``string_if_invalid`` can be a useful debugging tool, it is a bad idea "
"to turn it on as a 'development default'."
msgstr ""
"Хотя ``string_if_invalid`` и полезная для отладки, лучше не менять её по "
"умолчанию и использовать только при необходимости локально."

# c4e4535f0e85426da064d2780ce65f1d
#: ../../ref/templates/api.txt:387
msgid ""
"Many templates, including those in the Admin site, rely upon the silence of "
"the template system when a non-existent variable is encountered. If you "
"assign a value other than ``''`` to ``string_if_invalid``, you will "
"experience rendering problems with these templates and sites."
msgstr ""
"Многие шаблоны, включая шаблоны админки, полагаются на то, что неправильные "
"переменные будут проигнорированы системой шаблонов. Если заменить ``''`` в "
"``string_if_invalid`` на другое значение, могут возникнуть проблемы с "
"рендерингом шаблонов."

# d9c1b9e7a8b142a2942d3a959e03396c
#: ../../ref/templates/api.txt:392
msgid ""
"Generally, ``string_if_invalid`` should only be enabled in order to debug a "
"specific template problem, then cleared once debugging is complete."
msgstr ""
"Как правило ``string_if_invalid`` необходимо использовать для отладки "
"конкретной проблемы в шаблоне, и после отладки возвращать значение по "
"умолчанию."

# 49a720c370054926947d014bed08b497
#: ../../ref/templates/api.txt:396
msgid "Built-in variables"
msgstr "Встроенные переменные"

# 59a36043915e43d18199785e04f99b19
#: ../../ref/templates/api.txt:398
msgid ""
"Every context contains ``True``, ``False`` and ``None``. As you would "
"expect, these variables resolve to the corresponding Python objects."
msgstr ""
"Каждый контекст содержит ``True``, ``False`` и ``None``. Как и следовало "
"ожидать эти переменные соответствуют объектам Python."

# 577a939d6c3f4b92ae4734e159bc9f66
#: ../../ref/templates/api.txt:402
msgid "Limitations with string literals"
msgstr "Ограничения текстовых литералов"

# e95d11ea17ea4a2191bb00f2eada7ebe
#: ../../ref/templates/api.txt:404
msgid ""
"Django's template language has no way to escape the characters used for its "
"own syntax. For example, the :ttag:`templatetag` tag is required if you need "
"to output character sequences like ``{%`` and ``%}``."
msgstr ""
"Система шаблонов Django не позволяет экранировать символы, которые "
"используются в синтаксисе разметки шаблонов. Например, следует использовать "
"тег :ttag:`templatetag`, если необходимо вывести в шаблоне ``{%`` и ``%}`` "
"как строки."

# fa5ba05bbb9f41759bba510cd5e87340
#: ../../ref/templates/api.txt:408
msgid ""
"A similar issue exists if you want to include these sequences in template "
"filter or tag arguments. For example, when parsing a block tag, Django's "
"template parser looks for the first occurrence of ``%}`` after a ``{%``. "
"This prevents the use of ``\"%}\"`` as a string literal. For example, a "
"``TemplateSyntaxError`` will be raised for the following expressions::"
msgstr ""
"Аналогичные проблемы возникают, если необходимо использовать эти значения "
"как аргумент фильтра или тега. Например, при парсинге блочного тега, Django "
"ищет первое появление ``%}`` после ``{%``. Таким образом нельзя использовать "
"``\"%}\"`` как текст. Например, в следующих ситуациях будет вызвано "
"исключение ``TemplateSyntaxError``::"

# 7bc23eca2b824630beee07304e23b9e7
#: ../../ref/templates/api.txt:418
msgid ""
"The same issue can be triggered by using a reserved sequence in filter "
"arguments::"
msgstr ""
"Аналогичная проблема возникнет при использовании ``}}`` в качестве аргумента "
"фильтра::"

# 9de643ca8bdc4b9d83fb349740f92af7
#: ../../ref/templates/api.txt:423
msgid ""
"If you need to use strings with these sequences, store them in template "
"variables or use a custom template tag or filter to workaround the "
"limitation."
msgstr ""
"Чтобы обойти эти ограничения, используйте переменную для хранения "
"запрещенных строк, или свой теги или фильтр, чтобы обойти ограничения."

# 23aa021c846d43c1bc1457f2ca6f6dc6
#: ../../ref/templates/api.txt:429
#, fuzzy
msgid "Playing with ``Context`` objects"
msgstr "Использование объекта Context"

# 3d215e0a227d4ec9a65d7c6b2042d470
#: ../../ref/templates/api.txt:431
msgid ""
"Most of the time, you'll instantiate :class:`Context` objects by passing in "
"a fully-populated dictionary to ``Context()``. But you can add and delete "
"items from a ``Context`` object once it's been instantiated, too, using "
"standard dictionary syntax::"
msgstr ""
"Обычно при создании объекта :class:`Context` сразу передается словарь со "
"всеми переменными. Но вы можете менять содержимое объекта ``Context`` и "
"после его инициализации, использую стандартный API словарей::"

#: ../../ref/templates/api.txt:451
msgid ""
"Returns the value for ``key`` if ``key`` is in the context, else returns "
"``otherwise``."
msgstr ""
"Возвращает значение для ``key``, если ``key`` находится в контексте, иначе "
"возвращает ``otherwise``."

#: ../../ref/templates/api.txt:456
msgid ""
"If ``key`` is in the context, returns its value. Otherwise inserts ``key`` "
"with a value of ``default`` and returns ``default``."
msgstr ""
"Если контекст содержит ``key``, вернет его значение. Иначе добавит ``key`` с "
"значением ``default`` и вернет ``default``."

# 2cfc8d63979a4e47b03873aec19ea4cd
#: ../../ref/templates/api.txt:463
msgid ""
"A ``Context`` object is a stack. That is, you can ``push()`` and ``pop()`` "
"it. If you ``pop()`` too much, it'll raise ``django.template."
"ContextPopException``::"
msgstr ""
"Объект ``Context`` работает как стек. Поэтому можно использовать методы "
"``push()`` и ``pop()``. Если вызывать ``pop()`` слишком часто, будет вызвано "
"исключение ``django.template.ContextPopException``::"

# 55e1368f231a4a468b2cf38260f52094
#: ../../ref/templates/api.txt:486
msgid ""
"You can also use ``push()`` as a context manager to ensure a matching "
"``pop()`` is called."
msgstr ""
"``push()`` можно использовать как менеджер контекста, чтобы быть уверенным, "
"что будет ``pop()`` вызван в конце."

# 681d9c1b256c450da9a31e7edcd1c27c
#: ../../ref/templates/api.txt:498
msgid ""
"All arguments passed to ``push()`` will be passed to the ``dict`` "
"constructor used to build the new context level."
msgstr ""
"Все аргументы ``push()`` будут переданы в конструктор ``dict`` при создании "
"нового слоя в контексте."

# 2170415dc10649d8bfa0edfe98bde326
#: ../../ref/templates/api.txt:511
msgid ""
"In addition to ``push()`` and ``pop()``, the ``Context`` object also defines "
"an ``update()`` method. This works like ``push()`` but takes a dictionary as "
"an argument and pushes that dictionary onto the stack instead of an empty "
"one."
msgstr ""
"Кроме ``push()`` и ``pop()`` объект ``Context`` также предоставляет метод "
"``update()``. Работает как и ``push()``, но принимает словарь в качестве "
"аргумента и добавляет его в стек."

# 55e1368f231a4a468b2cf38260f52094
#: ../../ref/templates/api.txt:527
msgid ""
"Like ``push()``, you can use ``update()`` as a context manager to ensure a "
"matching ``pop()`` is called."
msgstr ""
"Как и ``push()``, вы можете использовать ``update()`` как менеджер "
"контекста, чтобы быть уверенным, что будет ``pop()`` вызван в конце."

# 1a23db2e66de429da838ef8c0eaaaf87
#: ../../ref/templates/api.txt:538
msgid ""
"Using a ``Context`` as a stack comes in handy in :ref:`some custom template "
"tags <howto-writing-custom-template-tags>`."
msgstr ""
"Использовать ``Context``, как стек, удобно в :ref:`собственных тегах <howto-"
"writing-custom-template-tags>`.."

# 61e9db3ead914d7a8e655258945a11f4
#: ../../ref/templates/api.txt:543
msgid ""
"Using ``flatten()`` method you can get whole ``Context`` stack as one "
"dictionary including builtin variables."
msgstr ""
"Метод ``flatten()`` возвращает весь стек ``Context`` одним словарём, включая "
"встроенные переменные."

# 97c6dfca57f641fbb7b2234b0decd0ef
#: ../../ref/templates/api.txt:553
msgid ""
"A ``flatten()`` method is also internally used to make ``Context`` objects "
"comparable."
msgstr ""
"Метод ``flatten()`` также используется для сравнения объектов ``Context`` "
"внутри системы шаблонов."

# a3808b43e3e441319c1465fa1d16ec67
#: ../../ref/templates/api.txt:564
msgid ""
"Result from ``flatten()`` can be useful in unit tests to compare ``Context`` "
"against ``dict``::"
msgstr ""
"Результат ``flatten()`` можно использовать в тестах для сравнения "
"``Context`` и ``dict``::"

# b3cfecf2edf84488aea9f62878ef6a9a
#: ../../ref/templates/api.txt:581
#, fuzzy
msgid "Using ``RequestContext``"
msgstr "Классы наследники Context: RequestContext"

# 794c75488db84963a4a2df2eb1408c38
#: ../../ref/templates/api.txt:585
msgid ""
"Django comes with a special ``Context`` class, ``django.template."
"RequestContext``, that acts slightly differently from the normal ``django."
"template.Context``. The first difference is that it takes an :class:`~django."
"http.HttpRequest` as its first argument. For example::"
msgstr ""
"Django предоставляет специальный класс ``Context``, ``django.template."
"RequestContext``, который немного отличается от обычного ``django.template."
"Context``. Первое отличие -- он принимает :class:`~django.http.HttpRequest` "
"первым аргументом. Например::"

# 36600bf9272b490a8f22225c32c90645
#: ../../ref/templates/api.txt:594
msgid ""
"The second difference is that it automatically populates the context with a "
"few variables, according to the engine's ``context_processors`` "
"configuration option."
msgstr ""
"Еще одно отличие -- он автоматически добавляет различные переменные в "
"соответствии с опцией ``context_processors`` шаблонизатора."

# d81ca0560a544e65b007c7936c5d9c2f
#: ../../ref/templates/api.txt:598
msgid ""
"The ``context_processors`` option is a list of callables -- called **context "
"processors** -- that take a request object as their argument and return a "
"dictionary of items to be merged into the context. In the default generated "
"settings file, the default template engine contains the following context "
"processors::"
msgstr ""
"``context_processors`` содержит кортеж функций, которые называются "
"**процессорами контекста**. Они принимают объект запроса в качестве "
"аргумента и возвращают словарь переменных, которые будут добавлены в "
"контекст. По умолчанию ``context_processors`` равна::"

# accd1f784a8e4727923bbc2a1fcb421a
#: ../../ref/templates/api.txt:611
msgid ""
"In addition to these, :class:`RequestContext` always enables ``'django."
"template.context_processors.csrf'``.  This is a security related context "
"processor required by the admin and other contrib apps, and, in case of "
"accidental misconfiguration, it is deliberately hardcoded in and cannot be "
"turned off in the ``context_processors`` option."
msgstr ""
"Кроме этого :class:`RequestContext` всегда использует ``django.core."
"context_processors.csrf``. Этот процессор контекста используется для "
"безопасности админкой и другими встроенными приложениями. Чтобы исключить "
"его случайное отключение, он захардкоден и не может быть выключен с помощью "
"настройки ``context_processors``."

# e3c6eff88d9147f6a2ff50c8ca76a65a
#: ../../ref/templates/api.txt:617
msgid ""
"Each processor is applied in order. That means, if one processor adds a "
"variable to the context and a second processor adds a variable with the same "
"name, the second will override the first. The default processors are "
"explained below."
msgstr ""
"Процессоры контекста применяются по очереди. Это означает, что один "
"процессор может перетереть переменную, которую добавил предыдущий. "
"Процессоры по умолчанию описаны ниже."

# 67c9890d0fc04471a9e1584fa2c50daf
#: ../../ref/templates/api.txt:622
msgid "When context processors are applied"
msgstr "Когда применяются процессоры контекста"

# 95c50fe560ff4cb08240345fb03de958
#: ../../ref/templates/api.txt:624
msgid ""
"Context processors are applied on top of context data. This means that a "
"context processor may overwrite variables you've supplied to your :class:"
"`Context` or :class:`RequestContext`, so take care to avoid variable names "
"that overlap with those supplied by your context processors."
msgstr ""
"Процессоры контекста применяются после инициализации контекста. То есть "
"процессор может перезаписать переменную, которую вы добавили в :class:"
"`Context` или :class:`RequestContext`. Поэтому избегайте названий "
"переменных, которые используются процессорами."

#: ../../ref/templates/api.txt:630
msgid ""
"If you want context data to take priority over context processors, use the "
"following pattern::"
msgstr ""
"Если вы хотите, чтобы переменная контекста перезаписывала переменные "
"процессора контекста, используйте следующий подход::"

#: ../../ref/templates/api.txt:638
msgid ""
"Django does this to allow context data to override context processors in "
"APIs such as :func:`~django.shortcuts.render` and :class:`~django.template."
"response.TemplateResponse`."
msgstr ""
"Django использует такой способ, чтобы перезаписать процессоры контекста во "
"внутреннем API, например :func:`~django.shortcuts.render` и :class:`~django."
"template.response.TemplateResponse`."

# 277c1ac702d4493eb42bcd33fdaa9682
#: ../../ref/templates/api.txt:642
msgid ""
"Also, you can give :class:`RequestContext` a list of additional processors, "
"using the optional, third positional argument, ``processors``. In this "
"example, the :class:`RequestContext` instance gets a ``ip_address`` "
"variable::"
msgstr ""
"Также в :class:`RequestContext` можно передать список дополнительных "
"процессоров контекста, используя третий необязательный аргумент "
"``processors``. В это примере в :class:`RequestContext` будет добавлена "
"переменная ``ip_address``::"

# 1fcde39b1ac443d8b4163bef8893de09
#: ../../ref/templates/api.txt:662
msgid "Built-in template context processors"
msgstr "Встроенные процессоры контекста"

# 67a7f24f7c234c958535ea79c218237a
#: ../../ref/templates/api.txt:664
msgid "Here's what each of the built-in processors does:"
msgstr "Вот список процессоров контекста по умолчанию:"

# 4f74c55c8ffb45b0b8ba336076dbd8d5
#: ../../ref/templates/api.txt:669
#, fuzzy
msgid "``django.contrib.auth.context_processors.auth``"
msgstr "django.contrib.auth.context_processors.auth"

# 46663a355dbf4721b6853eb24490fa14
#: ../../ref/templates/api.txt:673
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain these "
"variables:"
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будут добавлены следующие "
"переменные:"

# 2099f68b2f5e48b28426eba03ba71aed
#: ../../ref/templates/api.txt:676
msgid ""
"``user`` -- An ``auth.User`` instance representing the currently logged-in "
"user (or an ``AnonymousUser`` instance, if the client isn't logged in)."
msgstr ""
"``user`` -- объект ``auth.User`` текущего авторизованного пользователя или "
"объект ``AnonymousUser``, если пользователь не авторизованный)."

# df4a1fc2c560491a89c4b3c257fe4c39
#: ../../ref/templates/api.txt:680
msgid ""
"``perms`` -- An instance of ``django.contrib.auth.context_processors."
"PermWrapper``, representing the permissions that the currently logged-in "
"user has."
msgstr ""
"``perms`` -- объект ``django.contrib.auth.context_processors.PermWrapper``, "
"которые содержит права доступа текущего пользователя."

# b6966b419065485c982913cd7f637d4f
#: ../../ref/templates/api.txt:687
#, fuzzy
msgid "``django.template.context_processors.debug``"
msgstr "django.template.context_processors.debug"

# a782b2b8c6fd44ba917bcfbbdf44e825
#: ../../ref/templates/api.txt:691
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain these "
"two variables -- but only if your :setting:`DEBUG` setting is set to "
"``True`` and the request's IP address (``request.META['REMOTE_ADDR']``) is "
"in the :setting:`INTERNAL_IPS` setting:"
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будут добавлены следующие "
"переменные, но только при :setting:`DEBUG` равном ``True`` и, если IP адрес "
"запроса (``request.META['REMOTE_ADDR']``) указан в :setting:`INTERNAL_IPS`:"

# 6271cf99e53345d49968b2696f57c449
#: ../../ref/templates/api.txt:696
msgid ""
"``debug`` -- ``True``. You can use this in templates to test whether you're "
"in :setting:`DEBUG` mode."
msgstr ""
"``debug`` -- ``True``. Вы можете использовать эту переменную, чтобы "
"определить :setting:`DEBUG` режим в шаблоне."

# 88c3d9db22e145de9770af0ccb2e2cff
#: ../../ref/templates/api.txt:698
#, fuzzy
msgid ""
"``sql_queries`` -- A list of ``{'sql': ..., 'time': ...}`` dictionaries, "
"representing every SQL query that has happened so far during the request and "
"how long it took. The list is in order by database alias and then by query. "
"It's lazily generated on access."
msgstr ""
"``sql_queries`` -- список словарей ``{'sql': ..., 'time': ...}``, который "
"содержит все SQL запросы и время их выполнения, которые были выполнены при "
"обработке запроса. Список отсортирован в порядке выполнения SQL запроса."

#: ../../ref/templates/api.txt:705
msgid ""
"In older versions, only the queries for the default database alias were "
"included."
msgstr ""

# 40b3281520c24cd3b9f25692a7eb1e66
#: ../../ref/templates/api.txt:709
#, fuzzy
msgid "``django.template.context_processors.i18n``"
msgstr "django.template.context_processors.i18n"

# 13192c07fd7f4886978238bd1647af92
#: ../../ref/templates/api.txt:711 ../../ref/templates/api.txt:758
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain these "
"two variables:"
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будут добавлены следующие "
"переменные:"

# fd018e6040574d409ffe9e8f6821ce22
#: ../../ref/templates/api.txt:714
msgid "``LANGUAGES`` -- The value of the :setting:`LANGUAGES` setting."
msgstr "``LANGUAGES`` -- значение настройки :setting:`LANGUAGES`."

# db178c2698da4a83acd2ae7a47dd4c2d
#: ../../ref/templates/api.txt:715
msgid ""
"``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, if it exists. Otherwise, the "
"value of the :setting:`LANGUAGE_CODE` setting."
msgstr ""
"``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, если существует. Иначе "
"значение :setting:`LANGUAGE_CODE`."

# 7e82e3a962514a29bc03b9c1d8f887cc
#: ../../ref/templates/api.txt:718
msgid "See :doc:`/topics/i18n/index` for more."
msgstr "Смотрите :doc:`/topics/i18n/index`."

# fc4072670a644ed4a02af0c52d98c520
#: ../../ref/templates/api.txt:721
#, fuzzy
msgid "``django.template.context_processors.media``"
msgstr "django.template.context_processors.media"

# 12e09d53127e4245a94bd154e7c386a3
#: ../../ref/templates/api.txt:723
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain a "
"variable ``MEDIA_URL``, providing the value of the :setting:`MEDIA_URL` "
"setting."
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будет добавлена "
"переменная ``MEDIA_URL``, которая содержит значение :setting:`MEDIA_URL`."

# 0df2d136ed844df4a50afee535e871cf
#: ../../ref/templates/api.txt:727
#, fuzzy
msgid "``django.template.context_processors.static``"
msgstr "django.template.context_processors.static"

# f3d32a76ba94481da1d0d32d26f18845
#: ../../ref/templates/api.txt:731
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain a "
"variable ``STATIC_URL``, providing the value of the :setting:`STATIC_URL` "
"setting."
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будет добавлена "
"переменная ``STATIC_URL``, которая содержит значение :setting:`STATIC_URL`."

# e6fe13fc616949f4bae7a8c5d2ae2d25
#: ../../ref/templates/api.txt:735
#, fuzzy
msgid "``django.template.context_processors.csrf``"
msgstr "django.template.context_processors.csrf"

# 076ae19c926d4ab18330243dae9b902c
#: ../../ref/templates/api.txt:737
msgid ""
"This processor adds a token that is needed by the :ttag:`csrf_token` "
"template tag for protection against :doc:`Cross Site Request Forgeries </ref/"
"csrf>`."
msgstr ""
"Этот процессор добавляет токен, который используется тегом :ttag:"
"`csrf_token` для защиты от :doc:`CSRF атак </ref/csrf>`."

# d72b464bbbc54949b59c36334dc7feaf
#: ../../ref/templates/api.txt:742
#, fuzzy
msgid "``django.template.context_processors.request``"
msgstr "django.template.context_processors.request"

# 98fac01ff9c94f6abbdd64330987bc5b
#: ../../ref/templates/api.txt:744
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain a "
"variable ``request``, which is the current :class:`~django.http.HttpRequest`."
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будет добавлена "
"переменная ``request``, содержащая текущий :class:`~django.http.HttpRequest`."

# 0df2d136ed844df4a50afee535e871cf
#: ../../ref/templates/api.txt:748
#, fuzzy
msgid "``django.template.context_processors.tz``"
msgstr "django.template.context_processors.static"

# 12e09d53127e4245a94bd154e7c386a3
#: ../../ref/templates/api.txt:752
#, fuzzy
msgid ""
"If this processor is enabled, every ``RequestContext`` will contain a "
"variable ``TIME_ZONE``, providing the name of the currently active time zone."
msgstr ""
"Если включить этот процессор, в ``RequestContext`` будет добавлена "
"переменная ``MEDIA_URL``, которая содержит значение :setting:`MEDIA_URL`."

# 9f9382901d7a46d192a2fa172846980b
#: ../../ref/templates/api.txt:756
#, fuzzy
msgid "``django.contrib.messages.context_processors.messages``"
msgstr "django.contrib.messages.context_processors.messages"

# 093618ab1c0444b69851d6ee73afaf60
#: ../../ref/templates/api.txt:761
msgid ""
"``messages`` -- A list of messages (as strings) that have been set via the :"
"doc:`messages framework </ref/contrib/messages>`."
msgstr ""
"``messages`` -- список сообщений (строки), которые были добавлены с помощью :"
"doc:`фреймворка сообщений </ref/contrib/messages>`."

# 8378ef0e3f044f5abf7957024fe47468
#: ../../ref/templates/api.txt:763
msgid ""
"``DEFAULT_MESSAGE_LEVELS`` -- A mapping of the message level names to :ref:"
"`their numeric value <message-level-constants>`."
msgstr ""
"``DEFAULT_MESSAGE_LEVELS`` -- словарь приоритетов сообщений и :ref:`их "
"числовых кодов <message-level-constants>`."

# 1fcde39b1ac443d8b4163bef8893de09
#: ../../ref/templates/api.txt:767
msgid "Writing your own context processors"
msgstr "Как создать свой процессор контекста"

# 2e07708a63e24295b61c5c28b7a42378
#: ../../ref/templates/api.txt:769
#, fuzzy
msgid ""
"A context processor has a very simple interface: It's a Python function that "
"takes one argument, an :class:`~django.http.HttpRequest` object, and returns "
"a dictionary that gets added to the template context. Each context processor "
"*must* return a dictionary."
msgstr ""
"Интерфейс процессора контекста очень простой: это функция Python, которая "
"принимает один аргумент, объект :class:`~django.http.HttpRequest`, и "
"возвращает словарь, которая будет добавлен в контекст шаблона. Процессор "
"контекста *обязательно* должен возвращать словарь."

# 6b0ac5e3f8d34d8db46cc759c9fbadaa
#: ../../ref/templates/api.txt:774
msgid ""
"Custom context processors can live anywhere in your code base. All Django "
"cares about is that your custom context processors are pointed to by the "
"``'context_processors'`` option in your :setting:`TEMPLATES` setting — or "
"the ``context_processors`` argument of :class:`~django.template.Engine` if "
"you're using it directly."
msgstr ""
"Код процессора может находится где угодно. Главное не забыть указать его в "
"опции ``'context_processors'`` настройки:setting:`TEMPLATES`, или передать "
"аргументом ``context_processors`` в :class:`~django.template.Engine`."

# d81d691eb3f547c1977948b7ce189443
#: ../../ref/templates/api.txt:781
msgid "Loading templates"
msgstr "Загрузка шаблонов"

# 9769e4cc33644631ac451b17ef9ad14f
#: ../../ref/templates/api.txt:783
msgid ""
"Generally, you'll store templates in files on your filesystem rather than "
"using the low-level :class:`~django.template.Template` API yourself. Save "
"templates in a directory specified as a **template directory**."
msgstr ""
"Обычно при разработке проекта шаблоны хранятся в файлах, а не создаются с "
"помощью API :class:`~django.template.Template`. Сохраняйте их в каталоге, "
"который называют **каталог с шаблонами**."

# 9b644db389ab4622988041bbfbb06311
#: ../../ref/templates/api.txt:787
msgid ""
"Django searches for template directories in a number of places, depending on "
"your template loading settings (see \"Loader types\" below), but the most "
"basic way of specifying template directories is by using the :setting:`DIRS "
"<TEMPLATES-DIRS>` option."
msgstr ""
"Django ищет каталоги с шаблонами в соответствии с настройками загрузки "
"шаблонов (смотрите \"Типа загрузчиков\" ниже). Самый простой способ -- "
"указать каталоги с шаблонами в опции :setting:`DIRS <TEMPLATES-DIRS>`."

#: ../../ref/templates/api.txt:793
msgid "The :setting:`DIRS <TEMPLATES-DIRS>` option"
msgstr "Опция :setting:`DIRS <TEMPLATES-DIRS>`"

# b963a6780eb34ebd8c8372a2b3020080
#: ../../ref/templates/api.txt:795
msgid ""
"Tell Django what your template directories are by using the :setting:`DIRS "
"<TEMPLATES-DIRS>` option in the :setting:`TEMPLATES` setting in your "
"settings file — or the ``dirs`` argument of :class:`~django.template."
"Engine`. This should be set to a list of strings that contain full paths to "
"your template directories::"
msgstr ""
"Вы можете указать Django каталоги с шаблонами через опцию :setting:`DIRS "
"<TEMPLATES-DIRS>` настройки :setting:`TEMPLATES`, или в аргументе ``dirs`` "
"при создании :class:`~django.template.Engine`. Настройка должна содержать "
"список или кортеж полных путей к каталогам. Например::"

# 0be6659172bd4a05befb3397349badb6
#: ../../ref/templates/api.txt:811
msgid ""
"Your templates can go anywhere you want, as long as the directories and "
"templates are readable by the Web server. They can have any extension you "
"want, such as ``.html`` or ``.txt``, or they can have no extension at all."
msgstr ""
"Шаблоны могут находиться где угодно, главное, чтобы у Web-сервера были права "
"на чтение. Расширение файла может быть любым, ``.html`` или ``.txt``, или "
"вообще без расширения."

# 1f5dbb2948f54aab8299117d1382f8db
#: ../../ref/templates/api.txt:815
msgid ""
"Note that these paths should use Unix-style forward slashes, even on Windows."
msgstr ""
"Обратите внимание, пути должны быть Unix-стиле, даже для Windows (то есть "
"использовать ``/``)."

# f5de52746ee64836bff2111256443442
#: ../../ref/templates/api.txt:820
msgid "Loader types"
msgstr "Типы загрузчиков"

# a3e1a45cce4049b7b9236c6b951c0373
#: ../../ref/templates/api.txt:822
msgid ""
"By default, Django uses a filesystem-based template loader, but Django comes "
"with a few other template loaders, which know how to load templates from "
"other sources."
msgstr ""
"По умолчанию Django использует загрузчик шаблонов с файловой системы, но "
"Django предоставляет и другие загрузчики шаблонов, которые позволяют "
"загружать шаблоны с других источников."

# b2bb78e6164e46e2abcf47d3af2a37d6
#: ../../ref/templates/api.txt:826
msgid ""
"Some of these other loaders are disabled by default, but you can activate "
"them by adding a ``'loaders'`` option to your ``DjangoTemplates`` backend in "
"the :setting:`TEMPLATES` setting or passing a ``loaders`` argument to :class:"
"`~django.template.Engine`. ``loaders`` should be a list of strings or "
"tuples, where each represents a template loader class. Here are the template "
"loaders that come with Django:"
msgstr ""
"Некоторые из них выключены по умолчанию, но вы можете активировать их "
"изменив опцию ``'loaders'`` бэкенда ``DjangoTemplates`` в настройке :setting:"
"`TEMPLATES`, или передав аргумент ``loaders`` в :class:`~django.template."
"Engine`. Опция ``loaders`` содержит кортеж строк, каждая из которых "
"представляет класс загрузчика шаблонов. Вот список загрузчиков, которые "
"предоставляет Django:"

# 5edff49860f9475dac1d179479ec492c
#: ../../ref/templates/api.txt:835
msgid "``django.template.loaders.filesystem.Loader``"
msgstr "``django.template.loaders.filesystem.Loader``"

# 51b2227ae0f0440da206259e90aa40d0
#: ../../ref/templates/api.txt:839
msgid ""
"Loads templates from the filesystem, according to :setting:`DIRS <TEMPLATES-"
"DIRS>`."
msgstr ""
"Загружает шаблоны с файловой системы в соответствии с настройкой :setting:"
"`DIRS <TEMPLATES-DIRS>`."

#: ../../ref/templates/api.txt:842
msgid ""
"This loader is enabled by default. However it won't find any templates until "
"you set :setting:`DIRS <TEMPLATES-DIRS>` to a non-empty list::"
msgstr ""
"Этот загрузчик включен по умолчанию. Однако, он не найдет ни один шаблон, "
"пока вы не укажите список каталогов в :setting:`DIRS <TEMPLATES-DIRS>`::"

#: ../../ref/templates/api.txt:850
msgid ""
"You can also override ``'DIRS'`` and specify specific directories for a "
"particular filesystem loader::"
msgstr ""

#: ../../ref/templates/api.txt:867
#, fuzzy
msgid ""
"The ability to specify directories for a particular filesystem loader was "
"added."
msgstr ""
"Была добавлена возможность использовать ``update()`` как менеджер контекста."

# 2aba8252bf3a4176a6e476db0436377a
#: ../../ref/templates/api.txt:870
msgid "``django.template.loaders.app_directories.Loader``"
msgstr "``django.template.loaders.app_directories.Loader``"

# b8ee5b981d6b452ab14eca16e8f331c9
#: ../../ref/templates/api.txt:874
msgid ""
"Loads templates from Django apps on the filesystem. For each app in :setting:"
"`INSTALLED_APPS`, the loader looks for a ``templates`` subdirectory. If the "
"directory exists, Django looks for templates in there."
msgstr ""
"Загружает шаблоны из каталога приложения Django. Для каждого приложения в :"
"setting:`INSTALLED_APPS` загрузчик ищет под-каталог ``templates``. Если под-"
"каталог найден, Django ищет в нем шаблон."

# 48d7074334514cb0ac403327830e08eb
#: ../../ref/templates/api.txt:878
msgid ""
"This means you can store templates with your individual apps. This also "
"makes it easy to distribute Django apps with default templates."
msgstr ""
"Это означает, что вы можете хранить шаблоны вместе с приложением. Таким "
"образом легко распространять приложение Django с шаблонами по умолчанию."

# 38bd1c8504a045629583779a4c3cc2c2
#: ../../ref/templates/api.txt:881
msgid "For example, for this setting::"
msgstr "Например для следующих настроек::"

# 13b7c3f588f946c194badd32f9fe6e9e
#: ../../ref/templates/api.txt:885
msgid ""
"...then ``get_template('foo.html')`` will look for ``foo.html`` in these "
"directories, in this order:"
msgstr ""
"... ``get_template('foo.html')`` будет искать ``foo.html`` в таких каталогах "
"в указанном порядке:"

# 9a2e4b2c7fc74f2eb4e473aebe4b8370
#: ../../ref/templates/api.txt:888
msgid "``/path/to/myproject/polls/templates/``"
msgstr "``/path/to/myproject/polls/templates/``"

# 4721bf0cdd62448090a615210f2b9966
#: ../../ref/templates/api.txt:889
msgid "``/path/to/myproject/music/templates/``"
msgstr "``/path/to/myproject/music/templates/``"

# 9cd1a5e2f14c451a9faa0f58d853f60e
#: ../../ref/templates/api.txt:891
msgid "... and will use the one it finds first."
msgstr "... и будет использовать первый найденный."

# 5dffd0ec00e2469cae7d6abc2e491c13
#: ../../ref/templates/api.txt:893
msgid ""
"The order of :setting:`INSTALLED_APPS` is significant! For example, if you "
"want to customize the Django admin, you might choose to override the "
"standard ``admin/base_site.html`` template, from ``django.contrib.admin``, "
"with your own ``admin/base_site.html`` in ``myproject.polls``. You must then "
"make sure that your ``myproject.polls`` comes *before* ``django.contrib."
"admin`` in :setting:`INSTALLED_APPS`, otherwise ``django.contrib.admin``’s "
"will be loaded first and yours will be ignored."
msgstr ""
"Порядок :setting:`INSTALLED_APPS` -- важен! Например, вы хотите "
"переопределить шаблон админки Django, например ``admin/base_site.html`` из "
"``django.contrib.admin``, заменив на ``admin/base_site.html`` из ``myproject."
"polls``. Вы должны указать ``myproject.polls`` *перед* ``django.contrib."
"admin`` в :setting:`INSTALLED_APPS`, иначе шаблон из ``django.contrib."
"admin`` будет загружен первым, а ваш проигнорирован."

# 1c097e92dfc14918a7737e12a63bf559
#: ../../ref/templates/api.txt:901
msgid ""
"Note that the loader performs an optimization when it first runs: it caches "
"a list of which :setting:`INSTALLED_APPS` packages have a ``templates`` "
"subdirectory."
msgstr ""
"Обратите внимание, загрузчик выполняет некоторую оптимизацию при первом "
"импорте: он кеширует список приложений из :setting:`INSTALLED_APPS`, которые "
"содержат под-каталог ``templates``."

#: ../../ref/templates/api.txt:905
msgid ""
"You can enable this loader simply by setting :setting:`APP_DIRS <TEMPLATES-"
"APP_DIRS>` to ``True``::"
msgstr ""
"Вы можете включить этот загрузчик, указав ``True`` в :setting:`APP_DIRS "
"<TEMPLATES-APP_DIRS>`::"

# 18220eec191c479fbbbb0c1a7e385d3b
#: ../../ref/templates/api.txt:913
msgid "``django.template.loaders.eggs.Loader``"
msgstr "``django.template.loaders.eggs.Loader``"

#: ../../ref/templates/api.txt:919
msgid "Distributing applications as eggs is not recommended."
msgstr "Распространять приложения как \"egg\" не рекомендуется."

# ce2a25b669ee4bf08a984f1dd31d7ec9
#: ../../ref/templates/api.txt:921
msgid ""
"Just like ``app_directories`` above, but it loads templates from Python eggs "
"rather than from the filesystem."
msgstr ""
"Аналогичен ``app_directories``, но загружает шаблоны из Python eggs, а не "
"файловой системы."

# efc4aa376af64478925271255c365323
# 20bb1c0bcb424e0ab796724346461155
#: ../../ref/templates/api.txt:924 ../../ref/templates/api.txt:994
msgid "This loader is disabled by default."
msgstr "Загрузчик выключен по умолчанию."

# 247a952199d94495809c6ab2cbd21a14
#: ../../ref/templates/api.txt:926
msgid "``django.template.loaders.cached.Loader``"
msgstr "``django.template.loaders.cached.Loader``"

# 0537a19bb307473d8d7fefaf136432c5
#: ../../ref/templates/api.txt:930
#, fuzzy
msgid ""
"By default (when :setting:`DEBUG` is ``True``), the template system reads "
"and compiles your templates every time they're rendered. While the Django "
"template system is quite fast, the overhead from reading and compiling "
"templates can add up."
msgstr ""
"По умолчанию система шаблонов читает и компилирует ваш шаблон при каждом "
"рендеринге шаблона. Хотя система шаблонов Django работает достаточно быстро, "
"но общие накладные расходы на чтение и компилирование шаблонов могут быть "
"существенны."

# 13c13aee0e9b455eaf2f4900ba60a41a
#: ../../ref/templates/api.txt:935
#, fuzzy
msgid ""
"You configure the cached template loader with a list of other loaders that "
"it should wrap. The wrapped loaders are used to locate unknown templates "
"when they're first encountered. The cached loader then stores the compiled "
"``Template`` in memory. The cached ``Template`` instance is returned for "
"subsequent requests to load the same template."
msgstr ""
"Кеширующий загрузчик шаблонов принимает список загрузчиков Он будет "
"использовать их для поиска неизвестных шаблонов, которые загружаются первый "
"раз. Затем скомпилированные ``Template`` сохраняются в памяти. "
"Закешированный объект ``Template`` возвращается при повторном поиске уже "
"загруженного шаблона."

#: ../../ref/templates/api.txt:941
msgid ""
"This loader is automatically enabled if :setting:`DEBUG` is ``False`` and :"
"setting:`OPTIONS['loaders'] <TEMPLATES-OPTIONS>` isn't specified."
msgstr ""

# 516fe45b918b4719b19990806f80c661
#: ../../ref/templates/api.txt:944
#, fuzzy
msgid ""
"You can also enable template caching with some custom template loaders using "
"settings like this::"
msgstr ""
"Например, чтобы включить кеширование с загрузчиками ``filesystem`` и "
"``app_directories``, используйте следующие настройки::"

# 524f570e0dad476b999724a81d0afd81
#: ../../ref/templates/api.txt:963
msgid ""
"All of the built-in Django template tags are safe to use with the cached "
"loader, but if you're using custom template tags that come from third party "
"packages, or that you wrote yourself, you should ensure that the ``Node`` "
"implementation for each tag is thread-safe. For more information, see :ref:"
"`template tag thread safety considerations <template_tag_thread_safety>`."
msgstr ""
"Все встроенные теги Django можно использовать с кеширующим загрузчиком, но "
"теги сторонних приложений, или ваши собственные, должны использовать "
"потокобезопасный код при использовании класса ``Node``. Смотрите :ref:"
"`Потокобезопасные шаблонные теги<template_tag_thread_safety>`."

#: ../../ref/templates/api.txt:972
msgid ""
"The automatic enabling of the cached template loader when ``debug`` is "
"``False`` was added."
msgstr ""

# 247a952199d94495809c6ab2cbd21a14
#: ../../ref/templates/api.txt:975
msgid "``django.template.loaders.locmem.Loader``"
msgstr "``django.template.loaders.locmem.Loader``"

#: ../../ref/templates/api.txt:979
msgid "Loads templates from a Python dictionary. This is useful for testing."
msgstr "Загружает шаблоны из словаря Python. Удобен при тестировании."

#: ../../ref/templates/api.txt:981
msgid "This loader takes a dictionary of templates as its first argument::"
msgstr "Этот загрузчик принимает словарь каталогов первым аргументом::"

# eeea2eb077de42bd9852eb0866145e05
#: ../../ref/templates/api.txt:996
msgid ""
"Django uses the template loaders in order according to the ``'loaders'`` "
"option. It uses each loader until a loader finds a match."
msgstr ""
"Django использует загрузчики шаблонов в порядке, указанном в опции "
"``'loaders'``. Загрузчики используются пока один из них не найдет шаблон."

#: ../../ref/templates/api.txt:1004
msgid "Custom loaders"
msgstr "Собственные загрузчики"

#: ../../ref/templates/api.txt:1006
msgid ""
"It's possible to load templates from additional sources using custom "
"template loaders. Custom ``Loader`` classes should inherit from ``django."
"template.loaders.base.Loader`` and define the ``get_contents()`` and "
"``get_template_sources()`` methods."
msgstr ""
"Вы можете загружать шаблоны из дополнительных источников, используя "
"собственный загрузчик шаблонов. Собственный класс ``Loader`` должен "
"наследоваться от ``django.template.loaders.base.Loader`` и определять методы "
"``get_contents()`` и ``get_template_sources()``."

# f5de52746ee64836bff2111256443442
#: ../../ref/templates/api.txt:1012
msgid "Loader methods"
msgstr "Методы загрузчика шаблонов"

#: ../../ref/templates/api.txt:1016
msgid ""
"Loads templates from a given source, such as the filesystem or a database."
msgstr ""
"Загружает шаблоны из определенного источника, такого как файловая система "
"или база данных."

#: ../../ref/templates/api.txt:1020
msgid ""
"A method that takes a ``template_name`` and yields :class:`~django.template."
"base.Origin` instances for each possible source."
msgstr ""
"Метод принимает ``template_name`` и возвращает итератора по экземплярам :"
"class:`~django.template.base.Origin` для каждого возможного источника "
"шаблонов."

#: ../../ref/templates/api.txt:1024
msgid ""
"For example, the filesystem loader may receive ``'index.html'`` as a "
"``template_name`` argument.  This method would yield origins for the full "
"path of ``index.html`` as it appears in each template directory the loader "
"looks at."
msgstr ""
"Например, загрузчик с файловой системы получает ``'index.html'`` в аргументе "
"``template_name``.  Этот метод вернет итератор, который содержит полные пути "
"к ``index.html`` для каждого каталога, в котором он выполняет поиск шаблонов."

#: ../../ref/templates/api.txt:1029
msgid ""
"The method doesn't need to verify that the template exists at a given path, "
"but it should ensure the path is valid. For instance, the filesystem loader "
"makes sure the path lies under a valid template directory."
msgstr ""
"Этот метод не проверяет находится ли шаблон по указанному пути, но путь "
"должен быть правильным. Например, загрузчик с файловой системы проверяет, "
"что путь находится в каталоге с шаблонами."

#: ../../ref/templates/api.txt:1036
msgid ""
"Returns the contents for a template given a :class:`~django.template.base."
"Origin` instance."
msgstr ""
"Возвращает содержимое шаблона для переданного экземпляра :class:`~django."
"template.base.Origin`."

#: ../../ref/templates/api.txt:1039
msgid ""
"This is where a filesystem loader would read contents from the filesystem, "
"or a database loader would read from the database. If a matching template "
"doesn't exist, this should raise a :exc:`~django.template."
"TemplateDoesNotExist` error."
msgstr ""
"В этом методе загрузчик прочитает содержимое с файловой системы, или базы "
"данных. Если шаблон не найден, метод должен вызвать исключение :exc:`~django."
"template.TemplateDoesNotExist`."

#: ../../ref/templates/api.txt:1046
msgid ""
"Returns a ``Template`` object for a given ``template_name`` by looping "
"through results from :meth:`get_template_sources` and calling :meth:"
"`get_contents`. This returns the first matching template. If no template is "
"found, :exc:`~django.template.TemplateDoesNotExist` is raised."
msgstr ""
"Возвращает объект ``Template`` для переданного ``template_name``, проверяя "
"все источники из :meth:`get_template_sources` и вызывая :meth:"
"`get_contents`. Возвращает первый найденный шаблон. Если шаблон не найден, "
"будет вызвано исключение :exc:`~django.template.TemplateDoesNotExist`."

#: ../../ref/templates/api.txt:1052
msgid ""
"The optional ``skip`` argument is a list of origins to ignore when extending "
"templates. This allow templates to extend other templates of the same name. "
"It also used to avoid recursion errors."
msgstr ""
"Необязательный аргумент ``skip`` содержит список источников, которые "
"игнорируются при наследовании шаблонов. Это позволяет шаблонам наследовать "
"шаблоны с одинаковыми именами. Также позволяет избежать ошибки о рекурсии."

#: ../../ref/templates/api.txt:1056
msgid ""
"In general, it is enough to define :meth:`get_template_sources` and :meth:"
"`get_contents` for custom template loaders. ``get_template()`` will usually "
"not need to be overridden."
msgstr ""
"Обычно достаточно определить методы :meth:`get_template_sources` и :meth:"
"`get_contents`. ``get_template()`` обычно не нужно переопределять."

#: ../../ref/templates/api.txt:1062
msgid ""
"Returns a tuple of (``template_string``, ``template_origin``), where "
"``template_string`` is a string containing the template contents, and "
"``template_origin`` is a string identifying the template source. A "
"filesystem-based loader may return the full path to the file as the "
"``template_origin``, for example."
msgstr ""
"Возвращает кортеж (``template_string``, ``template_origin``), где "
"``template_string`` строка с содержимым шаблона, а ``template_origin`` "
"строка, указывающая источник шаблона. Например, загрузчик с файловой системы "
"вернет полный путь к файлу с шаблоном в ``template_origin``."

#: ../../ref/templates/api.txt:1068
msgid ""
"``template_dirs`` is an optional argument used to control which directories "
"the loader will search."
msgstr ""
"``template_dirs`` -- необязательный аргумент, который определяет каталоги "
"для поиска шаблона."

#: ../../ref/templates/api.txt:1071
msgid ""
"This method is called automatically by :meth:`load_template` and should be "
"overridden when writing custom template loaders."
msgstr ""
"Этот метод автоматически вызывается :meth:`load_template` и должен быть "
"переопределен при создании собственного загрузчика."

#: ../../ref/templates/api.txt:1076 ../../ref/templates/api.txt:1088
msgid ""
"Custom loaders should use :meth:`get_template` and :meth:`get_contents` "
"instead."
msgstr ""
"Собственные загрузчики должны использовать :meth:`get_template` и :meth:"
"`get_contents` вместо этого метода."

#: ../../ref/templates/api.txt:1081
msgid ""
"Returns a tuple of (``template``, ``template_origin``), where ``template`` "
"is a ``Template`` object and ``template_origin`` is a string identifying the "
"template source. A filesystem-based loader may return the full path to the "
"file as the ``template_origin``, for example."
msgstr ""
"Возвращает кортеж (``template``, ``template_origin``), где ``template`` это "
"объект ``Template``, а ``template_origin`` строка, указывающая источник "
"шаблона. Например, загрузчик с файловой системы вернет полный путь к файлу с "
"шаблоном в ``template_origin``."

#: ../../ref/templates/api.txt:1091
msgid "Building your own"
msgstr "Создание собственного загрузчика"

#: ../../ref/templates/api.txt:1093
msgid "For examples, `read the source code for Django's built-in loaders`_."
msgstr ""
"Примеры кода можно найти в `исходниках Django <https://github.com/django/"
"django/tree/master/django/template/loaders>`_."

# f50582e848c742668750b398e5eb6c3e
#: ../../ref/templates/api.txt:1100
msgid "Template origin"
msgstr "Расположение шаблона"

# c9cb538fd5cd44b8a46433abba7149d7
#: ../../ref/templates/api.txt:1102
msgid ""
"Templates have an ``origin`` containing attributes depending on the source "
"they are loaded from."
msgstr ""
"Шаблоны содержат атрибут ``origin``, поля которого зависят от загрузчика "
"шаблона."

# e00e01fdf4e344019090411ed5fae6d5
#: ../../ref/templates/api.txt:1109
msgid ""
"The path to the template as returned by the template loader. For loaders "
"that read from the file system, this is the full path to the template."
msgstr ""
"Путь к шаблону, который вернул загрузчик шаблонов. Для загрузчиков, которые "
"ищут в файловой системе, это будет полный путь к файлу шаблона."

#: ../../ref/templates/api.txt:1113
msgid ""
"If the template is instantiated directly rather than through a template "
"loader, this is a string value of ``<unknown_source>``."
msgstr ""
"Если шаблон создан на прямую, без загрузчика шаблонов, это поле содержит "
"``<unknown_source>``."

# a206db0de1834dbf9d65e06f2f4e0caf
#: ../../ref/templates/api.txt:1118
msgid "The relative path to the template as passed into the template loader."
msgstr "Относительный путь к шаблону, которые передается в загрузчик шаблонов."

#: ../../ref/templates/api.txt:1121
msgid ""
"If the template is instantiated directly rather than through a template "
"loader, this is ``None``."
msgstr ""
"Если шаблон создан на прямую, без загрузчика шаблонов, это поле содержит "
"``None``."

#~ msgid "The ``libraries`` and ``builtins`` arguments were added."
#~ msgstr "Были добавлены аргументы ``libraries`` и ``builtins``."

#~ msgid ""
#~ "In previous versions of Django, custom loaders defined a single method: "
#~ "``load_template_source()``."
#~ msgstr ""
#~ "В предыдущих версиях Django собственные загрузчики шаблонов определяли "
#~ "только один метод: ``load_template_source()``."

#~ msgid ""
#~ "Django used to create an origin based on ``django.template.loader."
#~ "LoaderOrigin`` or ``django.template.base.StringOrigin``. These have been "
#~ "replaced by ``django.template.base.Origin``."
#~ msgstr ""
#~ "Ранее при создании использовался ``django.template.loader.LoaderOrigin`` "
#~ "или ``django.template.base.StringOrigin``. Теперь используется ``django."
#~ "template.base.Origin``."

#~ msgid ""
#~ "``allowed_include_roots`` is a list of strings representing allowed "
#~ "prefixes for the ``{% ssi %}`` template tag. This is a security measure, "
#~ "so that template authors can't access files that they shouldn't be "
#~ "accessing."
#~ msgstr ""
#~ "``allowed_include_roots`` -- список доступных префиксов для тега ``{% ssi "
#~ "%}``. Эта настройка используется для безопасности, чтобы авторы шаблонов "
#~ "не имели доступа ко всем файлам."

#~ msgid ""
#~ "For example, if ``'allowed_include_roots'`` is ``['/home/html', '/var/"
#~ "www']``, then ``{% ssi /home/html/foo.txt %}`` would work, but ``{% ssi /"
#~ "etc/passwd %}`` wouldn't."
#~ msgstr ""
#~ "Например, если ``'allowed_include_roots'`` равна ``['/home/html', '/var/"
#~ "www']``, тогда ``{% ssi /home/html/foo.txt %}`` будет работать, а ``{% "
#~ "ssi /etc/passwd %}`` -- нет."

#~ msgid "``allowed_include_roots`` is deprecated."
#~ msgstr "Опция ``allowed_include_roots`` устарела."

#~ msgid ""
#~ "The ``current_app`` argument is deprecated. If you need it, you must now "
#~ "use a :class:`RequestContext` instead of a :class:`Context`."
#~ msgstr ""
#~ "Аргумент ``current_app`` устарел. Если он вам необходим, используйте :"
#~ "class:`RequestContext` вместо :class:`Context`."

#~ msgid ""
#~ "Built-in template context processors were moved from ``django.core."
#~ "context_processors`` to ``django.template.context_processors`` in Django "
#~ "1.8."
#~ msgstr ""
#~ "Встроенные процессоры контекста были перенесены из ``django.core."
#~ "context_processors`` в ``django.template.context_processors`` в Django "
#~ "1.8."

# 67c9890d0fc04471a9e1584fa2c50daf
#~ msgid "Context processors"
#~ msgstr "Процессоры контекста"

#~ msgid "This value used to be defined by the ``TEMPLATE_DIRS`` setting."
#~ msgstr "По умолчанию использует значение настройки ``TEMPLATE_DIRS``."

#~ msgid ""
#~ "``django.template.loaders.base.Loader`` used to be defined at ``django."
#~ "template.loader.BaseLoader``."
#~ msgstr ""
#~ "``django.template.loaders.base.Loader`` ранее находился в ``django."
#~ "template.loader.BaseLoader``."

# d06dfea5b49b4d8281abf98eab374c33
#~ msgid "The ``DEFAULT_MESSAGE_LEVELS`` variable was added."
#~ msgstr "Была добавлена переменная ``DEFAULT_MESSAGE_LEVELS``."

# 19af1eb9afab482da382654eb5dbed66
#~ msgid ""
#~ "Custom ``Loader`` classes should inherit from ``django.template.loaders."
#~ "base.Loader`` and override the ``load_template_source()`` method, which "
#~ "takes a ``template_name`` argument, loads the template from disk (or "
#~ "elsewhere), and returns a tuple: ``(template_string, template_origin)``."
#~ msgstr ""
#~ "Наш класс ``Loader`` должен наследоваться от ``django.template.loaders."
#~ "base.Loader`` и переопределять метод ``load_template_source()``, который "
#~ "принимает аргумент ``template_name``, загружает шаблон с файловой системы "
#~ "(или другого источника), и возвращает кортеж: ``(template_string, "
#~ "template_origin)``."

# 49b9f30483244915a7e7398162a8471b
#~ msgid ""
#~ "The ``load_template()`` method of the ``Loader`` class retrieves the "
#~ "template string by calling ``load_template_source()``, instantiates a "
#~ "``Template`` from the template source, and returns a tuple: ``(template, "
#~ "template_origin)``."
#~ msgstr ""
#~ "Метод ``load_template()`` класса ``Loader`` загружает содержимое шаблона, "
#~ "используя ``load_template_source()``, создает экземпляр ``Template`` с "
#~ "этим содержимым, и возвращает кортеж: ``(template, template_origin)``."

#~ msgid ""
#~ "When an :class:`~django.template.Engine` is initialized with "
#~ "``debug=True``, its templates have an ``origin`` attribute depending on "
#~ "the source they are loaded from. For engines initialized by Django, "
#~ "``debug`` defaults to the value of :setting:`DEBUG`."
#~ msgstr ""
#~ "Если :class:`~django.template.Engine` инициализирован с ``debug=True``, "
#~ "его шаблоны содержат атрибут ``origin``, который указывает откуда был "
#~ "загружен шаблон. Для шаблонизаторов, инициализированных Django, ``debug`` "
#~ "по умолчанию равен :setting:`DEBUG`."

# 3d79c7873bb94fa1a588fb55f56d7bb9
#~ msgid ""
#~ "Templates created from a template loader will use the ``django.template."
#~ "loader.LoaderOrigin`` class."
#~ msgstr ""
#~ "Шаблоны, загруженные с помощью загрузчика шаблонов, будут использовать "
#~ "класс ``django.template.loader.LoaderOrigin`` как значение этого атрибута."

# 7b5b3bc62d4a4850bc7331e3b7b5ed25
#~ msgid ""
#~ "Templates created from a ``Template`` class will use the ``django."
#~ "template.StringOrigin`` class."
#~ msgstr ""
#~ "Шаблоны созданные классом ``Template`` будут использовать класс ``django."
#~ "template.StringOrigin``."

# 95f439a87e5c4e0c9b2cc62ed5344b1e
#~ msgid "The string used to create the template."
#~ msgstr "Строка, которая использовалась для создания шаблона."

# 0f7ad3c91f0a483fac3791c90a7b8508
#~ msgid ""
#~ "If you're looking to use the Django template system as part of another "
#~ "application -- i.e., without the rest of the framework -- make sure to "
#~ "read the `configuration`_ section later in this document."
#~ msgstr ""
#~ "Если вы хотите использовать систему шаблонов Django в другом приложении "
#~ "-- т.е. без всего Django -- прочитайте раздел о :ref:`настройке "
#~ "<configuration>`."

# c5016c1597d948c8a10aabddd092ffb7
#~ msgid "Basics"
#~ msgstr "Основы"

# 6e1167d354544442bf489d0f43826259
#~ msgid ""
#~ "A **template** is a text document, or a normal Python string, that is "
#~ "marked-up using the Django template language. A template can contain "
#~ "**block tags** or **variables**."
#~ msgstr ""
#~ "**Шаблон** -- просто текстовый документ, или строка Python, которая "
#~ "использует язык разметки шаблонов Django. Шаблон может содержать "
#~ "**блочные теги** или **переменные**."

# cd3854f00e4d48d0ae0fef931d6ed185
#~ msgid "A **block tag** is a symbol within a template that does something."
#~ msgstr ""
#~ "**Блочный тег** -- просто символ в шаблоне, который что-то означает."

# bc011e8fead7414ea49eeeed695dc6f2
#~ msgid ""
#~ "This definition is deliberately vague. For example, a block tag can "
#~ "output content, serve as a control structure (an \"if\" statement or \"for"
#~ "\" loop), grab content from a database or enable access to other template "
#~ "tags."
#~ msgstr ""
#~ "Это определение такое неточное намеренно. Например, блочный тег может "
#~ "выводить текст, работать как условный оператор (\"if\" или \"for\" для "
#~ "циклов), получать данные из базы данных или загружать другие шаблонные "
#~ "теги."

# 681a759e2e91403fb9bf11718eefa6de
#~ msgid "Block tags are surrounded by ``\"{%\"`` and ``\"%}\"``."
#~ msgstr "Блочные теги выделены ``\"{%\"`` и ``\"%}\"``."

# 171996132fe348919cc95b02c8b4a9ae
#~ msgid "Example template with block tags:"
#~ msgstr "Пример шаблона с блочными тегами:"

# e00ecbce5b1f4864a40e6ac8fbdfed08
#~ msgid "A **variable** is a symbol within a template that outputs a value."
#~ msgstr ""
#~ "**Переменная** -- это символ в шаблоне, который выводит какое-то значение."

# 76199fbd4c8f4168809b0564b0980fe4
#~ msgid "Variable tags are surrounded by ``\"{{\"`` and ``\"}}\"``."
#~ msgstr "Переменные выделены ``\"{{\"`` и ``\"}}\"``."

# 00425ff901b1484c9c8ff0a725131c77
#~ msgid "Example template with variables:"
#~ msgstr "Пример шаблона с переменными:"

# c178484ab3034fbd8c70ff6f35c36fa1
#~ msgid ""
#~ "A **context** is a \"variable name\" -> \"variable value\" mapping that "
#~ "is passed to a template."
#~ msgstr ""
#~ "**Контекст** -- это структура, которая содержит соответствия \"название "
#~ "переменной\" -> \"значение переменной\" и передается в шаблон."

# 49a9b1db1f5e4b3eb959454a50ecf646
#~ msgid ""
#~ "A template **renders** a context by replacing the variable \"holes\" with "
#~ "values from the context and executing all block tags."
#~ msgstr ""
#~ "Шаблон **рендерит** контекст, заменяет переменные значениями из контекста "
#~ "и выполняет все блочные теги."

# 93e4b2cc2ec441e7afc4fac2a7d50039
#~ msgid "Using the template system"
#~ msgstr "Использование системы шаблонов"

# 91629278e2f749ba8e8273ff1b4115ca
#~ msgid ""
#~ "Then, you call the ``render()`` method of the ``Template`` object with a "
#~ "given context."
#~ msgstr ""
#~ "Затем вызываете метод ``render()`` объекта ``Template``, передав контекст."

# b178157bd37c4d57888f649cea31be62
#~ msgid "Compiling a string"
#~ msgstr "Компилирование строки"

# 2c01ea357f9948d481caebeae0d9f320
#~ msgid ""
#~ "If you're using Django's :func:`~django.shortcuts.render_to_response()` "
#~ "shortcut to populate a template with the contents of a dictionary, your "
#~ "template will be passed a ``Context`` instance by default (not a "
#~ "``RequestContext``). To use a ``RequestContext`` in your template "
#~ "rendering, pass an optional third argument to :func:`~django.shortcuts."
#~ "render_to_response()`: a ``RequestContext`` instance. Your code might "
#~ "look like this::"
#~ msgstr ""
#~ "Если вы используете встроенную в Django функцию :func:`~django.shortcuts."
#~ "render_to_response()` для рендеринга шаблона, в шаблон будет передан "
#~ "экземпляр ``Context`` (не ``RequestContext``). Чтобы использовать "
#~ "``RequestContext``, передайте третьим аргументом в :func:`~django."
#~ "shortcuts.render_to_response()` экземпляр ``RequestContext``. Например::"

# 1eb3ef40e1c64a7fb2b87fe0375c58ad
#~ msgid ""
#~ "Alternatively, use the :meth:`~django.shortcuts.render()` shortcut which "
#~ "is the same as a call to :func:`~django.shortcuts.render_to_response()` "
#~ "with a context_instance argument that forces the use of a "
#~ "``RequestContext``."
#~ msgstr ""
#~ "Еще можно использовать функцию :meth:`~django.shortcuts.render()`, "
#~ "которая работает аналогично :func:`~django.shortcuts."
#~ "render_to_response()`, но использует ``RequestContext``."

# 1ff5ce34e85d490dbe9fae802b3dc660
#~ msgid ""
#~ "Note that the contents of a supplied dictionary (``my_data_dictionary`` "
#~ "in this example) will take precedence over any variables supplied by "
#~ "context processors or the ``RequestContext``."
#~ msgstr ""
#~ "Обратите внимание, переменные из передаваемого словаря "
#~ "(``my_data_dictionary`` в нашем примере) будут иметь приоритет над "
#~ "переменными процессоров контекста или ``RequestContext``."

# e0741e1950ef4699ba6f4cac63ff138f
#~ msgid "The TEMPLATE_DIRS setting"
#~ msgstr "Настройка TEMPLATE_DIRS"

# e3a1efffc99c4aeeaa973c966f5b60c7
#~ msgid "The Python API"
#~ msgstr "Python API"

# 0215f38d94004d7ab391b4642132659c
#~ msgid ""
#~ "``django.template.loader`` has two functions to load templates from files:"
#~ msgstr ""
#~ "``django.template.loader`` содержит две функции для загрузки шаблонов с "
#~ "файла:"

# 982ca7c6f779465eb43bdd4fd9732676
#~ msgid ""
#~ "``get_template`` returns the compiled template (a ``Template`` object) "
#~ "for the template with the given name. If the template doesn't exist, it "
#~ "raises ``django.template.TemplateDoesNotExist``."
#~ msgstr ""
#~ "``get_template`` возвращает скомпилированный шаблон (объект ``Template``) "
#~ "для указанного названия шаблона. Если шаблон не найден, будет вызвано "
#~ "исключение ``django.template.TemplateDoesNotExist``."

# d32a0e9b06714446a005b8b861d34987
# 37574e2467b74e26875da184b256c198
#~ msgid ""
#~ "To override the :setting:`TEMPLATE_DIRS` setting, use the ``dirs`` "
#~ "parameter. The ``dirs`` parameter may be a tuple or list."
#~ msgstr ""
#~ "Чтобы переопределить настройку :setting:`TEMPLATE_DIRS`, используйте "
#~ "аргумент ``dirs``. Аргумент ``dirs`` может быть списком или кортежем."

# 423a741d62074cbe81e9757a0624ca70
#~ msgid ""
#~ "For example, if you call ``get_template('story_detail.html')`` and have "
#~ "the above :setting:`TEMPLATE_DIRS` setting, here are the files Django "
#~ "will look for, in order:"
#~ msgstr ""
#~ "Например, для ``get_template('story_detail.html')``, при настройке :"
#~ "setting:`TEMPLATE_DIRS` из примера выше, Django будет проверять такие "
#~ "файлы в следующем порядке:"

# 2e0ee63e3f0d4f21a2fafc6b7bbec8ad
# 1803a692346042ccb14e8d305eac6522
#~ msgid "``/home/html/templates/lawrence.com/story_detail.html``"
#~ msgstr "``/home/html/templates/lawrence.com/story_detail.html``"

# 16242f67738e44a2994ac1725d6b969d
# 2bef4fb42a9c438ca1540f3dad1b64f6
#~ msgid "``/home/html/templates/default/story_detail.html``"
#~ msgstr "``/home/html/templates/default/story_detail.html``"

# 61cffbed641149579be89541913953e7
#~ msgid ""
#~ "If you call ``select_template(['story_253_detail.html', 'story_detail."
#~ "html'])``, here's what Django will look for:"
#~ msgstr ""
#~ "Для ``select_template(['story_253_detail.html', 'story_detail.html'])``, "
#~ "Django будет искать:"

# 8568200fc8bb4647b408b1434db37912
#~ msgid "``/home/html/templates/lawrence.com/story_253_detail.html``"
#~ msgstr "``/home/html/templates/lawrence.com/story_253_detail.html``"

# 2159ec691c6a4b09a395e8267f3b36bd
#~ msgid "``/home/html/templates/default/story_253_detail.html``"
#~ msgstr "``/home/html/templates/default/story_253_detail.html``"

# 2d0f63d34b6e47fa88e74ea50017018f
#~ msgid "When Django finds a template that exists, it stops looking."
#~ msgstr "Как только Django найдет шаблон, поиск будет остановлен."

# 3d5d4dc50d404f95a2f5cb5daa03f311
#~ msgid "Tip"
#~ msgstr "Совет"

# f00cde4cb9ab4dd189d37d269c964575
#~ msgid ""
#~ "You can use ``select_template()`` for super-flexible \"templatability.\" "
#~ "For example, if you've written a news story and want some stories to have "
#~ "custom templates, use something like ``select_template(['story_%s_detail."
#~ "html' % story.id, 'story_detail.html'])``. That'll allow you to use a "
#~ "custom template for an individual story, with a fallback template for "
#~ "stories that don't have custom templates."
#~ msgstr ""
#~ "Вы можете использовать ``select_template()`` для супер-гибкой структуры "
#~ "шаблонов. Например, если у вас есть новости и вы хотите для некоторых "
#~ "использовать собственный шаблон, используйте следующий код "
#~ "``select_template(['story_%s_detail.html' % story.id, 'story_detail."
#~ "html'])``. Такой подход позволит использовать собственный шаблон для "
#~ "некоторых новостей и шаблон по умолчанию для всех остальных."

# 8011a261467e46178cd9ddab3aaeb8c7
#~ msgid "Using subdirectories"
#~ msgstr "Использование под-каталогов"

# 0591f24d108f4428930f19b7c28027e6
#~ msgid ""
#~ "It's possible -- and preferable -- to organize templates in "
#~ "subdirectories of the template directory. The convention is to make a "
#~ "subdirectory for each Django app, with subdirectories within those "
#~ "subdirectories as needed."
#~ msgstr ""
#~ "Вы можете организовать хранение шаблонов в под-каталогах в каталоге "
#~ "шаблонов и мы рекомендуем использовать такой подход. Существует "
#~ "неписанное соглашение разделять шаблоны по под-каталогам для каждого "
#~ "приложения Django."

# cddaa40c34254f36b25d4ab157828ca5
#~ msgid ""
#~ "Do this for your own sanity. Storing all templates in the root level of a "
#~ "single directory gets messy."
#~ msgstr ""
#~ "Используйте это для собственного удобства. Хранение всех шаблонов в одном "
#~ "каталоге может привести к беспорядку в коде."

# 8cbe197b72964bfd9c37e2ef0914a6d5
#~ msgid ""
#~ "To load a template that's within a subdirectory, just use a slash, like "
#~ "so::"
#~ msgstr "Чтобы загрузить шаблон из под-каталога, используйте слеш::"

# 6b704e28322e4943a4cf3bc4d38fc99b
#~ msgid ""
#~ "Using the same :setting:`TEMPLATE_DIRS` setting from above, this example "
#~ "``get_template()`` call will attempt to load the following templates:"
#~ msgstr ""
#~ "Для настройки :setting:`TEMPLATE_DIRS` из примера выше этот вызов "
#~ "``get_template()`` будет искать следующие шаблоны:"

# e1cf406e1d9e465997c40f4eafce6755
#~ msgid "``/home/html/templates/lawrence.com/news/story_detail.html``"
#~ msgstr "``/home/html/templates/lawrence.com/news/story_detail.html``"

# f49d19997fdf4c8cb1f5faec6152fdc2
#~ msgid "``/home/html/templates/default/news/story_detail.html``"
#~ msgstr "``/home/html/templates/default/news/story_detail.html``"

# 49e0044590b840ceb79bd35f885a2831
#~ msgid "This loader is enabled by default."
#~ msgstr "Загрузчик включен по умолчанию."

# 54b77857e724476c829d200888ceecbc
#~ msgid "The ``render_to_string`` shortcut"
#~ msgstr "Функция ``render_to_string``"

# c9b323809de74788a855878589b920aa
#~ msgid ""
#~ "To cut down on the repetitive nature of loading and rendering templates, "
#~ "Django provides a shortcut function which largely automates the process: "
#~ "``render_to_string()`` in :mod:`django.template.loader`, which loads a "
#~ "template, renders it and returns the resulting string::"
#~ msgstr ""
#~ "Для удобства загрузки и ренедеринга шаблон Django предоставляет функцию, "
#~ "которая упрощает это процесс: ``render_to_string()`` из :mod:`django."
#~ "template.loader`. Она загружает шаблон, рендерит его и возвращает строку::"

# 7d1ccbdb8f384a33b92c27ca41b68891
#~ msgid ""
#~ "The ``render_to_string`` shortcut takes one required argument -- "
#~ "``template_name``, which should be the name of the template to load and "
#~ "render (or a list of template names, in which case Django will use the "
#~ "first template in the list that exists) -- and two optional arguments:"
#~ msgstr ""
#~ "``render_to_string`` принимает один обязательный аргумент -- "
#~ "``template_name``, который указывает название шаблона, который необходимо "
#~ "загрузить и отрендерить (или список шаблонов, Django будет использовать "
#~ "первый найденный шаблон) -- и два необязательных:"

# 3e7ae697fec14b89bca23571eefe1a82
#~ msgid "dictionary"
#~ msgstr "dictionary"

# 0633e44d6a314835bce68844bc39a569
#~ msgid ""
#~ "A dictionary to be used as variables and values for the template's "
#~ "context. This can also be passed as the second positional argument."
#~ msgstr ""
#~ "Словарь с переменными, который будет добавлен в контекст при рендеринге. "
#~ "Можно передавать как второй позиционный аргумент."

# 7b4223f9a7814bf79d3ba0b9d1621600
#~ msgid "context_instance"
#~ msgstr "context_instance"

# 07b5417c1796444baf5205333b8da78c
#~ msgid ""
#~ "An instance of :class:`~django.template.Context` or a subclass (e.g., an "
#~ "instance of :class:`~django.template.RequestContext`) to use as the "
#~ "template's context. This can also be passed as the third positional "
#~ "argument."
#~ msgstr ""
#~ "Экземпляр :class:`~django.template.Context` или под-класса (например "
#~ "экземпляр :class:`~django.template.RequestContext`), который будет "
#~ "использоваться как контекст. Можно передавать как третий позиционный "
#~ "аргумент."

# cf8d59a123e84504b351826b4304c0f1
#~ msgid ""
#~ "See also the :func:`~django.shortcuts.render_to_response()` shortcut, "
#~ "which calls ``render_to_string`` and feeds the result into an :class:"
#~ "`~django.http.HttpResponse` suitable for returning directly from a view."
#~ msgstr ""
#~ "Смотрите также :func:`~django.shortcuts.render_to_response()`. Она "
#~ "вызывает ``render_to_string`` и передает в :class:`~django.http."
#~ "HttpResponse`, который можно вернуть из представления."

# f770006c4081468e8d776053a86e9107
#~ msgid "Configuring the template system in standalone mode"
#~ msgstr "Настройка системы шаблонов в стороннем приложении"

# 03a65f3e05234e26825dca20e92ca495
#~ msgid ""
#~ "This section is only of interest to people trying to use the template "
#~ "system as an output component in another application. If you're using the "
#~ "template system as part of a Django application, nothing here applies to "
#~ "you."
#~ msgstr ""
#~ "Этот раздел для тех, кто хочет использовать систему шаблонов в стороннем "
#~ "приложении. Если вы используете Django для создания приложений, можете "
#~ "пропустить этот раздел."

# f78697993cdb4fb6a21d15e5b00c0cb5
#~ msgid ""
#~ "Normally, Django will load all the configuration information it needs "
#~ "from its own default configuration file, combined with the settings in "
#~ "the module given in the :envvar:`DJANGO_SETTINGS_MODULE` environment "
#~ "variable. But if you're using the template system independently of the "
#~ "rest of Django, the environment variable approach isn't very convenient, "
#~ "because you probably want to configure the template system in line with "
#~ "the rest of your application rather than dealing with settings files and "
#~ "pointing to them via environment variables."
#~ msgstr ""
#~ "Обычно Django загружает настройки из внутреннего файлы настроек, который "
#~ "содержит настройки по умолчанию, затем дополняет настройками из модуля, "
#~ "который указан в переменной окружения :envvar:`DJANGO_SETTINGS_MODULE`. "
#~ "Если вы хотите использовать систему шаблонов без Django, использовать "
#~ "переменную окружения не очень удобно, т.к. скорее всего вы захотите "
#~ "настраивать систему шаблонов как и остальную часть приложения, а не "
#~ "выносить отдельно настройки и указывать их через переменную окружения."

# 881a440b420b4a84b1fcfdde8cd5c32b
#~ msgid ""
#~ "To solve this problem, you need to use the manual configuration option "
#~ "described in :ref:`settings-without-django-settings-module`. Simply "
#~ "import the appropriate pieces of the templating system and then, *before* "
#~ "you call any of the templating functions, call :func:`django.conf."
#~ "settings.configure()` with any settings you wish to specify. You might "
#~ "want to consider setting at least :setting:`TEMPLATE_DIRS` (if you're "
#~ "going to use template loaders), :setting:`DEFAULT_CHARSET` (although the "
#~ "default of ``utf-8`` is probably fine) and :setting:`TEMPLATE_DEBUG`. If "
#~ "you plan to use the :ttag:`url` template tag, you will also need to set "
#~ "the :setting:`ROOT_URLCONF` setting. All available settings are described "
#~ "in the :doc:`settings documentation </ref/settings>`, and any setting "
#~ "starting with ``TEMPLATE_`` is of obvious interest."
#~ msgstr ""
#~ "Для этого вы должны использовать явную настройку, описанную в :ref:"
#~ "`settings-without-django-settings-module`. Просто импортируйте "
#~ "необходимый модуль системы шаблонов, затем, *перед* использованием какого "
#~ "либо функционала, вызовите :func:`django.conf.settings.configure()` с "
#~ "необходимыми настройками. В первую очередь вам следует указать :setting:"
#~ "`TEMPLATE_DIRS` (если вы хотите использовать загрузчики шаблонов), :"
#~ "setting:`DEFAULT_CHARSET` (если ``utf-8`` по умолчанию вас не устраивает) "
#~ "и :setting:`TEMPLATE_DEBUG`. Если вы планируете использовать тег :ttag:"
#~ "`url`, необходимо указать :setting:`ROOT_URLCONF`. Все доступные "
#~ "настройки указаны в :doc:`разделе о настройках Django </ref/settings>`, в "
#~ "первую очередь обратите внимание на настройки, которые начинают с "
#~ "префикса ``TEMPLATE_``."

# 7a0e4a2f481d4aeb8d460c4e4b3506ba
#~ msgid "Using an alternative template language"
#~ msgstr "Использование других языков разметки шаблонов"

# b8886e9c4f554c94bda8403017890369
#~ msgid ""
#~ "The Django ``Template`` and ``Loader`` classes implement a simple API for "
#~ "loading and rendering templates. By providing some simple wrapper classes "
#~ "that implement this API we can use third party template systems like "
#~ "`Jinja2 <http://jinja.pocoo.org/docs/>`_ or `Cheetah <http://www."
#~ "cheetahtemplate.org/>`_. This allows us to use third-party template "
#~ "libraries without giving up useful Django features like the Django "
#~ "``Context`` object and handy shortcuts like :func:`~django.shortcuts."
#~ "render_to_response()`."
#~ msgstr ""
#~ "Классы ``Template`` и ``Loader`` предоставляют простой API для загрузки и "
#~ "рендеринга шаблонов. Реализовав этот API вы можете использовать сторонние "
#~ "системы шаблонов, например `Jinja2 <http://jinja.pocoo.org/docs/>`_ или "
#~ "`Cheetah <http://www.cheetahtemplate.org/>`_. Это позволяет использовать "
#~ "различные языки разметки шаблон вместе с полезным функционалом Django, "
#~ "например объекты ``Context`` и функцию :func:`~django.shortcuts."
#~ "render_to_response()`."

# c761273a76c24f8795b698c47b5ad833
#~ msgid ""
#~ "The core component of the Django templating system is the ``Template`` "
#~ "class. This class has a very simple interface: it has a constructor that "
#~ "takes a single positional argument specifying the template string, and a "
#~ "``render()`` method that takes a :class:`~django.template.Context` object "
#~ "and returns a string containing the rendered response."
#~ msgstr ""
#~ "Главный компонент системы шаблонов Django -- класс ``Template``. Этот "
#~ "класс предоставляет очень простой интерфейс: его конструктор принимает "
#~ "строку шаблона, а метод ``render()`` принимает объект :class:`~django."
#~ "template.Context`и возвращает отрендеренный шаблон."

# cf5c429e2374405885de45b6191482ae
#~ msgid ""
#~ "Suppose we're using a template language that defines a ``Template`` "
#~ "object with a ``render()`` method that takes a dictionary rather than a "
#~ "``Context`` object. We can write a simple wrapper that implements the "
#~ "Django ``Template`` interface::"
#~ msgstr ""
#~ "Предположим мы используем систему шаблонов, которая предоставляет объект "
#~ "``Template`` с методом ``render()``, который принимает словарь вместо "
#~ "объекта ``Context``. Мы может создать простой класс-обертку, который "
#~ "реализует интерфейс класса ``Template`` Django::"

# 03648e77ce7d4457918a89fe9183aaad
#~ msgid ""
#~ "That's all that's required to make our fictional ``Template`` class "
#~ "compatible with the Django loading and rendering system!"
#~ msgstr ""
#~ "Это все что необходимо, чтобы наш класс ``Template`` работал с загрузкой "
#~ "и рендерингом шаблонов Django!"

# 968ec19b83d144c783db3ac24f333baf
#~ msgid ""
#~ "Finally, we need to modify our project settings, telling Django to use "
#~ "our custom loader. Now we can write all of our templates in our "
#~ "alternative template language while continuing to use the rest of the "
#~ "Django templating system."
#~ msgstr ""
#~ "Теперь осталось поправить настройки проекта, указав Django использовать "
#~ "наш загрузчик шаблонов. Теперь мы можем использовать собственный язык "
#~ "разметки шаблонов вместе с остальным функционалом Django."
