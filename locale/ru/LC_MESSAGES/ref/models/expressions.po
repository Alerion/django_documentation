# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-13 22:13+0300\n"
"PO-Revision-Date: 2015-03-19 15:06+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../ref/models/expressions.txt:3
msgid "Query Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:7
msgid ""
"Query expressions describe a value or a computation that can be used as part "
"of an update, create, filter, order by, annotation, or aggregate. When an "
"expression outputs a boolean value, it may be used directly in filters. "
"There are a number of built-in expressions (documented below) that can be "
"used to help you write queries. Expressions can be combined, or in some "
"cases nested, to form more complex computations."
msgstr ""

#: ../../ref/models/expressions.txt:15
msgid "Supported arithmetic"
msgstr ""

#: ../../ref/models/expressions.txt:17
msgid ""
"Django supports negation, addition, subtraction, multiplication, division, "
"modulo arithmetic, and the power operator on query expressions, using Python "
"constants, variables, and even other expressions."
msgstr ""

#: ../../ref/models/expressions.txt:22
msgid "Some examples"
msgstr ""

#: ../../ref/models/expressions.txt:80
msgid "Built-in Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:84
msgid ""
"These expressions are defined in ``django.db.models.expressions`` and "
"``django.db.models.aggregates``, but for convenience they're available and "
"usually imported from :mod:`django.db.models`."
msgstr ""

#: ../../ref/models/expressions.txt:89
msgid "``F()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:93
msgid ""
"An ``F()`` object represents the value of a model field or annotated column. "
"It makes it possible to refer to model field values and perform  database "
"operations using them without actually having to pull them out of the  "
"database into Python memory."
msgstr ""

#: ../../ref/models/expressions.txt:98
msgid ""
"Instead, Django uses the ``F()`` object to generate an SQL expression that "
"describes the required operation at the database level."
msgstr ""

#: ../../ref/models/expressions.txt:101
msgid ""
"Let's try this with an example. Normally, one might do something like this::"
msgstr ""

#: ../../ref/models/expressions.txt:108
msgid ""
"Here, we have pulled the value of ``reporter.stories_filed`` from the "
"database into memory and manipulated it using familiar Python operators, and "
"then saved the object back to the database. But instead we could also have "
"done::"
msgstr ""

#: ../../ref/models/expressions.txt:118
msgid ""
"Although ``reporter.stories_filed = F('stories_filed') + 1`` looks like a "
"normal Python assignment of value to an instance attribute, in fact it's an "
"SQL construct describing an operation on the database."
msgstr ""

#: ../../ref/models/expressions.txt:122
msgid ""
"When Django encounters an instance of ``F()``, it overrides the standard "
"Python operators to create an encapsulated SQL expression; in this case, one "
"which instructs the database to increment the database field represented by "
"``reporter.stories_filed``."
msgstr ""

#: ../../ref/models/expressions.txt:127
msgid ""
"Whatever value is or was on ``reporter.stories_filed``, Python never gets to "
"know about it - it is dealt with entirely by the database. All Python does, "
"through Django's ``F()`` class, is create the SQL syntax to refer to the "
"field and describe the operation."
msgstr ""

#: ../../ref/models/expressions.txt:132
msgid "To access the new value saved this way, the object must be reloaded::"
msgstr ""

#: ../../ref/models/expressions.txt:138
msgid ""
"As well as being used in operations on single instances as above, ``F()`` "
"can be used on ``QuerySets`` of object instances, with ``update()``. This "
"reduces the two queries we were using above - the ``get()`` and the :meth:"
"`~Model.save()` - to just one::"
msgstr ""

#: ../../ref/models/expressions.txt:146
msgid ""
"We can also use :meth:`~django.db.models.query.QuerySet.update()` to "
"increment the field value on multiple objects - which could be very much "
"faster than pulling them all into Python from the database, looping over "
"them, incrementing the field value of each one, and saving each one back to "
"the database::"
msgstr ""

#: ../../ref/models/expressions.txt:153
msgid "``F()`` therefore can offer performance advantages by:"
msgstr ""

#: ../../ref/models/expressions.txt:155
msgid "getting the database, rather than Python, to do work"
msgstr ""

#: ../../ref/models/expressions.txt:156
msgid "reducing the number of queries some operations require"
msgstr ""

#: ../../ref/models/expressions.txt:161
msgid "Avoiding race conditions using ``F()``"
msgstr ""

#: ../../ref/models/expressions.txt:163
msgid ""
"Another useful benefit of ``F()`` is that having the database - rather than "
"Python - update a field's value avoids a *race condition*."
msgstr ""

#: ../../ref/models/expressions.txt:166
msgid ""
"If two Python threads execute the code in the first example above, one "
"thread could retrieve, increment, and save a field's value after the other "
"has retrieved it from the database. The value that the second thread saves "
"will be based on the original value; the work of the first thread will be "
"lost."
msgstr ""

#: ../../ref/models/expressions.txt:171
msgid ""
"If the database is responsible for updating the field, the process is more "
"robust: it will only ever update the field based on the value of the field "
"in the database when the :meth:`~Model.save()` or ``update()`` is executed, "
"rather than based on its value when the instance was retrieved."
msgstr ""

#: ../../ref/models/expressions.txt:177
msgid "``F()`` assignments persist after ``Model.save()``"
msgstr ""

#: ../../ref/models/expressions.txt:179
msgid ""
"``F()`` objects assigned to model fields persist after saving the model "
"instance and will be applied on each :meth:`~Model.save()`. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:189
msgid ""
"``stories_filed`` will be updated twice in this case. If it's initially "
"``1``, the final value will be ``3``. This persistence can be avoided by "
"reloading the model object after saving it, for example, by using :meth:"
"`~Model.refresh_from_db()`."
msgstr ""

#: ../../ref/models/expressions.txt:195
msgid "Using ``F()`` in filters"
msgstr ""

#: ../../ref/models/expressions.txt:197
msgid ""
"``F()`` is also very useful in ``QuerySet`` filters, where they make it "
"possible to filter a set of objects against criteria based on their field "
"values, rather than on Python values."
msgstr ""

#: ../../ref/models/expressions.txt:201
msgid ""
"This is documented in :ref:`using F() expressions in queries <using-f-"
"expressions-in-filters>`."
msgstr ""

#: ../../ref/models/expressions.txt:207
msgid "Using ``F()`` with annotations"
msgstr ""

#: ../../ref/models/expressions.txt:209
msgid ""
"``F()`` can be used to create dynamic fields on your models by combining "
"different fields with arithmetic::"
msgstr ""

#: ../../ref/models/expressions.txt:215
msgid ""
"If the fields that you're combining are of different types you'll need to "
"tell Django what kind of field will be returned. Since ``F()`` does not "
"directly support ``output_field`` you will need to wrap the expression with :"
"class:`ExpressionWrapper`::"
msgstr ""

#: ../../ref/models/expressions.txt:226
msgid ""
"When referencing relational fields such as ``ForeignKey``, ``F()`` returns "
"the primary key value rather than a model instance::"
msgstr ""

#: ../../ref/models/expressions.txt:238
msgid "Using ``F()`` to sort null values"
msgstr ""

#: ../../ref/models/expressions.txt:240
msgid ""
"Use ``F()`` and the ``nulls_first`` or ``nulls_last`` keyword argument to :"
"meth:`.Expression.asc` or :meth:`~.Expression.desc` to control the ordering "
"of a field's null values. By default, the ordering depends on your database."
msgstr ""

#: ../../ref/models/expressions.txt:244
msgid ""
"For example, to sort companies that haven't been contacted "
"(``last_contacted`` is null) after companies that have been contacted::"
msgstr ""

#: ../../ref/models/expressions.txt:253
msgid "``Func()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:255
msgid ""
"``Func()`` expressions are the base type of all expressions that involve "
"database functions like ``COALESCE`` and ``LOWER``, or aggregates like "
"``SUM``. They can be used directly::"
msgstr ""

#: ../../ref/models/expressions.txt:263
msgid "or they can be used to build a library of database functions::"
msgstr ""

#: ../../ref/models/expressions.txt:270
msgid ""
"But both cases will result in a queryset where each model is annotated with "
"an extra attribute ``field_lower`` produced, roughly, from the following SQL:"
msgstr ""

#: ../../ref/models/expressions.txt:279
msgid ""
"See :doc:`database-functions` for a list of built-in database functions."
msgstr ""

#: ../../ref/models/expressions.txt:281
msgid "The ``Func`` API is as follows:"
msgstr ""

#: ../../ref/models/expressions.txt:287
msgid ""
"A class attribute describing the function that will be generated. "
"Specifically, the ``function`` will be interpolated as the ``function`` "
"placeholder within :attr:`template`. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:293
msgid ""
"A class attribute, as a format string, that describes the SQL that is "
"generated for this function. Defaults to ``'%(function)s(%(expressions)s)'``."
msgstr ""

#: ../../ref/models/expressions.txt:297
msgid ""
"If you're constructing SQL like ``strftime('%W', 'date')`` and need a "
"literal ``%`` character in the query, quadruple it (``%%%%``) in the "
"``template`` attribute because the string is interpolated twice: once during "
"the template interpolation in ``as_sql()`` and once in the SQL interpolation "
"with the query parameters in the database cursor."
msgstr ""

#: ../../ref/models/expressions.txt:305
msgid ""
"A class attribute that denotes the character used to join the list of "
"``expressions`` together. Defaults to ``', '``."
msgstr ""

#: ../../ref/models/expressions.txt:310
msgid ""
"A class attribute that denotes the number of arguments the function accepts. "
"If this attribute is set and the function is called with a different number "
"of expressions, ``TypeError`` will be raised. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:317
msgid "Generates the SQL for the database function."
msgstr ""

#: ../../ref/models/expressions.txt:319
msgid ""
"The ``as_vendor()`` methods should use the ``function``, ``template``, "
"``arg_joiner``, and any other ``**extra_context`` parameters to customize "
"the SQL as needed. For example:"
msgstr ""

#: ../../ref/models/expressions.txt:323
msgid "django/db/models/functions.py"
msgstr ""

#: ../../ref/models/expressions.txt:339
msgid ""
"To avoid a SQL injection vulnerability, ``extra_context`` :ref:`must not "
"contain untrusted user input <avoiding-sql-injection-in-query-expressions>` "
"as these values are interpolated into the SQL string rather than passed as "
"query parameters, where the database driver would escape them."
msgstr ""

#: ../../ref/models/expressions.txt:344
msgid ""
"The ``*expressions`` argument is a list of positional expressions that the "
"function will be applied to. The expressions will be converted to strings, "
"joined together with ``arg_joiner``, and then interpolated into the "
"``template`` as the ``expressions`` placeholder."
msgstr ""

#: ../../ref/models/expressions.txt:349
msgid ""
"Positional arguments can be expressions or Python values. Strings are "
"assumed to be column references and will be wrapped in ``F()`` expressions "
"while other values will be wrapped in ``Value()`` expressions."
msgstr ""

#: ../../ref/models/expressions.txt:353
msgid ""
"The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated into "
"the ``template`` attribute. To avoid a SQL injection vulnerability, "
"``extra`` :ref:`must not contain untrusted user input <avoiding-sql-"
"injection-in-query-expressions>` as these values are interpolated into the "
"SQL string rather than passed as query parameters, where the database driver "
"would escape them."
msgstr ""

#: ../../ref/models/expressions.txt:360
msgid ""
"The ``function``, ``template``, and ``arg_joiner`` keywords can be used to "
"replace the attributes of the same name without having to define your own "
"class. ``output_field`` can be used to define the expected return type."
msgstr ""

#: ../../ref/models/expressions.txt:365
msgid "``Aggregate()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:367
msgid ""
"An aggregate expression is a special case of a :ref:`Func() expression <func-"
"expressions>` that informs the query that a ``GROUP BY`` clause is required. "
"All of the :ref:`aggregate functions <aggregation-functions>`, like "
"``Sum()`` and ``Count()``, inherit from ``Aggregate()``."
msgstr ""

#: ../../ref/models/expressions.txt:372
msgid ""
"Since ``Aggregate``\\s are expressions and wrap expressions, you can "
"represent some complex computations::"
msgstr ""

#: ../../ref/models/expressions.txt:380
msgid "The ``Aggregate`` API is as follows:"
msgstr ""

#: ../../ref/models/expressions.txt:386
msgid ""
"A class attribute, as a format string, that describes the SQL that is "
"generated for this aggregate. Defaults to ``'%(function)s(%(distinct)s"
"%(expressions)s)'``."
msgstr ""

#: ../../ref/models/expressions.txt:392
msgid ""
"A class attribute describing the aggregate function that will be generated. "
"Specifically, the ``function`` will be interpolated as the ``function`` "
"placeholder within :attr:`template`. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:398
msgid ""
"Defaults to ``True`` since most aggregate functions can be used as the "
"source expression in :class:`~django.db.models.expressions.Window`."
msgstr ""

#: ../../ref/models/expressions.txt:405
msgid ""
"A class attribute determining whether or not this aggregate function allows "
"passing a ``distinct`` keyword argument. If set to ``False`` (default), "
"``TypeError`` is raised if ``distinct=True`` is passed."
msgstr ""

#: ../../ref/models/expressions.txt:409
msgid ""
"The ``expressions`` positional arguments can include expressions or the "
"names of model fields. They will be converted to a string and used as the "
"``expressions`` placeholder within the ``template``."
msgstr ""

#: ../../ref/models/expressions.txt:413
msgid ""
"The ``output_field`` argument requires a model field instance, like "
"``IntegerField()`` or ``BooleanField()``, into which Django will load the "
"value after it's retrieved from the database. Usually no arguments are "
"needed when instantiating the model field as any arguments relating to data "
"validation (``max_length``, ``max_digits``, etc.) will not be enforced on "
"the expression's output value."
msgstr ""

#: ../../ref/models/expressions.txt:420
msgid ""
"Note that ``output_field`` is only required when Django is unable to "
"determine what field type the result should be. Complex expressions that mix "
"field types should define the desired ``output_field``. For example, adding "
"an ``IntegerField()`` and a ``FloatField()`` together should probably have "
"``output_field=FloatField()`` defined."
msgstr ""

#: ../../ref/models/expressions.txt:426
msgid ""
"The ``distinct`` argument determines whether or not the aggregate function "
"should be invoked for each distinct value of ``expressions`` (or set of "
"values, for multiple ``expressions``). The argument is only supported on "
"aggregates that have :attr:`~Aggregate.allow_distinct` set to ``True``."
msgstr ""

#: ../../ref/models/expressions.txt:431
msgid ""
"The ``filter`` argument takes a :class:`Q object <django.db.models.Q>` "
"that's used to filter the rows that are aggregated. See :ref:`conditional-"
"aggregation` and :ref:`filtering-on-annotations` for example usage."
msgstr ""

#: ../../ref/models/expressions.txt:435
msgid ""
"The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated into "
"the ``template`` attribute."
msgstr ""

#: ../../ref/models/expressions.txt:440
msgid "The ``allow_distinct`` attribute and ``distinct`` argument were added."
msgstr ""

#: ../../ref/models/expressions.txt:443
msgid "Creating your own Aggregate Functions"
msgstr ""

#: ../../ref/models/expressions.txt:445
msgid ""
"You can create your own aggregate functions, too. At a minimum, you need to "
"define ``function``, but you can also completely customize the SQL that is "
"generated. Here's a brief example::"
msgstr ""

#: ../../ref/models/expressions.txt:465
msgid "``Value()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:470
msgid ""
"A ``Value()`` object represents the smallest possible component of an "
"expression: a simple value. When you need to represent the value of an "
"integer, boolean, or string within an expression, you can wrap that value "
"within a ``Value()``."
msgstr ""

#: ../../ref/models/expressions.txt:475
msgid ""
"You will rarely need to use ``Value()`` directly. When you write the "
"expression ``F('field') + 1``, Django implicitly wraps the ``1`` in a "
"``Value()``, allowing simple values to be used in more complex expressions. "
"You will need to use ``Value()`` when you want to pass a string to an "
"expression. Most expressions interpret a string argument as the name of a "
"field, like ``Lower('name')``."
msgstr ""

#: ../../ref/models/expressions.txt:482
msgid ""
"The ``value`` argument describes the value to be included in the expression, "
"such as ``1``, ``True``, or ``None``. Django knows how to convert these "
"Python values into their corresponding database type."
msgstr ""

#: ../../ref/models/expressions.txt:486
msgid ""
"The ``output_field`` argument should be a model field instance, like "
"``IntegerField()`` or ``BooleanField()``, into which Django will load the "
"value after it's retrieved from the database. Usually no arguments are "
"needed when instantiating the model field as any arguments relating to data "
"validation (``max_length``, ``max_digits``, etc.) will not be enforced on "
"the expression's output value."
msgstr ""

#: ../../ref/models/expressions.txt:494
msgid "``ExpressionWrapper()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:498
msgid ""
"``ExpressionWrapper`` surrounds another expression and provides access to "
"properties, such as ``output_field``, that may not be available on other "
"expressions. ``ExpressionWrapper`` is necessary when using arithmetic on "
"``F()`` expressions with different types as described in :ref:`using-f-with-"
"annotations`."
msgstr ""

#: ../../ref/models/expressions.txt:505
msgid "Conditional expressions"
msgstr ""

#: ../../ref/models/expressions.txt:507
msgid ""
"Conditional expressions allow you to use :keyword:`if` ... :keyword:"
"`elif` ... :keyword:`else` logic in queries. Django natively supports SQL "
"``CASE`` expressions. For more details see :doc:`conditional-expressions`."
msgstr ""

#: ../../ref/models/expressions.txt:512
msgid "``Subquery()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:516
msgid ""
"You can add an explicit subquery to a ``QuerySet`` using the ``Subquery`` "
"expression."
msgstr ""

#: ../../ref/models/expressions.txt:519
msgid ""
"For example, to annotate each post with the email address of the author of "
"the newest comment on that post::"
msgstr ""

#: ../../ref/models/expressions.txt:526 ../../ref/models/expressions.txt:615
msgid "On PostgreSQL, the SQL looks like:"
msgstr ""

#: ../../ref/models/expressions.txt:539
msgid ""
"The examples in this section are designed to show how to force Django to "
"execute a subquery. In some cases it may be possible to write an equivalent "
"queryset that performs the same task more clearly or efficiently."
msgstr ""

#: ../../ref/models/expressions.txt:545
msgid "Referencing columns from the outer queryset"
msgstr ""

#: ../../ref/models/expressions.txt:549
msgid ""
"Use ``OuterRef`` when a queryset in a ``Subquery`` needs to refer to a field "
"from the outer query. It acts like an :class:`F` expression except that the "
"check to see if it refers to a valid field isn't made until the outer "
"queryset is resolved."
msgstr ""

#: ../../ref/models/expressions.txt:554
msgid ""
"Instances of ``OuterRef`` may be used in conjunction with nested instances "
"of ``Subquery`` to refer to a containing queryset that isn't the immediate "
"parent. For example, this queryset would need to be within a nested pair of "
"``Subquery`` instances to resolve correctly::"
msgstr ""

#: ../../ref/models/expressions.txt:562
msgid "Limiting a subquery to a single column"
msgstr ""

#: ../../ref/models/expressions.txt:564
msgid ""
"There are times when a single column must be returned from a ``Subquery``, "
"for instance, to use a ``Subquery`` as the target of an ``__in`` lookup. To "
"return all comments for posts published within the last day::"
msgstr ""

#: ../../ref/models/expressions.txt:574
msgid ""
"In this case, the subquery must use :meth:`~.QuerySet.values` to return only "
"a single column: the primary key of the post."
msgstr ""

#: ../../ref/models/expressions.txt:578
msgid "Limiting the subquery to a single row"
msgstr ""

#: ../../ref/models/expressions.txt:580
msgid ""
"To prevent a subquery from returning multiple rows, a slice (``[:1]``) of "
"the queryset is used::"
msgstr ""

#: ../../ref/models/expressions.txt:586
msgid ""
"In this case, the subquery must only return a single column *and* a single "
"row: the email address of the most recently created comment."
msgstr ""

#: ../../ref/models/expressions.txt:589
msgid ""
"(Using :meth:`~.QuerySet.get` instead of a slice would fail because the "
"``OuterRef`` cannot be resolved until the queryset is used within a "
"``Subquery``.)"
msgstr ""

#: ../../ref/models/expressions.txt:594
msgid "``Exists()`` subqueries"
msgstr ""

#: ../../ref/models/expressions.txt:598
msgid ""
"``Exists`` is a ``Subquery`` subclass that uses an SQL ``EXISTS`` statement. "
"In many cases it will perform better than a subquery since the database is "
"able to stop evaluation of the subquery when a first matching row is found."
msgstr ""

#: ../../ref/models/expressions.txt:602
msgid ""
"For example, to annotate each post with whether or not it has a comment from "
"within the last day::"
msgstr ""

#: ../../ref/models/expressions.txt:628
msgid ""
"It's unnecessary to force ``Exists`` to refer to a single column, since the "
"columns are discarded and a boolean result is returned. Similarly, since "
"ordering is unimportant within an SQL ``EXISTS`` subquery and would only "
"degrade performance, it's automatically removed."
msgstr ""

#: ../../ref/models/expressions.txt:633
msgid "You can query using ``NOT EXISTS`` with ``~Exists()``."
msgstr ""

#: ../../ref/models/expressions.txt:636
msgid "Filtering on a ``Subquery()`` or ``Exists()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:638
msgid ""
"``Subquery()`` that returns a boolean value and ``Exists()`` may be used as "
"a ``condition`` in :class:`~django.db.models.expressions.When` expressions, "
"or to directly filter a queryset::"
msgstr ""

#: ../../ref/models/expressions.txt:645
msgid ""
"This will ensure that the subquery will not be added to the ``SELECT`` "
"columns, which may result in a better performance."
msgstr ""

#: ../../ref/models/expressions.txt:650
msgid ""
"In previous versions of Django, it was necessary to first annotate and then "
"filter against the annotation. This resulted in the annotated value always "
"being present in the query result, and often resulted in a query that took "
"more time to execute."
msgstr ""

#: ../../ref/models/expressions.txt:656
msgid "Using aggregates within a ``Subquery`` expression"
msgstr ""

#: ../../ref/models/expressions.txt:658
msgid ""
"Aggregates may be used within a ``Subquery``, but they require a specific "
"combination of :meth:`~.QuerySet.filter`, :meth:`~.QuerySet.values`, and :"
"meth:`~.QuerySet.annotate` to get the subquery grouping correct."
msgstr ""

#: ../../ref/models/expressions.txt:662
msgid ""
"Assuming both models have a ``length`` field, to find posts where the post "
"length is greater than the total length of all combined comments::"
msgstr ""

#: ../../ref/models/expressions.txt:670
msgid ""
"The initial ``filter(...)`` limits the subquery to the relevant parameters. "
"``order_by()`` removes the default :attr:`~django.db.models.Options."
"ordering` (if any) on the ``Comment`` model. ``values('post')`` aggregates "
"comments by ``Post``. Finally, ``annotate(...)`` performs the aggregation. "
"The order in which these queryset methods are applied is important. In this "
"case, since the subquery must be limited to a single column, "
"``values('total')`` is required."
msgstr ""

#: ../../ref/models/expressions.txt:677
msgid ""
"This is the only way to perform an aggregation within a ``Subquery``, as "
"using :meth:`~.QuerySet.aggregate` attempts to evaluate the queryset (and if "
"there is an ``OuterRef``, this will not be possible to resolve)."
msgstr ""

#: ../../ref/models/expressions.txt:682
msgid "Raw SQL expressions"
msgstr ""

#: ../../ref/models/expressions.txt:688
msgid ""
"Sometimes database expressions can't easily express a complex ``WHERE`` "
"clause. In these edge cases, use the ``RawSQL`` expression. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:694
msgid ""
"These extra lookups may not be portable to different database engines "
"(because you're explicitly writing SQL code) and violate the DRY principle, "
"so you should avoid them if possible."
msgstr ""

#: ../../ref/models/expressions.txt:700
msgid ""
"To protect against `SQL injection attacks <https://en.wikipedia.org/wiki/"
"SQL_injection>`_, you must escape any parameters that the user can control "
"by using ``params``. ``params`` is a required argument to force you to "
"acknowledge that you're not interpolating your SQL with user-provided data."
msgstr ""

#: ../../ref/models/expressions.txt:706
msgid ""
"You also must not quote placeholders in the SQL string. This example is "
"vulnerable to SQL injection because of the quotes around ``%s``::"
msgstr ""

#: ../../ref/models/expressions.txt:711
msgid ""
"You can read more about how Django's :ref:`SQL injection protection <sql-"
"injection-protection>` works."
msgstr ""

#: ../../ref/models/expressions.txt:715
msgid "Window functions"
msgstr ""

#: ../../ref/models/expressions.txt:717
msgid ""
"Window functions provide a way to apply functions on partitions. Unlike a "
"normal aggregation function which computes a final result for each set "
"defined by the group by, window functions operate on :ref:`frames <window-"
"frames>` and partitions, and compute the result for each row."
msgstr ""

#: ../../ref/models/expressions.txt:722
msgid ""
"You can specify multiple windows in the same query which in Django ORM would "
"be equivalent to including multiple expressions in a :doc:`QuerySet."
"annotate() </topics/db/aggregation>` call. The ORM doesn't make use of named "
"windows, instead they are part of the selected columns."
msgstr ""

#: ../../ref/models/expressions.txt:731
msgid ""
"Defaults to ``False``. The SQL standard disallows referencing window "
"functions in the ``WHERE`` clause and Django raises an exception when "
"constructing a ``QuerySet`` that would do that."
msgstr ""

#: ../../ref/models/expressions.txt:737
msgid ""
"Defaults to ``%(expression)s OVER (%(window)s)'``. If only the "
"``expression`` argument is provided, the window clause will be blank."
msgstr ""

#: ../../ref/models/expressions.txt:740
msgid "The ``Window`` class is the main expression for an ``OVER`` clause."
msgstr ""

#: ../../ref/models/expressions.txt:742
msgid ""
"The ``expression`` argument is either a :ref:`window function <window-"
"functions>`, an :ref:`aggregate function <aggregation-functions>`, or an "
"expression that's compatible in a window clause."
msgstr ""

#: ../../ref/models/expressions.txt:746
msgid ""
"The ``partition_by`` argument is a list of expressions (column names should "
"be wrapped in an ``F``-object) that control the partitioning of the rows. "
"Partitioning narrows which rows are used to compute the result set."
msgstr ""

#: ../../ref/models/expressions.txt:750
msgid ""
"The ``output_field`` is specified either as an argument or by the expression."
msgstr ""

#: ../../ref/models/expressions.txt:752
msgid ""
"The ``order_by`` argument accepts a sequence of expressions on which you can "
"call :meth:`~django.db.models.Expression.asc` and :meth:`~django.db.models."
"Expression.desc`. The ordering controls the order in which the expression is "
"applied. For example, if you sum over the rows in a partition, the first "
"result is the value of the first row, the second is the sum of first and "
"second row."
msgstr ""

#: ../../ref/models/expressions.txt:759
msgid ""
"The ``frame`` parameter specifies which other rows that should be used in "
"the computation. See :ref:`window-frames` for details."
msgstr ""

#: ../../ref/models/expressions.txt:762
msgid ""
"For example, to annotate each movie with the average rating for the movies "
"by the same studio in the same genre and release year::"
msgstr ""

#: ../../ref/models/expressions.txt:775
msgid ""
"This allows you to check if a movie is rated better or worse than its peers."
msgstr ""

#: ../../ref/models/expressions.txt:777
msgid ""
"You may want to apply multiple expressions over the same window, i.e., the "
"same partition and frame. For example, you could modify the previous example "
"to also include the best and worst rating in each movie's group (same "
"studio, genre, and release year) by using three window functions in the same "
"query. The partition and ordering from the previous example is extracted "
"into a dictionary to reduce repetition::"
msgstr ""

#: ../../ref/models/expressions.txt:802
msgid ""
"Among Django's built-in database backends, MySQL 8.0.2+, PostgreSQL, and "
"Oracle support window expressions. Support for different window expression "
"features varies among the different databases. For example, the options in :"
"meth:`~django.db.models.Expression.asc` and :meth:`~django.db.models."
"Expression.desc` may not be supported. Consult the documentation for your "
"database as needed."
msgstr ""

#: ../../ref/models/expressions.txt:812
msgid "Frames"
msgstr ""

#: ../../ref/models/expressions.txt:814
msgid ""
"For a window frame, you can choose either a range-based sequence of rows or "
"an ordinary sequence of rows."
msgstr ""

#: ../../ref/models/expressions.txt:821
msgid "This attribute is set to ``'RANGE'``."
msgstr ""

#: ../../ref/models/expressions.txt:823
msgid ""
"PostgreSQL has limited support for ``ValueRange`` and only supports use of "
"the standard start and end points, such as ``CURRENT ROW`` and ``UNBOUNDED "
"FOLLOWING``."
msgstr ""

#: ../../ref/models/expressions.txt:831
msgid "This attribute is set to ``'ROWS'``."
msgstr ""

#: ../../ref/models/expressions.txt:833
msgid "Both classes return SQL with the template::"
msgstr ""

#: ../../ref/models/expressions.txt:837
msgid ""
"Frames narrow the rows that are used for computing the result. They shift "
"from some start point to some specified end point. Frames can be used with "
"and without partitions, but it's often a good idea to specify an ordering of "
"the window to ensure a deterministic result. In a frame, a peer in a frame "
"is a row with an equivalent value, or all rows if an ordering clause isn't "
"present."
msgstr ""

#: ../../ref/models/expressions.txt:843
msgid ""
"The default starting point for a frame is ``UNBOUNDED PRECEDING`` which is "
"the first row of the partition. The end point is always explicitly included "
"in the SQL generated by the ORM and is by default ``UNBOUNDED FOLLOWING``. "
"The default frame includes all rows from the partition to the last row in "
"the set."
msgstr ""

#: ../../ref/models/expressions.txt:848
msgid ""
"The accepted values for the ``start`` and ``end`` arguments are ``None``, an "
"integer, or zero. A negative integer for ``start`` results in ``N "
"preceding``, while ``None`` yields ``UNBOUNDED PRECEDING``. For both "
"``start`` and ``end``, zero will return ``CURRENT ROW``. Positive integers "
"are accepted for ``end``."
msgstr ""

#: ../../ref/models/expressions.txt:853
msgid ""
"There's a difference in what ``CURRENT ROW`` includes. When specified in "
"``ROWS`` mode, the frame starts or ends with the current row. When specified "
"in ``RANGE`` mode, the frame starts or ends at the first or last peer "
"according to the ordering clause. Thus, ``RANGE CURRENT ROW`` evaluates the "
"expression for rows which have the same value specified by the ordering. "
"Because the template includes both the ``start`` and ``end`` points, this "
"may be expressed with::"
msgstr ""

#: ../../ref/models/expressions.txt:862
msgid ""
"If a movie's \"peers\" are described as movies released by the same studio "
"in the same genre in the same year, this ``RowRange`` example annotates each "
"movie with the average rating of a movie's two prior and two following "
"peers::"
msgstr ""

#: ../../ref/models/expressions.txt:877
msgid ""
"If the database supports it, you can specify the start and end points based "
"on values of an expression in the partition. If the ``released`` field of "
"the ``Movie`` model stores the release month of each movies, this "
"``ValueRange`` example annotates each movie with the average rating of a "
"movie's peers released between twelve months before and twelve months after "
"the each movie."
msgstr ""

#: ../../ref/models/expressions.txt:896
msgid "Technical Information"
msgstr ""

#: ../../ref/models/expressions.txt:898
msgid ""
"Below you'll find technical implementation details that may be useful to "
"library authors. The technical API and examples below will help with "
"creating generic query expressions that can extend the built-in "
"functionality that Django provides."
msgstr ""

#: ../../ref/models/expressions.txt:904
msgid "Expression API"
msgstr ""

#: ../../ref/models/expressions.txt:906
msgid ""
"Query expressions implement the :ref:`query expression API <query-"
"expression>`, but also expose a number of extra methods and attributes "
"listed below. All query expressions must inherit from ``Expression()`` or a "
"relevant subclass."
msgstr ""

#: ../../ref/models/expressions.txt:911
msgid ""
"When a query expression wraps another expression, it is responsible for "
"calling the appropriate methods on the wrapped expression."
msgstr ""

#: ../../ref/models/expressions.txt:918
msgid ""
"Tells Django that this expression contains an aggregate and that a ``GROUP "
"BY`` clause needs to be added to the query."
msgstr ""

#: ../../ref/models/expressions.txt:923
msgid ""
"Tells Django that this expression contains a :class:`~django.db.models."
"expressions.Window` expression. It's used, for example, to disallow window "
"function expressions in queries that modify data."
msgstr ""

#: ../../ref/models/expressions.txt:930
msgid ""
"Tells Django that this expression can be referenced in :meth:`.QuerySet."
"filter`. Defaults to ``True``."
msgstr ""

#: ../../ref/models/expressions.txt:935
msgid ""
"Tells Django that this expression can be used as the source expression in :"
"class:`~django.db.models.expressions.Window`. Defaults to ``False``."
msgstr ""

#: ../../ref/models/expressions.txt:941
msgid ""
"Provides the chance to do any pre-processing or validation of the expression "
"before it's added to the query. ``resolve_expression()`` must also be called "
"on any nested expressions. A ``copy()`` of ``self`` should be returned with "
"any necessary transformations."
msgstr ""

#: ../../ref/models/expressions.txt:946
msgid "``query`` is the backend query implementation."
msgstr ""

#: ../../ref/models/expressions.txt:948
msgid ""
"``allow_joins`` is a boolean that allows or denies the use of joins in the "
"query."
msgstr ""

#: ../../ref/models/expressions.txt:951
msgid "``reuse`` is a set of reusable joins for multi-join scenarios."
msgstr ""

#: ../../ref/models/expressions.txt:953
msgid ""
"``summarize`` is a boolean that, when ``True``, signals that the query being "
"computed is a terminal aggregate query."
msgstr ""

#: ../../ref/models/expressions.txt:956
msgid ""
"``for_save`` is a boolean that, when ``True``, signals that the query being "
"executed is performing a create or update."
msgstr ""

#: ../../ref/models/expressions.txt:961
msgid "Returns an ordered list of inner expressions. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:968
msgid ""
"Takes a list of expressions and stores them such that "
"``get_source_expressions()`` can return them."
msgstr ""

#: ../../ref/models/expressions.txt:973
msgid ""
"Returns a clone (copy) of ``self``, with any column aliases relabeled. "
"Column aliases are renamed when subqueries are created. "
"``relabeled_clone()`` should also be called on any nested expressions and "
"assigned to the clone."
msgstr ""

#: ../../ref/models/expressions.txt:978
msgid "``change_map`` is a dictionary mapping old aliases to new aliases."
msgstr ""

#: ../../ref/models/expressions.txt:980
msgid "Example::"
msgstr ""

#: ../../ref/models/expressions.txt:989
msgid ""
"A hook allowing the expression to coerce ``value`` into a more appropriate "
"type."
msgstr ""

#: ../../ref/models/expressions.txt:994
msgid ""
"Responsible for returning the list of columns references by this expression. "
"``get_group_by_cols()`` should be called on any nested expressions. ``F()`` "
"objects, in particular, hold a reference to a column. The ``alias`` "
"parameter will be ``None`` unless the expression has been annotated and is "
"used for grouping."
msgstr ""

#: ../../ref/models/expressions.txt:1002
msgid "The ``alias`` parameter was added."
msgstr ""

#: ../../ref/models/expressions.txt:1006
msgid "Returns the expression ready to be sorted in ascending order."
msgstr ""

#: ../../ref/models/expressions.txt:1008 ../../ref/models/expressions.txt:1015
msgid ""
"``nulls_first`` and ``nulls_last`` define how null values are sorted. See :"
"ref:`using-f-to-sort-null-values` for example usage."
msgstr ""

#: ../../ref/models/expressions.txt:1013
msgid "Returns the expression ready to be sorted in descending order."
msgstr ""

#: ../../ref/models/expressions.txt:1020
msgid ""
"Returns ``self`` with any modifications required to reverse the sort order "
"within an ``order_by`` call. As an example, an expression implementing "
"``NULLS LAST`` would change its value to be ``NULLS FIRST``. Modifications "
"are only required for expressions that implement sort order like "
"``OrderBy``. This method is called when :meth:`~django.db.models.query."
"QuerySet.reverse()` is called on a queryset."
msgstr ""

#: ../../ref/models/expressions.txt:1029
msgid "Writing your own Query Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:1031
msgid ""
"You can write your own query expression classes that use, and can integrate "
"with, other query expressions. Let's step through an example by writing an "
"implementation of the ``COALESCE`` SQL function, without using the built-in :"
"ref:`Func() expressions <func-expressions>`."
msgstr ""

#: ../../ref/models/expressions.txt:1036
msgid ""
"The ``COALESCE`` SQL function is defined as taking a list of columns or "
"values. It will return the first column or value that isn't ``NULL``."
msgstr ""

#: ../../ref/models/expressions.txt:1039
msgid ""
"We'll start by defining the template to be used for SQL generation and an "
"``__init__()`` method to set some attributes::"
msgstr ""

#: ../../ref/models/expressions.txt:1057
msgid ""
"We do some basic validation on the parameters, including requiring at least "
"2 columns or values, and ensuring they are expressions. We are requiring "
"``output_field`` here so that Django knows what kind of model field to "
"assign the eventual result to."
msgstr ""

#: ../../ref/models/expressions.txt:1062
msgid ""
"Now we implement the pre-processing and validation. Since we do not have any "
"of our own validation at this point, we delegate to the nested expressions::"
msgstr ""

#: ../../ref/models/expressions.txt:1073
msgid "Next, we write the method responsible for generating the SQL::"
msgstr ""

#: ../../ref/models/expressions.txt:1092
msgid ""
"``as_sql()`` methods can support custom keyword arguments, allowing "
"``as_vendorname()`` methods to override data used to generate the SQL "
"string. Using ``as_sql()`` keyword arguments for customization is preferable "
"to mutating ``self`` within ``as_vendorname()`` methods as the latter can "
"lead to errors when running on different database backends. If your class "
"relies on class attributes to define data, consider allowing overrides in "
"your ``as_sql()`` method."
msgstr ""

#: ../../ref/models/expressions.txt:1100
msgid ""
"We generate the SQL for each of the ``expressions`` by using the ``compiler."
"compile()`` method, and join the result together with commas. Then the "
"template is filled out with our data and the SQL and parameters are returned."
msgstr ""

#: ../../ref/models/expressions.txt:1105
msgid ""
"We've also defined a custom implementation that is specific to the Oracle "
"backend. The ``as_oracle()`` function will be called instead of ``as_sql()`` "
"if the Oracle backend is in use."
msgstr ""

#: ../../ref/models/expressions.txt:1109
msgid ""
"Finally, we implement the rest of the methods that allow our query "
"expression to play nice with other query expressions::"
msgstr ""

#: ../../ref/models/expressions.txt:1118
msgid "Let's see how it works::"
msgstr ""

#: ../../ref/models/expressions.txt:1139
msgid "Avoiding SQL injection"
msgstr ""

#: ../../ref/models/expressions.txt:1141
msgid ""
"Since a ``Func``'s keyword arguments for ``__init__()``  (``**extra``) and "
"``as_sql()`` (``**extra_context``) are interpolated into the SQL string "
"rather than passed as query parameters (where the database driver would "
"escape them), they must not contain untrusted user input."
msgstr ""

#: ../../ref/models/expressions.txt:1146
msgid ""
"For example, if ``substring`` is user-provided, this function is vulnerable "
"to SQL injection::"
msgstr ""

#: ../../ref/models/expressions.txt:1159
msgid ""
"This function generates a SQL string without any parameters. Since "
"``substring`` is passed to ``super().__init__()`` as a keyword argument, "
"it's interpolated into the SQL string before the query is sent to the "
"database."
msgstr ""

#: ../../ref/models/expressions.txt:1163
msgid "Here's a corrected rewrite::"
msgstr ""

#: ../../ref/models/expressions.txt:1172
msgid ""
"With ``substring`` instead passed as a positional argument, it'll be passed "
"as a parameter in the database query."
msgstr ""

#: ../../ref/models/expressions.txt:1176
msgid "Adding support in third-party database backends"
msgstr ""

#: ../../ref/models/expressions.txt:1178
msgid ""
"If you're using a database backend that uses a different SQL syntax for a "
"certain function, you can add support for it by monkey patching a new method "
"onto the function's class."
msgstr ""

#: ../../ref/models/expressions.txt:1182
msgid ""
"Let's say we're writing a backend for Microsoft's SQL Server which uses the "
"SQL ``LEN`` instead of ``LENGTH`` for the :class:`~functions.Length` "
"function. We'll monkey patch a new method called ``as_sqlserver()`` onto the "
"``Length`` class::"
msgstr ""

#: ../../ref/models/expressions.txt:1194
msgid ""
"You can also customize the SQL using the ``template`` parameter of "
"``as_sql()``."
msgstr ""

#: ../../ref/models/expressions.txt:1196
msgid ""
"We use ``as_sqlserver()`` because ``django.db.connection.vendor`` returns "
"``sqlserver`` for the backend."
msgstr ""

#: ../../ref/models/expressions.txt:1199
msgid ""
"Third-party backends can register their functions in the top level "
"``__init__.py`` file of the backend package or in a top level ``expressions."
"py`` file (or package) that is imported from the top level ``__init__.py``."
msgstr ""

#: ../../ref/models/expressions.txt:1203
msgid ""
"For user projects wishing to patch the backend that they're using, this code "
"should live in an :meth:`AppConfig.ready()<django.apps.AppConfig.ready>` "
"method."
msgstr ""
