# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-12-08 11:07+0200\n"
"PO-Revision-Date: 2015-03-19 15:06+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../ref/models/expressions.txt:3
msgid "Query Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:7
msgid ""
"Query expressions describe a value or a computation that can be used as part "
"of an update, create, filter, order by, annotation, or aggregate. There are "
"a number of built-in expressions (documented below) that can be used to help "
"you write queries. Expressions can be combined, or in some cases nested, to "
"form more complex computations."
msgstr ""

#: ../../ref/models/expressions.txt:15
msgid ""
"Support for using expressions when creating new model instances was added."
msgstr ""

#: ../../ref/models/expressions.txt:18
msgid "Supported arithmetic"
msgstr ""

#: ../../ref/models/expressions.txt:20
msgid ""
"Django supports addition, subtraction, multiplication, division, modulo "
"arithmetic, and the power operator on query expressions, using Python "
"constants, variables, and even other expressions."
msgstr ""

#: ../../ref/models/expressions.txt:25
msgid "Some examples"
msgstr ""

#: ../../ref/models/expressions.txt:73
msgid "Built-in Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:77
msgid ""
"These expressions are defined in ``django.db.models.expressions`` and "
"``django.db.models.aggregates``, but for convenience they're available and "
"usually imported from :mod:`django.db.models`."
msgstr ""

#: ../../ref/models/expressions.txt:82
msgid "``F()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:86
msgid ""
"An ``F()`` object represents the value of a model field or annotated column. "
"It makes it possible to refer to model field values and perform  database "
"operations using them without actually having to pull them out of the  "
"database into Python memory."
msgstr ""

#: ../../ref/models/expressions.txt:91
msgid ""
"Instead, Django uses the ``F()`` object to generate an SQL expression that "
"describes the required operation at the database level."
msgstr ""

#: ../../ref/models/expressions.txt:94
msgid ""
"This is easiest to understand through an example. Normally, one might do "
"something like this::"
msgstr ""

#: ../../ref/models/expressions.txt:102
msgid ""
"Here, we have pulled the value of ``reporter.stories_filed`` from the "
"database into memory and manipulated it using familiar Python operators, and "
"then saved the object back to the database. But instead we could also have "
"done::"
msgstr ""

#: ../../ref/models/expressions.txt:112
msgid ""
"Although ``reporter.stories_filed = F('stories_filed') + 1`` looks like a "
"normal Python assignment of value to an instance attribute, in fact it's an "
"SQL construct describing an operation on the database."
msgstr ""

#: ../../ref/models/expressions.txt:116
msgid ""
"When Django encounters an instance of ``F()``, it overrides the standard "
"Python operators to create an encapsulated SQL expression; in this case, one "
"which instructs the database to increment the database field represented by "
"``reporter.stories_filed``."
msgstr ""

#: ../../ref/models/expressions.txt:121
msgid ""
"Whatever value is or was on ``reporter.stories_filed``, Python never gets to "
"know about it - it is dealt with entirely by the database. All Python does, "
"through Django's ``F()`` class, is create the SQL syntax to refer to the "
"field and describe the operation."
msgstr ""

#: ../../ref/models/expressions.txt:128
msgid ""
"In order to access the new value that has been saved in this way, the object "
"will need to be reloaded::"
msgstr ""

#: ../../ref/models/expressions.txt:135
msgid ""
"As well as being used in operations on single instances as above, ``F()`` "
"can be used on ``QuerySets`` of object instances, with ``update()``. This "
"reduces the two queries we were using above - the ``get()`` and the :meth:"
"`~Model.save()` - to just one::"
msgstr ""

#: ../../ref/models/expressions.txt:143
msgid ""
"We can also use :meth:`~django.db.models.query.QuerySet.update()` to "
"increment the field value on multiple objects - which could be very much "
"faster than pulling them all into Python from the database, looping over "
"them, incrementing the field value of each one, and saving each one back to "
"the database::"
msgstr ""

#: ../../ref/models/expressions.txt:150
msgid "``F()`` therefore can offer performance advantages by:"
msgstr ""

#: ../../ref/models/expressions.txt:152
msgid "getting the database, rather than Python, to do work"
msgstr ""

#: ../../ref/models/expressions.txt:153
msgid "reducing the number of queries some operations require"
msgstr ""

#: ../../ref/models/expressions.txt:158
msgid "Avoiding race conditions using ``F()``"
msgstr ""

#: ../../ref/models/expressions.txt:160
msgid ""
"Another useful benefit of ``F()`` is that having the database - rather than "
"Python - update a field's value avoids a *race condition*."
msgstr ""

#: ../../ref/models/expressions.txt:163
msgid ""
"If two Python threads execute the code in the first example above, one "
"thread could retrieve, increment, and save a field's value after the other "
"has retrieved it from the database. The value that the second thread saves "
"will be based on the original value; the work of the first thread will "
"simply be lost."
msgstr ""

#: ../../ref/models/expressions.txt:168
msgid ""
"If the database is responsible for updating the field, the process is more "
"robust: it will only ever update the field based on the value of the field "
"in the database when the :meth:`~Model.save()` or ``update()`` is executed, "
"rather than based on its value when the instance was retrieved."
msgstr ""

#: ../../ref/models/expressions.txt:174
msgid "``F()`` assignments persist after ``Model.save()``"
msgstr ""

#: ../../ref/models/expressions.txt:176
msgid ""
"``F()`` objects assigned to model fields persist after saving the model "
"instance and will be applied on each :meth:`~Model.save()`. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:186
msgid ""
"``stories_filed`` will be updated twice in this case. If it's initially "
"``1``, the final value will be ``3``."
msgstr ""

#: ../../ref/models/expressions.txt:190
msgid "Using ``F()`` in filters"
msgstr ""

#: ../../ref/models/expressions.txt:192
msgid ""
"``F()`` is also very useful in ``QuerySet`` filters, where they make it "
"possible to filter a set of objects against criteria based on their field "
"values, rather than on Python values."
msgstr ""

#: ../../ref/models/expressions.txt:196
msgid ""
"This is documented in :ref:`using F() expressions in queries <using-f-"
"expressions-in-filters>`."
msgstr ""

#: ../../ref/models/expressions.txt:202
msgid "Using ``F()`` with annotations"
msgstr ""

#: ../../ref/models/expressions.txt:204
msgid ""
"``F()`` can be used to create dynamic fields on your models by combining "
"different fields with arithmetic::"
msgstr ""

#: ../../ref/models/expressions.txt:210
msgid ""
"If the fields that you're combining are of different types you'll need to "
"tell Django what kind of field will be returned. Since ``F()`` does not "
"directly support ``output_field`` you will need to wrap the expression with :"
"class:`ExpressionWrapper`::"
msgstr ""

#: ../../ref/models/expressions.txt:224
msgid "``Func()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:226
msgid ""
"``Func()`` expressions are the base type of all expressions that involve "
"database functions like ``COALESCE`` and ``LOWER``, or aggregates like "
"``SUM``. They can be used directly::"
msgstr ""

#: ../../ref/models/expressions.txt:234
msgid "or they can be used to build a library of database functions::"
msgstr ""

#: ../../ref/models/expressions.txt:241
msgid ""
"But both cases will result in a queryset where each model is annotated with "
"an extra attribute ``field_lower`` produced, roughly, from the following "
"SQL::"
msgstr ""

#: ../../ref/models/expressions.txt:248
msgid ""
"See :doc:`database-functions` for a list of built-in database functions."
msgstr ""

#: ../../ref/models/expressions.txt:250
msgid "The ``Func`` API is as follows:"
msgstr ""

#: ../../ref/models/expressions.txt:256
msgid ""
"A class attribute describing the function that will be generated. "
"Specifically, the ``function`` will be interpolated as the ``function`` "
"placeholder within :attr:`template`. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:262
msgid ""
"A class attribute, as a format string, that describes the SQL that is "
"generated for this function. Defaults to ``'%(function)s(%(expressions)s)'``."
msgstr ""

#: ../../ref/models/expressions.txt:268
msgid ""
"A class attribute that denotes the character used to join the list of "
"``expressions`` together. Defaults to ``', '``."
msgstr ""

#: ../../ref/models/expressions.txt:275
msgid ""
"A class attribute that denotes the number of arguments the function accepts. "
"If this attribute is set and the function is called with a different number "
"of expressions, ``TypeError`` will be raised. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:282
msgid "Generates the SQL for the database function."
msgstr ""

#: ../../ref/models/expressions.txt:284
msgid ""
"The ``as_vendor()`` methods should use the ``function``, ``template``, "
"``arg_joiner``, and any other ``**extra_context`` parameters to customize "
"the SQL as needed. For example:"
msgstr ""

#: ../../ref/models/expressions.txt:305
msgid ""
"Support for the ``arg_joiner`` and ``**extra_context`` parameters was added."
msgstr ""

#: ../../ref/models/expressions.txt:308
msgid ""
"The ``*expressions`` argument is a list of positional expressions that the "
"function will be applied to. The expressions will be converted to strings, "
"joined together with ``arg_joiner``, and then interpolated into the "
"``template`` as the ``expressions`` placeholder."
msgstr ""

#: ../../ref/models/expressions.txt:313
msgid ""
"Positional arguments can be expressions or Python values. Strings are "
"assumed to be column references and will be wrapped in ``F()`` expressions "
"while other values will be wrapped in ``Value()`` expressions."
msgstr ""

#: ../../ref/models/expressions.txt:317
msgid ""
"The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated into "
"the ``template`` attribute. The ``function``, ``template``, and "
"``arg_joiner`` keywords can be used to replace the attributes of the same "
"name without having to define your own class. ``output_field`` can be used "
"to define the expected return type."
msgstr ""

#: ../../ref/models/expressions.txt:324
msgid "``Aggregate()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:326
msgid ""
"An aggregate expression is a special case of a :ref:`Func() expression <func-"
"expressions>` that informs the query that a ``GROUP BY`` clause is required. "
"All of the :ref:`aggregate functions <aggregation-functions>`, like "
"``Sum()`` and ``Count()``, inherit from ``Aggregate()``."
msgstr ""

#: ../../ref/models/expressions.txt:331
msgid ""
"Since ``Aggregate``\\s are expressions and wrap expressions, you can "
"represent some complex computations::"
msgstr ""

#: ../../ref/models/expressions.txt:339
msgid "The ``Aggregate`` API is as follows:"
msgstr ""

#: ../../ref/models/expressions.txt:345
msgid ""
"A class attribute, as a format string, that describes the SQL that is "
"generated for this aggregate. Defaults to "
"``'%(function)s( %(expressions)s )'``."
msgstr ""

#: ../../ref/models/expressions.txt:351
msgid ""
"A class attribute describing the aggregate function that will be generated. "
"Specifically, the ``function`` will be interpolated as the ``function`` "
"placeholder within :attr:`template`. Defaults to ``None``."
msgstr ""

#: ../../ref/models/expressions.txt:355
msgid ""
"The ``expression`` argument can be the name of a field on the model, or "
"another expression. It will be converted to a string and used as the "
"``expressions`` placeholder within the ``template``."
msgstr ""

#: ../../ref/models/expressions.txt:359
msgid ""
"The ``output_field`` argument requires a model field instance, like "
"``IntegerField()`` or ``BooleanField()``, into which Django will load the "
"value after it's retrieved from the database. Usually no arguments are "
"needed when instantiating the model field as any arguments relating to data "
"validation (``max_length``, ``max_digits``, etc.) will not be enforced on "
"the expression's output value."
msgstr ""

#: ../../ref/models/expressions.txt:366
msgid ""
"Note that ``output_field`` is only required when Django is unable to "
"determine what field type the result should be. Complex expressions that mix "
"field types should define the desired ``output_field``. For example, adding "
"an ``IntegerField()`` and a ``FloatField()`` together should probably have "
"``output_field=FloatField()`` defined."
msgstr ""

#: ../../ref/models/expressions.txt:372
msgid ""
"The ``**extra`` kwargs are ``key=value`` pairs that can be interpolated into "
"the ``template`` attribute."
msgstr ""

#: ../../ref/models/expressions.txt:376
msgid "Creating your own Aggregate Functions"
msgstr ""

#: ../../ref/models/expressions.txt:378
msgid ""
"Creating your own aggregate is extremely easy. At a minimum, you need to "
"define ``function``, but you can also completely customize the SQL that is "
"generated. Here's a brief example::"
msgstr ""

#: ../../ref/models/expressions.txt:399
msgid "``Value()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:404
msgid ""
"A ``Value()`` object represents the smallest possible component of an "
"expression: a simple value. When you need to represent the value of an "
"integer, boolean, or string within an expression, you can wrap that value "
"within a ``Value()``."
msgstr ""

#: ../../ref/models/expressions.txt:409
msgid ""
"You will rarely need to use ``Value()`` directly. When you write the "
"expression ``F('field') + 1``, Django implicitly wraps the ``1`` in a "
"``Value()``, allowing simple values to be used in more complex expressions. "
"You will need to use ``Value()`` when you want to pass a string to an "
"expression. Most expressions interpret a string argument as the name of a "
"field, like ``Lower('name')``."
msgstr ""

#: ../../ref/models/expressions.txt:416
msgid ""
"The ``value`` argument describes the value to be included in the expression, "
"such as ``1``, ``True``, or ``None``. Django knows how to convert these "
"Python values into their corresponding database type."
msgstr ""

#: ../../ref/models/expressions.txt:420
msgid ""
"The ``output_field`` argument should be a model field instance, like "
"``IntegerField()`` or ``BooleanField()``, into which Django will load the "
"value after it's retrieved from the database. Usually no arguments are "
"needed when instantiating the model field as any arguments relating to data "
"validation (``max_length``, ``max_digits``, etc.) will not be enforced on "
"the expression's output value."
msgstr ""

#: ../../ref/models/expressions.txt:428
msgid "``ExpressionWrapper()`` expressions"
msgstr ""

#: ../../ref/models/expressions.txt:432
msgid ""
"``ExpressionWrapper`` simply surrounds another expression and provides "
"access to properties, such as ``output_field``, that may not be available on "
"other expressions. ``ExpressionWrapper`` is necessary when using arithmetic "
"on ``F()`` expressions with different types as described in :ref:`using-f-"
"with-annotations`."
msgstr ""

#: ../../ref/models/expressions.txt:439
msgid "Conditional expressions"
msgstr ""

#: ../../ref/models/expressions.txt:441
msgid ""
"Conditional expressions allow you to use :keyword:`if` ... :keyword:"
"`elif` ... :keyword:`else` logic in queries. Django natively supports SQL "
"``CASE`` expressions. For more details see :doc:`conditional-expressions`."
msgstr ""

#: ../../ref/models/expressions.txt:446
msgid "Raw SQL expressions"
msgstr ""

#: ../../ref/models/expressions.txt:452
msgid ""
"Sometimes database expressions can't easily express a complex ``WHERE`` "
"clause. In these edge cases, use the ``RawSQL`` expression. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:458
msgid ""
"These extra lookups may not be portable to different database engines "
"(because you're explicitly writing SQL code) and violate the DRY principle, "
"so you should avoid them if possible."
msgstr ""

#: ../../ref/models/expressions.txt:464
msgid ""
"You should be very careful to escape any parameters that the user can "
"control by using ``params`` in order to protect against :ref:`SQL injection "
"attacks <sql-injection-protection>`. ``params`` is a required argument to "
"force you to acknowledge that you're not interpolating your SQL with user "
"provided data."
msgstr ""

#: ../../ref/models/expressions.txt:473
msgid "Technical Information"
msgstr ""

#: ../../ref/models/expressions.txt:475
msgid ""
"Below you'll find technical implementation details that may be useful to "
"library authors. The technical API and examples below will help with "
"creating generic query expressions that can extend the built-in "
"functionality that Django provides."
msgstr ""

#: ../../ref/models/expressions.txt:481
msgid "Expression API"
msgstr ""

#: ../../ref/models/expressions.txt:483
msgid ""
"Query expressions implement the :ref:`query expression API <query-"
"expression>`, but also expose a number of extra methods and attributes "
"listed below. All query expressions must inherit from ``Expression()`` or a "
"relevant subclass."
msgstr ""

#: ../../ref/models/expressions.txt:488
msgid ""
"When a query expression wraps another expression, it is responsible for "
"calling the appropriate methods on the wrapped expression."
msgstr ""

#: ../../ref/models/expressions.txt:495
msgid ""
"Tells Django that this expression contains an aggregate and that a ``GROUP "
"BY`` clause needs to be added to the query."
msgstr ""

#: ../../ref/models/expressions.txt:500
msgid ""
"Provides the chance to do any pre-processing or validation of the expression "
"before it's added to the query. ``resolve_expression()`` must also be called "
"on any nested expressions. A ``copy()`` of ``self`` should be returned with "
"any necessary transformations."
msgstr ""

#: ../../ref/models/expressions.txt:505
msgid "``query`` is the backend query implementation."
msgstr ""

#: ../../ref/models/expressions.txt:507
msgid ""
"``allow_joins`` is a boolean that allows or denies the use of joins in the "
"query."
msgstr ""

#: ../../ref/models/expressions.txt:510
msgid "``reuse`` is a set of reusable joins for multi-join scenarios."
msgstr ""

#: ../../ref/models/expressions.txt:512
msgid ""
"``summarize`` is a boolean that, when ``True``, signals that the query being "
"computed is a terminal aggregate query."
msgstr ""

#: ../../ref/models/expressions.txt:517
msgid "Returns an ordered list of inner expressions. For example::"
msgstr ""

#: ../../ref/models/expressions.txt:524
msgid ""
"Takes a list of expressions and stores them such that "
"``get_source_expressions()`` can return them."
msgstr ""

#: ../../ref/models/expressions.txt:529
msgid ""
"Returns a clone (copy) of ``self``, with any column aliases relabeled. "
"Column aliases are renamed when subqueries are created. "
"``relabeled_clone()`` should also be called on any nested expressions and "
"assigned to the clone."
msgstr ""

#: ../../ref/models/expressions.txt:534
msgid "``change_map`` is a dictionary mapping old aliases to new aliases."
msgstr ""

#: ../../ref/models/expressions.txt:536
msgid "Example::"
msgstr ""

#: ../../ref/models/expressions.txt:545
msgid ""
"A hook allowing the expression to coerce ``value`` into a more appropriate "
"type."
msgstr ""

#: ../../ref/models/expressions.txt:550
msgid ""
"Responsible for returning the list of columns references by this expression. "
"``get_group_by_cols()`` should be called on any nested expressions. ``F()`` "
"objects, in particular, hold a reference to a column."
msgstr ""

#: ../../ref/models/expressions.txt:557
msgid "Returns the expression ready to be sorted in ascending order."
msgstr ""

#: ../../ref/models/expressions.txt:561
msgid "Returns the expression ready to be sorted in descending order."
msgstr ""

#: ../../ref/models/expressions.txt:565
msgid ""
"Returns ``self`` with any modifications required to reverse the sort order "
"within an ``order_by`` call. As an example, an expression implementing "
"``NULLS LAST`` would change its value to be ``NULLS FIRST``. Modifications "
"are only required for expressions that implement sort order like "
"``OrderBy``. This method is called when :meth:`~django.db.models.query."
"QuerySet.reverse()` is called on a queryset."
msgstr ""

#: ../../ref/models/expressions.txt:574
msgid "Writing your own Query Expressions"
msgstr ""

#: ../../ref/models/expressions.txt:576
msgid ""
"You can write your own query expression classes that use, and can integrate "
"with, other query expressions. Let's step through an example by writing an "
"implementation of the ``COALESCE`` SQL function, without using the built-in :"
"ref:`Func() expressions <func-expressions>`."
msgstr ""

#: ../../ref/models/expressions.txt:581
msgid ""
"The ``COALESCE`` SQL function is defined as taking a list of columns or "
"values. It will return the first column or value that isn't ``NULL``."
msgstr ""

#: ../../ref/models/expressions.txt:584
msgid ""
"We'll start by defining the template to be used for SQL generation and an "
"``__init__()`` method to set some attributes::"
msgstr ""

#: ../../ref/models/expressions.txt:602
msgid ""
"We do some basic validation on the parameters, including requiring at least "
"2 columns or values, and ensuring they are expressions. We are requiring "
"``output_field`` here so that Django knows what kind of model field to "
"assign the eventual result to."
msgstr ""

#: ../../ref/models/expressions.txt:607
msgid ""
"Now we implement the pre-processing and validation. Since we do not have any "
"of our own validation at this point, we just delegate to the nested "
"expressions::"
msgstr ""

#: ../../ref/models/expressions.txt:618
msgid "Next, we write the method responsible for generating the SQL::"
msgstr ""

#: ../../ref/models/expressions.txt:637
msgid ""
"``as_sql()`` methods can support custom keyword arguments, allowing "
"``as_vendorname()`` methods to override data used to generate the SQL "
"string. Using ``as_sql()`` keyword arguments for customization is preferable "
"to mutating ``self`` within ``as_vendorname()`` methods as the latter can "
"lead to errors when running on different database backends. If your class "
"relies on class attributes to define data, consider allowing overrides in "
"your ``as_sql()`` method."
msgstr ""

#: ../../ref/models/expressions.txt:645
msgid ""
"We generate the SQL for each of the ``expressions`` by using the ``compiler."
"compile()`` method, and join the result together with commas. Then the "
"template is filled out with our data and the SQL and parameters are returned."
msgstr ""

#: ../../ref/models/expressions.txt:650
msgid ""
"We've also defined a custom implementation that is specific to the Oracle "
"backend. The ``as_oracle()`` function will be called instead of ``as_sql()`` "
"if the Oracle backend is in use."
msgstr ""

#: ../../ref/models/expressions.txt:654
msgid ""
"Finally, we implement the rest of the methods that allow our query "
"expression to play nice with other query expressions::"
msgstr ""

#: ../../ref/models/expressions.txt:663
msgid "Let's see how it works::"
msgstr ""

#: ../../ref/models/expressions.txt:682
msgid "Adding support in third-party database backends"
msgstr ""

#: ../../ref/models/expressions.txt:684
msgid ""
"If you're using a database backend that uses a different SQL syntax for a "
"certain function, you can add support for it by monkey patching a new method "
"onto the function's class."
msgstr ""

#: ../../ref/models/expressions.txt:688
msgid ""
"Let's say we're writing a backend for Microsoft's SQL Server which uses the "
"SQL ``LEN`` instead of ``LENGTH`` for the :class:`~functions.Length` "
"function. We'll monkey patch a new method called ``as_sqlserver()`` onto the "
"``Length`` class::"
msgstr ""

#: ../../ref/models/expressions.txt:700
msgid ""
"You can also customize the SQL using the ``template`` parameter of "
"``as_sql()``."
msgstr ""

#: ../../ref/models/expressions.txt:702
msgid ""
"We use ``as_sqlserver()`` because ``django.db.connection.vendor`` returns "
"``sqlserver`` for the backend."
msgstr ""

#: ../../ref/models/expressions.txt:705
msgid ""
"Third-party backends can register their functions in the top level "
"``__init__.py`` file of the backend package or in a top level ``expressions."
"py`` file (or package) that is imported from the top level ``__init__.py``."
msgstr ""

#: ../../ref/models/expressions.txt:709
msgid ""
"For user projects wishing to patch the backend that they're using, this code "
"should live in an :meth:`AppConfig.ready()<django.apps.AppConfig.ready>` "
"method."
msgstr ""
