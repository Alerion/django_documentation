# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-17 17:48+0300\n"
"PO-Revision-Date: 2016-03-21 16:29+0200\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# a4ddc79d3d4240fbaf014357723dd45c
#: ../../ref/models/querysets.txt:3
#, fuzzy
msgid "``QuerySet`` API reference"
msgstr "QuerySet API"

# 93dca2c82f0c42dc9c97bbfb3a7a319a
#: ../../ref/models/querysets.txt:7
msgid ""
"This document describes the details of the ``QuerySet`` API. It builds on "
"the material presented in the :doc:`model </topics/db/models>` and :doc:"
"`database query </topics/db/queries>` guides, so you'll probably want to "
"read and understand those documents before reading this one."
msgstr ""
"Этот раздел описывает ``QuerySet`` API. Изложенный материал опирается на "
"материал, изложенный в разделах о :doc:`моделях </topics/db/models>` и :doc:"
"`выполнении запросов </topics/db/queries>`, возможно вам следует прочитать "
"их перед прочтением этого раздела."

# f19e85b7e4874b628b1f97996cd04bd3
#: ../../ref/models/querysets.txt:12
msgid ""
"Throughout this reference we'll use the :ref:`example Weblog models "
"<queryset-model-example>` presented in the :doc:`database query guide </"
"topics/db/queries>`."
msgstr ""
"В примерах будут использованы :ref:`примеры моделей web-блога <queryset-"
"model-example>` представленные в разделе о :doc:`выполнении запросов </"
"topics/db/queries>`."

# ae28fbbf5a5c49d1ac0b40f966930aab
#: ../../ref/models/querysets.txt:19
#, fuzzy
msgid "When ``QuerySet``\\s are evaluated"
msgstr "Когда вычисляется QuerySets"

# 5dd5377703a945e4bcde2e5797e707bf
#: ../../ref/models/querysets.txt:21
msgid ""
"Internally, a ``QuerySet`` can be constructed, filtered, sliced, and "
"generally passed around without actually hitting the database. No database "
"activity actually occurs until you do something to evaluate the queryset."
msgstr ""
"``QuerySet`` может быть создан, отфильтрован, ограничен и использован "
"фактически без выполнения запросов к базе данных. База данных не будет "
"затронута, пока вы не спровоцируете выполнение QuerySet."

# ef3c207e9e724decb242d6fab6847a5c
#: ../../ref/models/querysets.txt:25
msgid "You can evaluate a ``QuerySet`` in the following ways:"
msgstr "``QuerySet`` будет вычислен при таких действиях:"

# e9bffa6ccc09496581d31d19a0e48c7c
#: ../../ref/models/querysets.txt:27
msgid ""
"**Iteration.** A ``QuerySet`` is iterable, and it executes its database "
"query the first time you iterate over it. For example, this will print the "
"headline of all entries in the database::"
msgstr ""
"**Итерация.** ``QuerySet`` -- это итератор, и при первом выполнении итерации "
"будет произведен запрос к базе данных. Например, этот код выводит заголовки "
"статей из базы данных::"

# 64e106da47db49398858e730d80ca97e
#: ../../ref/models/querysets.txt:34
msgid ""
"Note: Don't use this if all you want to do is determine if at least one "
"result exists. It's more efficient to use :meth:`~QuerySet.exists`."
msgstr ""
"Заметка: *не используйте* такой подход, если необходимо всего лишь узнать "
"содержит ли результат запроса хотя бы один объект, и вам не нужен сам "
"результат. Эффективнее использовать метод :meth:`~QuerySet.exists`."

# ea019d80409d44c082b23bd353e993ae
#: ../../ref/models/querysets.txt:37
msgid ""
"**Slicing.** As explained in :ref:`limiting-querysets`, a ``QuerySet`` can "
"be sliced, using Python's array-slicing syntax. Slicing an unevaluated "
"``QuerySet`` usually returns another unevaluated ``QuerySet``, but Django "
"will execute the database query if you use the \"step\" parameter of slice "
"syntax, and will return a list. Slicing a ``QuerySet`` that has been "
"evaluated also returns a list."
msgstr ""
"**Ограничение выборки.** Как описано в :ref:`limiting-querysets`, выборка "
"``QuerySet`` может быть ограничена, используя синтаксис срезов в Python. "
"Срез не вычисленного ``QuerySet`` обычно возвращает новый не вычисленный "
"``QuerySet``, но Django выполнит запрос, если будет указан шаг среза и "
"вернет список. Срез ``QuerySet``, который был вычислен(частично или "
"полностью), также вернет список. "

#: ../../ref/models/querysets.txt:44
msgid ""
"Also note that even though slicing an unevaluated ``QuerySet`` returns "
"another unevaluated ``QuerySet``, modifying it further (e.g., adding more "
"filters, or modifying ordering) is not allowed, since that does not "
"translate well into SQL and it would not have a clear meaning either."
msgstr ""
"Обратите внимание, хотя срез не вычисленного ``QuerySet`` вернет новый не "
"вычисленный ``QuerySet``, вы не можете изменять (например, добавлять "
"фильтры, менять сортировку) его дальше, т.к. это не транслируется в SQL и не "
"имеет определенного смысла."

# 99a34d84d70f4617ae3ff5339d628e09
#: ../../ref/models/querysets.txt:49
msgid ""
"**Pickling/Caching.** See the following section for details of what is "
"involved when `pickling QuerySets`_. The important thing for the purposes of "
"this section is that the results are read from the database."
msgstr ""
"**Pickling/кэширование.** Смотрите соответствующий раздел о `pickling "
"QuerySets`_. Основное замечание это то, что при этих операциях будет "
"выполнен запрос к базе данных."

# 872279b13af94aec98b1ca373cc0e01b
#: ../../ref/models/querysets.txt:53
msgid ""
"**repr().** A ``QuerySet`` is evaluated when you call ``repr()`` on it. This "
"is for convenience in the Python interactive interpreter, so you can "
"immediately see your results when using the API interactively."
msgstr ""
"**repr().** ``QuerySet`` будет вычислен при вызове ``repr()``. Это сделано "
"для удобства использования в консоли Python, вы можете сразу увидеть "
"результат работая с ``QuerySet`` в консоли."

# e36ca60edd4a42f8a1ae96714efea75f
#: ../../ref/models/querysets.txt:57
msgid ""
"**len().** A ``QuerySet`` is evaluated when you call ``len()`` on it. This, "
"as you might expect, returns the length of the result list."
msgstr ""
"**len().** ``QuerySet`` будет вычислен при выполнении ``len()`` над ним. Как "
"вы и ожидаете будет возвращено количество объектов в результате выборки."

# 4e7152e7b8a54da19602177972d20d79
#: ../../ref/models/querysets.txt:60
msgid ""
"Note: If you only need to determine the number of records in the set (and "
"don't need the actual objects), it's much more efficient to handle a count "
"at the database level using SQL's ``SELECT COUNT(*)``. Django provides a :"
"meth:`~QuerySet.count` method for precisely this reason."
msgstr ""
"Заметка: *Не используйте* ``len()`` с ``QuerySet`` если вам нужно узнать "
"только количество записей в выборке. Эффективнее использовать подсчет на "
"уровне базы данных, используя оператор SQL ``SELECT COUNT(*)``, и Django "
"предоставляет метод :meth:`~QuerySet.count` для этого."

# f2ee6259dad84d99beaf8af8932b6442
#: ../../ref/models/querysets.txt:65
msgid ""
"**list().** Force evaluation of a ``QuerySet`` by calling ``list()`` on it. "
"For example::"
msgstr ""
"**list().** ``QuerySet`` будет вычислен при использовании ``list()`` над "
"ним. Например::"

# 3e3a9035098f45a3a55134c68417686e
#: ../../ref/models/querysets.txt:70
msgid ""
"**bool().** Testing a ``QuerySet`` in a boolean context, such as using "
"``bool()``, ``or``, ``and`` or an ``if`` statement, will cause the query to "
"be executed. If there is at least one result, the ``QuerySet`` is ``True``, "
"otherwise ``False``. For example::"
msgstr ""
"**bool().** При вычислении булевого значения ``QuerySet``, например "
"выполнении ``bool()``,  использовании с ``or``, ``and`` или ``if``. Если "
"``QuerySet`` содержит хотя бы один элемент, результат будет ``True``, иначе "
"-- ``False``. Например::"

# 64e106da47db49398858e730d80ca97e
#: ../../ref/models/querysets.txt:78
msgid ""
"Note: If you only want to determine if at least one result exists (and don't "
"need the actual objects), it's more efficient to use :meth:`~QuerySet."
"exists`."
msgstr ""
"Заметка: *не используйте* такой подход, если необходимо всего лишь узнать "
"содержит ли результат запроса хотя бы один объект, и вам не нужен сам "
"результат. Эффективнее использовать метод :meth:`~QuerySet.exists`."

# 5b6bb2dcb2784b5cb020f75b74b30426
#: ../../ref/models/querysets.txt:84
#, fuzzy
msgid "Pickling ``QuerySet``\\s"
msgstr "Сериализация QuerySets"

# 0eed6a4a90c14a68ae30b17236be7a56
#: ../../ref/models/querysets.txt:86
msgid ""
"If you :mod:`pickle` a ``QuerySet``, this will force all the results to be "
"loaded into memory prior to pickling. Pickling is usually used as a "
"precursor to caching and when the cached queryset is reloaded, you want the "
"results to already be present and ready for use (reading from the database "
"can take some time, defeating the purpose of caching). This means that when "
"you unpickle a ``QuerySet``, it contains the results at the moment it was "
"pickled, rather than the results that are currently in the database."
msgstr ""
"Используя :mod:`pickle` для ``QuerySet``, будет выполнен запрос к базе "
"данных, чтобы загрузить данные в память для сериализации. Сериализация "
"обычно используется перед кэшированием ``QuerySet`` или загрузкой из кэша, "
"необходимо, чтобы результат был доступен для использования сразу после "
"загрузки (чтение с базы данных занимает некоторое время, что свело бы всю "
"пользу кэширования к нулю). Это означает что после восстановления "
"сериализованного ``QuerySet``, он будет содержать результат на момент "
"сериализации, а не тот, который хранится в базе данных на текущий момент."

# b306d47b2f0c4e4a89b8cc7e5977f198
#: ../../ref/models/querysets.txt:94
msgid ""
"If you only want to pickle the necessary information to recreate the "
"``QuerySet`` from the database at a later time, pickle the ``query`` "
"attribute of the ``QuerySet``. You can then recreate the original "
"``QuerySet`` (without any results loaded) using some code like this::"
msgstr ""
"Если вам необходимо сохранить запрос выполняемый ``QuerySet``, чтобы "
"получить данные позже, сериализируйте атрибут ``query`` ``QuerySet``. Позже "
"вы можете воссоздать первоначальный ``QuerySet`` (без загрузки результата) "
"используя такой код::"

# a2e2110a529c4eaab208a5965f96bd47
#: ../../ref/models/querysets.txt:104
msgid ""
"The ``query`` attribute is an opaque object. It represents the internals of "
"the query construction and is not part of the public API. However, it is "
"safe (and fully supported) to pickle and unpickle the attribute's contents "
"as described here."
msgstr ""
"Атрибут ``query`` не является частью публичного API, и является частью "
"внутреннего механизма создания запросов. Однако, поддерживает использование "
"``pickle`` и ``unpickle`` как показано в примере выше."

# f1598950c2274242bb23dd75d8e12821
#: ../../ref/models/querysets.txt:109
msgid "You can't share pickles between versions"
msgstr "нельзя переносить \"pickles\" между версиями"

# 5138d41bc219471096f24197c2187b31
#: ../../ref/models/querysets.txt:111
msgid ""
"Pickles of ``QuerySets`` are only valid for the version of Django that was "
"used to generate them. If you generate a pickle using Django version N, "
"there is no guarantee that pickle will be readable with Django version N+1. "
"Pickles should not be used as part of a long-term archival strategy."
msgstr ""
"Сериализация ``QuerySets`` возможна только для версии Django, которая была "
"использована при сохранении объекта. При сериализации объекта в версии "
"Django N, нет гарантии что, его можно будет восстановить в версии Django N"
"+1. Сериализация не должна быть использована для долговременного хранения "
"данных."

#: ../../ref/models/querysets.txt:117
msgid ""
"Since pickle compatibility errors can be difficult to diagnose, such as "
"silently corrupted objects, a ``RuntimeWarning`` is raised when you try to "
"unpickle a queryset in a Django version that is different than the one in "
"which it was pickled."
msgstr ""
"Так как ошибки совместимости \"pickle\" тяжело диагностировать, если вы "
"попытаетесь распаковать ``QuerySet`` в версии Django, которая отличается от "
"версии при упаковке объекта, будет вызвано ``RuntimeWarning``."

# 8908ae5fd52d421ca02f08f6bd313113
#: ../../ref/models/querysets.txt:125
#, fuzzy
msgid "``QuerySet`` API"
msgstr "QuerySet API"

# 62561c601ce546a8b371220d4bac8e8d
#: ../../ref/models/querysets.txt:127
msgid "Here's the formal declaration of a ``QuerySet``:"
msgstr "Вот документированное объявление ``QuerySet``:"

# 53e27b9c3de54a2fbd32c666d6c04e4d
#: ../../ref/models/querysets.txt:131
msgid ""
"Usually when you'll interact with a ``QuerySet`` you'll use it by :ref:"
"`chaining filters <chaining-filters>`. To make this work, most ``QuerySet`` "
"methods return new querysets. These methods are covered in detail later in "
"this section."
msgstr ""
"Обычно работа с ``QuerySet`` состоит в использовании :ref:`цепочек фильтров "
"<chaining-filters>`. Для этого большинство методов ``QuerySet`` возвращает "
"новый \"queryset\". Эти методы описаны далее."

# 018b3bc308034a708b2a93706cdd4981
#: ../../ref/models/querysets.txt:136
msgid ""
"The ``QuerySet`` class has two public attributes you can use for "
"introspection:"
msgstr "Класс ``QuerySet`` имеет два публичных атрибута:"

# 1158362f2a7041c090f146c7b5ce2225
#: ../../ref/models/querysets.txt:141
msgid ""
"``True`` if the ``QuerySet`` is ordered — i.e. has an :meth:`order_by()` "
"clause or a default ordering on the model. ``False`` otherwise."
msgstr ""
"``True`` если ``QuerySet`` использует сортировку — то есть использован "
"метод :meth:`order_by()` или модель содержит сортировку по-умолчанию. Иначе "
"``False``."

# d6fda43d8834411c9ce1bc9945085409
#: ../../ref/models/querysets.txt:147
msgid "The database that will be used if this query is executed now."
msgstr "База данных, которая будет использована для выполнения запроса."

# 8395b9df63654ec483d35040b7b08ab0
#: ../../ref/models/querysets.txt:151
#, fuzzy
msgid ""
"The ``query`` parameter to :class:`QuerySet` exists so that specialized "
"query subclasses can reconstruct internal query state. The value of the "
"parameter is an opaque representation of that query state and is not part of "
"a public API. To put it simply: if you need to ask, you don't need to use it."
msgstr ""
"Также присутствует атрибут ``query`` класса :class:`QuerySet`. Подклассы :"
"class:`QuerySet`, такие как :class:`~django.contrib.gis.db.models."
"GeoQuerySet` могут переопределить структуру запроса используя этот аргумент. "
"Значение атрибута является скрытым представлением состояния запроса и не "
"является частью публичного API. Проще говоря, если вам нужно рассказывать о "
"нем, значит вам не стоит его использовать."

# cc754084a78646b4aed2e7a7dac0209e
#: ../../ref/models/querysets.txt:160
#, fuzzy
msgid "Methods that return new ``QuerySet``\\s"
msgstr "Методы, которые возвращают новый QuerySets"

# 8da92a93adba4090a21bda07d305cf9e
#: ../../ref/models/querysets.txt:162
msgid ""
"Django provides a range of ``QuerySet`` refinement methods that modify "
"either the types of results returned by the ``QuerySet`` or the way its SQL "
"query is executed."
msgstr ""
"Django предоставляет набор методов ``QuerySet``, которые изменяют "
"возвращаемый результат или выполнение SQL запроса."

# 19a92a74d013406e9d778a85e53da6a8
#: ../../ref/models/querysets.txt:167
#, fuzzy
msgid "``filter()``"
msgstr "filter"

# 19caf98180104d82850aba702557d77d
#: ../../ref/models/querysets.txt:171
msgid ""
"Returns a new ``QuerySet`` containing objects that match the given lookup "
"parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты отвечающие параметрам "
"фильтрации."

# 3c339c8df1204cfb9765ef08fa9589d9
#: ../../ref/models/querysets.txt:174
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND``."

#: ../../ref/models/querysets.txt:178 ../../ref/models/querysets.txt:216
msgid ""
"If you need to execute more complex queries (for example, queries with "
"``OR`` statements), you can use :class:`Q objects <django.db.models.Q>`."
msgstr ""
"Если вам необходимо выполнить более сложные вопросы (например, запросы с "
"``OR``), вы можете использовать :class:`объект Q <django.db.models.Q>`."

# 28aa203a3e1a435c96eb81c24c2e689c
#: ../../ref/models/querysets.txt:182
#, fuzzy
msgid "``exclude()``"
msgstr "exclude"

# 5f4da46a6bdc421a8b7e893cd9da1d9b
#: ../../ref/models/querysets.txt:186
msgid ""
"Returns a new ``QuerySet`` containing objects that do *not* match the given "
"lookup parameters."
msgstr ""
"Возвращает новый ``QuerySet`` содержащий объекты *не* отвечающие параметрам "
"фильтрации."

# 6b1617a52446469eac978adbd18f4ead
#: ../../ref/models/querysets.txt:189
msgid ""
"The lookup parameters (``**kwargs``) should be in the format described in "
"`Field lookups`_ below. Multiple parameters are joined via ``AND`` in the "
"underlying SQL statement, and the whole thing is enclosed in a ``NOT()``."
msgstr ""
"Параметры фильтрации (``**kwargs``) должны отвечать формату описанному в :"
"ref:`соответствующем разделе <field-lookups>`. Несколько параметров "
"объединяются оператором SQL ``AND`` и все это замыкается оператором "
"``NOT()``."

# 4cd38f0d4a4e4ed99da118a46297684f
#: ../../ref/models/querysets.txt:193
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"AND whose ``headline`` is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date`` раньше 3.01.2005 И с "
"``headline`` равным \"Hello\"::"

# 89b7076d784e406bb11a99a9952fe728
# 0ad334998d0a41a7bb92d33376bc41eb
#: ../../ref/models/querysets.txt:198 ../../ref/models/querysets.txt:208
msgid "In SQL terms, that evaluates to::"
msgstr "Это эквивалентно запросу SQL::"

# 48b1915862b34bb89734a35d07fc6dc9
#: ../../ref/models/querysets.txt:203
msgid ""
"This example excludes all entries whose ``pub_date`` is later than 2005-1-3 "
"OR whose headline is \"Hello\"::"
msgstr ""
"Этот пример исключает все записи с ``pub_date``  раньше 3.01.2005 ИЛИ с "
"``headline`` равным \"Hello\"::"

# fef8b484158d43c09d30be0e0d5c42dd
#: ../../ref/models/querysets.txt:214
msgid "Note the second example is more restrictive."
msgstr ""
"Обратите внимание на второй пример, который больше ограничивает выборку."

# a2293c04f4024a0a9cb06fd346095b62
#: ../../ref/models/querysets.txt:220
#, fuzzy
msgid "``annotate()``"
msgstr "annotate"

#: ../../ref/models/querysets.txt:224
#, fuzzy
msgid ""
"Annotates each object in the ``QuerySet`` with the provided list of :doc:"
"`query expressions </ref/models/expressions>`. An expression may be a simple "
"value, a reference to a field on the model (or any related models), or an "
"aggregate expression (averages, sums, etc.) that has been computed over the "
"objects that are related to the objects in the ``QuerySet``."
msgstr ""
"Добавляет к каждому объекту ``QuerySet`` результаты указанных :doc:"
"`выражений </ref/models/expressions>`. Выражение может содержать простое "
"значение, указатель на другое поле модели (или связанных моделей), или "
"функции агрегации (среднее, сумма и прочие), которые вычисляются над "
"объектами, связанными с объектами из ``QuerySet``."

#: ../../ref/models/querysets.txt:230
msgid ""
"Each argument to ``annotate()`` is an annotation that will be added to each "
"object in the ``QuerySet`` that is returned."
msgstr ""
"Каждый аргумент ``annotate()`` добавит аннотацию для каждого объекта, "
"возвращаемого ``QuerySet``."

# 26a461f5b7274dc4a735bbb9fce4ba5a
# 4fe4f86b68b6440db1d38c51360ca1b7
#: ../../ref/models/querysets.txt:233
msgid ""
"The aggregation functions that are provided by Django are described in "
"`Aggregation Functions`_ below."
msgstr ""
"Функции агрегации описаны в :ref:`соответствующем разделе <aggregation-"
"functions>` ниже."

# 1294149d7e0f4999b399e546ea71cba2
#: ../../ref/models/querysets.txt:236
msgid ""
"Annotations specified using keyword arguments will use the keyword as the "
"alias for the annotation. Anonymous arguments will have an alias generated "
"for them based upon the name of the aggregate function and the model field "
"that is being aggregated. Only aggregate expressions that reference a single "
"field can be anonymous arguments. Everything else must be a keyword argument."
msgstr ""
"Аннотация, определенная именованными аргументами, будет использовать имя "
"аргумента, как название аннотации. Для позиционного аргумента будет "
"использовано имя, созданное с названия функции агрегации и используемого "
"поля модели. В позиционных аргументах можно указывать агрегирующее "
"выражение, которое использует только одно поле. Все остальные должны "
"передаваться через именованные аргументы."

# bc4c877ba3e64badbbd94b6f46f45600
#: ../../ref/models/querysets.txt:243
msgid ""
"For example, if you were manipulating a list of blogs, you may want to "
"determine how many entries have been made in each blog::"
msgstr ""
"Например, получая список блогов, вы захотите получить и количество записей в "
"каждом блоге::"

# ccaaae1b195c44628f3315859b9bb718
#: ../../ref/models/querysets.txt:255
msgid ""
"The ``Blog`` model doesn't define an ``entry__count`` attribute by itself, "
"but by using a keyword argument to specify the aggregate function, you can "
"control the name of the annotation::"
msgstr ""
"Модель ``Blog`` не определяет атрибут ``entry__count``, используя "
"именованный аргументы вы можете переопределить название этого атрибута::"

# 06fa46ba1eb442a985458a09dd622220
# ab78c4ab8814417ba4e5cfdfb7472acc
#: ../../ref/models/querysets.txt:264 ../../ref/models/querysets.txt:2275
msgid ""
"For an in-depth discussion of aggregation, see :doc:`the topic guide on "
"Aggregation </topics/db/aggregation>`."
msgstr ""
"Для углубленного изучения агрегации смотрите :doc:`раздел про агрегацию </"
"topics/db/aggregation>`."

# 1a5e940cb73b484ca39666c8fa38f4df
#: ../../ref/models/querysets.txt:268
#, fuzzy
msgid "``order_by()``"
msgstr "``order_by``"

# 4ce6382747e147e6b4c2c894014e9fdd
#: ../../ref/models/querysets.txt:272
msgid ""
"By default, results returned by a ``QuerySet`` are ordered by the ordering "
"tuple given by the ``ordering`` option in the model's ``Meta``. You can "
"override this on a per-``QuerySet`` basis by using the ``order_by`` method."
msgstr ""
"По-умолчанию, результат возвращаемый ``QuerySet``, отсортирован по полям "
"указанным в аргументе ``ordering`` класса ``Meta`` модели. Вы можете "
"переопределить сортировку используя метод ``order_by``."

# 9d69c8c34bb94cfb9f72158f427d9875
# 281b9774fa0d46529ee6c3c477956ff0
# bd3e7a153bd546bfa12e3e064720c459
# 7485308321904c3e86cc39e8910894cf
# a8749cbfd9144937b06db38a2f4ddbc1
# 4e7d2c4f218141e08e5318b264b7539d
# b66cc768e92f4b00854574e0f7a09126
# f684b5f11b1e4ce297dd1cbb0f927d5b
# 5216d8bec88c49baa9125fff2593910c
# 86cd4ddefdec4f10abdd2b4c12921b5c
# 90a5adbaedd94557b72e697a0a3902f7
# acc746828da84a32aec741c47c86164f
# 283c07c48d2b4ce4b00f12b3c1f0efd4
# eea33b1aeada471fbe719406b859dbb6
# 826d3125f3e54acebbcc86e452cdbe87
# cef75640dadb4cdab7865b789b2aed99
# 023748dbdf60440bac260fd3f787fe80
# 138ad121b8974c83997cf5ec1f4adadc
# 0382f09a65854e21892f5b81d95a1a53
# 6ae4ead3d03541bda278d48c33a12fdd
# cad7f2ad2c194100be061b225b5520ab
# 8436a2d96dbb4cf9a815ec6e24c1f0ba
# 5c2e58ba392c495cb905b93975f4f58f
# b2988e279ef34f8a8639ab324df8bc0e
# e033341134a04405a431b26b35ed31c1
#: ../../ref/models/querysets.txt:276 ../../ref/models/querysets.txt:524
#: ../../ref/models/querysets.txt:1319 ../../ref/models/querysets.txt:1384
#: ../../ref/models/querysets.txt:1442 ../../ref/models/querysets.txt:2036
#: ../../ref/models/querysets.txt:2065 ../../ref/models/querysets.txt:2223
#: ../../ref/models/querysets.txt:2515 ../../ref/models/querysets.txt:2541
#: ../../ref/models/querysets.txt:2566 ../../ref/models/querysets.txt:2586
#: ../../ref/models/querysets.txt:2645 ../../ref/models/querysets.txt:2681
#: ../../ref/models/querysets.txt:2699 ../../ref/models/querysets.txt:2719
#: ../../ref/models/querysets.txt:2740 ../../ref/models/querysets.txt:2760
#: ../../ref/models/querysets.txt:2793 ../../ref/models/querysets.txt:2812
#: ../../ref/models/querysets.txt:2835 ../../ref/models/querysets.txt:2859
#: ../../ref/models/querysets.txt:2889 ../../ref/models/querysets.txt:2911
#: ../../ref/models/querysets.txt:2959 ../../ref/models/querysets.txt:2978
#: ../../ref/models/querysets.txt:3003 ../../ref/models/querysets.txt:3028
#: ../../ref/models/querysets.txt:3053 ../../ref/models/querysets.txt:3073
#: ../../ref/models/querysets.txt:3097
msgid "Example::"
msgstr "Например::"

# 388c881a8f9746d4ae76faba940c86d3
#: ../../ref/models/querysets.txt:280
msgid ""
"The result above will be ordered by ``pub_date`` descending, then by "
"``headline`` ascending. The negative sign in front of ``\"-pub_date\"`` "
"indicates *descending* order. Ascending order is implied. To order randomly, "
"use ``\"?\"``, like so::"
msgstr ""
"Результат выше будет отсортирован в обратном порядке по полю ``pub_date``, "
"далее по полю ``headline``. Знак \"минус\" в ``\"-pub_date\"`` указывает на "
"\"нисходящую\" сортировку. Сортировка по возрастанию подразумевается по-"
"умолчанию. Чтобы отсортировать случайно используйте ``\"?\"``, например::"

# c941f625bb1945f18e21bfb4770ddf97
#: ../../ref/models/querysets.txt:287
msgid ""
"Note: ``order_by('?')`` queries may be expensive and slow, depending on the "
"database backend you're using."
msgstr ""
"Заметка: запрос с ``order_by('?')`` может быть медленным и сильно нагружать "
"базу данных, зависит от типа базы данных, которую вы используете."

# 0feb041843864550815406170d7b62c2
#: ../../ref/models/querysets.txt:290
msgid ""
"To order by a field in a different model, use the same syntax as when you "
"are querying across model relations. That is, the name of the field, "
"followed by a double underscore (``__``), followed by the name of the field "
"in the new model, and so on for as many models as you want to join. For "
"example::"
msgstr ""
"Для сортировки по полю из другой модели, используйте синтаксис аналогичный "
"тому, который используется при фильтрации по полям связанной модели. То "
"есть, название поля, далее два нижних подчеркивания (``__``), и имя поля в "
"новой модели, и так далее. Например::"

# ca5d43c386634e059a7d177dc4a37ca4
#: ../../ref/models/querysets.txt:297
msgid ""
"If you try to order by a field that is a relation to another model, Django "
"will use the default ordering on the related model, or order by the related "
"model's primary key if there is no :attr:`Meta.ordering <django.db.models."
"Options.ordering>` specified. For example, since the ``Blog`` model has no "
"default ordering specified::"
msgstr ""
"Если вы пытаетесь отсортировать по полю, которое является связью на другую "
"модель, Django будет использовать сортировку по-умолчанию связанной модели "
"(или же сортировку по первичному ключу связанной модели если :attr:`Meta."
"ordering <django.db.models.Options.ordering>` не указан). Например, так как "
"в модели ``Blog`` не указана сортировка по умолчанию::"

# 1e58dbcf06c84eeba4053165e5509788
#: ../../ref/models/querysets.txt:305
msgid "...is identical to::"
msgstr "...идентично::"

#: ../../ref/models/querysets.txt:309
msgid ""
"If ``Blog`` had ``ordering = ['name']``, then the first queryset would be "
"identical to::"
msgstr ""
"Если ``Blog`` содержит ``ordering = ['name']``, первый запрос будет "
"аналогичен::"

#: ../../ref/models/querysets.txt:314
msgid ""
"You can also order by :doc:`query expressions </ref/models/expressions>` by "
"calling ``asc()`` or ``desc()`` on the expression::"
msgstr ""
"Вы можете также сортировать по :doc:`выражению </ref/models/expressions>`, "
"вызвав ``asc()`` или ``desc()`` для выражения::"

# 0b0c59c51c0841ac9e6768b430ecd9ee
#: ../../ref/models/querysets.txt:319
msgid ""
"Be cautious when ordering by fields in related models if you are also using :"
"meth:`distinct()`. See the note in :meth:`distinct` for an explanation of "
"how related model ordering can change the expected results."
msgstr ""
"Будьте осторожны используя по полю из связанной модели и метод :meth:"
"`distinct()`. Смотрите описание метода :meth:`distinct` для информации как "
"сортировка по связанной модели может повлиять на ожидаемый результат."

# 7f1e286972b14790a8a82298dbc01f1c
#: ../../ref/models/querysets.txt:324
msgid ""
"It is permissible to specify a multi-valued field to order the results by "
"(for example, a :class:`~django.db.models.ManyToManyField` field, or the "
"reverse relation of a :class:`~django.db.models.ForeignKey` field)."
msgstr ""
"Можно использовать поля с множеством значений для фильтрации результатов "
"(например, поле :class:`~django.db.models.ManyToManyField`, или обратную "
"связь для поля :class:`~django.db.models.ForeignKey`)."

# 35465e7b81454c2e9e1e6418666353d8
#: ../../ref/models/querysets.txt:328
msgid "Consider this case::"
msgstr "Возьмем такой код::"

# 2c6e7c1632fd45b7bed7894360261b8b
#: ../../ref/models/querysets.txt:340
msgid ""
"Here, there could potentially be multiple ordering data for each ``Event``; "
"each ``Event`` with multiple ``children`` will be returned multiple times "
"into the new ``QuerySet`` that ``order_by()`` creates. In other words, using "
"``order_by()`` on the ``QuerySet`` could return more items than you were "
"working on to begin with - which is probably neither expected nor useful."
msgstr ""
"В таком случае может быть несколько значений указывающих порядок для объекта "
"``Event``. ``Event`` с несколькими ``children`` будет возвращен несколько "
"раз в ``QuerySet`` созданном ``order_by()``. Другими словами, использование "
"``order_by()`` больше объектов чем вы изначальном ``QuerySet``."

# 46269e7ffaf74797bfa27edbab392ba7
#: ../../ref/models/querysets.txt:347
msgid ""
"Thus, take care when using multi-valued field to order the results. **If** "
"you can be sure that there will only be one ordering piece of data for each "
"of the items you're ordering, this approach should not present problems. If "
"not, make sure the results are what you expect."
msgstr ""
"Будьте внимательны, когда используете поля с множеством значений для "
"сортировки. **Если** вы уверенны, что существует только одно значение для "
"объекта определяющее порядок сортировки, у вас не должно быть проблем. Иначе "
"убедитесь что полученный результат - это то, что вам нужно."

# dcef496eed3240d8b7da2df94461eddb
#: ../../ref/models/querysets.txt:352
msgid ""
"There's no way to specify whether ordering should be case sensitive. With "
"respect to case-sensitivity, Django will order results however your database "
"backend normally orders them."
msgstr ""
"Нет способа указать должна ли сортировка учитывать регистр. Поэтому Django "
"возвращает результат в таком порядке, в каком его вернула используемая база "
"данных."

#: ../../ref/models/querysets.txt:356
msgid ""
"You can order by a field converted to lowercase with :class:`~django.db."
"models.functions.Lower` which will achieve case-consistent ordering::"
msgstr ""
"Вы можете отсортировать по полю преобразовав значение в нижний регистр, "
"используя :class:`~django.db.models.functions.Lower`::"

# d072c96416f2478aa9c3ef185dc17d86
#: ../../ref/models/querysets.txt:362
msgid ""
"If you don't want any ordering to be applied to a query, not even the "
"default ordering, call :meth:`order_by()` with no parameters."
msgstr ""
"Если вы не хотите использовать сортировку, даже указанную по-умолчанию, "
"выполните метод :meth:`order_by()` без аргументов."

# 4272697bbb1f4191ac30eb51e396b2b1
#: ../../ref/models/querysets.txt:365
msgid ""
"You can tell if a query is ordered or not by checking the :attr:`.QuerySet."
"ordered` attribute, which will be ``True`` if the ``QuerySet`` has been "
"ordered in any way."
msgstr ""
"Вы можете определить используется сортировка или нет проверив атрибут :attr:"
"`.QuerySet.ordered`, который будет равен ``True``, если сортировка была "
"применена для ``QuerySet`` каким-либо образом."

#: ../../ref/models/querysets.txt:369
msgid ""
"Each ``order_by()`` call will clear any previous ordering. For example, this "
"query will be ordered by ``pub_date`` and not ``headline``::"
msgstr ""
"Каждый последующий вызов ``order_by()`` сбросит предыдущую сортировку. "
"Например, следующий запрос будет отсортирован по ``pub_date``, а не "
"``headline``::"

# ab3d940be09f46aca7d5c324fa3b7a02
#: ../../ref/models/querysets.txt:376
msgid ""
"Ordering is not a free operation. Each field you add to the ordering incurs "
"a cost to your database. Each foreign key you add will implicitly include "
"all of its default orderings as well."
msgstr ""
"Сортировка не бесплатная операция. Каждое поле влияет на скорость выполнения "
"запроса. Каждый внешний ключ добавит сортировку по умолчанию связанной "
"модели."

#: ../../ref/models/querysets.txt:380
msgid ""
"If a query doesn't have an ordering specified, results are returned from the "
"database in an unspecified order. A particular ordering is guaranteed only "
"when ordering by a set of fields that uniquely identify each object in the "
"results. For example, if a ``name`` field isn't unique, ordering by it won't "
"guarantee objects with the same name always appear in the same order."
msgstr ""

# 7d4492b3420a46a3ba839688362008f5
#: ../../ref/models/querysets.txt:387
#, fuzzy
msgid "``reverse()``"
msgstr "reverse"

# db69345ef8f94265988237ef355b596c
#: ../../ref/models/querysets.txt:391
msgid ""
"Use the ``reverse()`` method to reverse the order in which a queryset's "
"elements are returned. Calling ``reverse()`` a second time restores the "
"ordering back to the normal direction."
msgstr ""
"Используйте метод ``reverse()``, чтобы изменить порядок сортировки на "
"обратный. Вызов ``reverse()`` повторно восстановит изначальную сортировку."

# 62d776aa895846de9f16c2f531915fe5
#: ../../ref/models/querysets.txt:395
msgid "To retrieve the \"last\" five items in a queryset, you could do this::"
msgstr "Чтобы получить \"последние\" пять объектов выполните::"

# 55474eae90b641b8937651614d331aa1
#: ../../ref/models/querysets.txt:399
msgid ""
"Note that this is not quite the same as slicing from the end of a sequence "
"in Python. The above example will return the last item first, then the "
"penultimate item and so on. If we had a Python sequence and looked at "
"``seq[-5:]``, we would see the fifth-last item first. Django doesn't support "
"that mode of access (slicing from the end), because it's not possible to do "
"it efficiently in SQL."
msgstr ""
"Обратите внимание, что это не совсем аналог среза Python с конца. Этот "
"пример вернет сначала последний элемент, потом предпоследний и так далее. "
"Используя список Python и сделав срез ``seq[-5:]``, мы увидим пятый элемент "
"с конца первым. Django не поддерживает подобное (срез с конца), т.к. нет "
"способа интерпретировать это в эффективный SQL."

# 1a84791f3be9472b8ccb5dbf8582be18
#: ../../ref/models/querysets.txt:406
msgid ""
"Also, note that ``reverse()`` should generally only be called on a "
"``QuerySet`` which has a defined ordering (e.g., when querying against a "
"model which defines a default ordering, or when using :meth:`order_by()`). "
"If no such ordering is defined for a given ``QuerySet``, calling "
"``reverse()`` on it has no real effect (the ordering was undefined prior to "
"calling ``reverse()``, and will remain undefined afterward)."
msgstr ""
"Метод ``reverse()`` должен быть вызван для ``QuerySet`` с определенной "
"сортировкой (например, при запросе модели с сортировкой по-умолчанию или "
"после использования метода :meth:`order_by()`). Если сортировка не "
"определена , вызов ``reverse()`` не будет иметь никакого эффекта."

# 57e6d48e5bd743858191f3211a9d3569
#: ../../ref/models/querysets.txt:414
#, fuzzy
msgid "``distinct()``"
msgstr "distinct"

# f780c96158b04c1080f955a673f86a88
#: ../../ref/models/querysets.txt:418
msgid ""
"Returns a new ``QuerySet`` that uses ``SELECT DISTINCT`` in its SQL query. "
"This eliminates duplicate rows from the query results."
msgstr ""
"Возвращает ``QuerySet`` с добавленным ``SELECT DISTINCT`` в SQL запрос.  "
"Повторяющиеся записи будут исключены из результатов запроса."

# 72d0db17e03a42fcae1ab2c942ccd8d7
#: ../../ref/models/querysets.txt:421
msgid ""
"By default, a ``QuerySet`` will not eliminate duplicate rows. In practice, "
"this is rarely a problem, because simple queries such as ``Blog.objects."
"all()`` don't introduce the possibility of duplicate result rows. However, "
"if your query spans multiple tables, it's possible to get duplicate results "
"when a ``QuerySet`` is evaluated. That's when you'd use ``distinct()``."
msgstr ""
"По-умолчанию, ``QuerySet`` не исключает повторяющиеся записи. На практике, "
"это редко является проблемой, простые запросы вроде ``Blog.objects.all()`` "
"не создают повторяющиеся записи. Однако, если запрос использует несколько "
"таблиц, возможно что ``QuerySet`` вернет повторяющиеся записи. И здесь вам "
"пригодится ``distinct()``."

# 85c89befa0194d3a905a5addc20971b9
#: ../../ref/models/querysets.txt:428
msgid ""
"Any fields used in an :meth:`order_by` call are included in the SQL "
"``SELECT`` columns. This can sometimes lead to unexpected results when used "
"in conjunction with ``distinct()``. If you order by fields from a related "
"model, those fields will be added to the selected columns and they may make "
"otherwise duplicate rows appear to be distinct. Since the extra columns "
"don't appear in the returned results (they are only there to support "
"ordering), it sometimes looks like non-distinct results are being returned."
msgstr ""
"Любое поле используемое в :meth:`order_by` будет добавлено в список "
"выбираемых колонок в части ``SELECT`` SQL запроса. Это может привести к "
"непредвиденным результатам если вы используете ``distinct()``. При "
"сортировке по колонке из связанной таблицы, эти колонки будет включены в "
"список выбираемых колонок, что может сделать одинаковые строки результата "
"уникальными. Т.к. эти дополнительные колонки не будет включены в "
"результат(они используются только для определения сортировки), будет "
"выглядеть так, вроде бы ``distinct()`` возвращает не уникальные элементы "
"результатов."

# 27904ac42d8f4813ba4c11520f61cf48
#: ../../ref/models/querysets.txt:436
msgid ""
"Similarly, if you use a :meth:`values()` query to restrict the columns "
"selected, the columns used in any :meth:`order_by()` (or default model "
"ordering) will still be involved and may affect uniqueness of the results."
msgstr ""
"Также, если вы используете метод :meth:`values()`, чтобы ограничить "
"выбираемые поля, поля из :meth:`order_by()` (или сортировки по-умолчанию "
"модели) так же будут включены и могут повлиять на уникальность результатов."

# b6960fd26547439c90f298d3376f6055
#: ../../ref/models/querysets.txt:440
msgid ""
"The moral here is that if you are using ``distinct()`` be careful about "
"ordering by related models. Similarly, when using ``distinct()`` and :meth:"
"`values()` together, be careful when ordering by fields not in the :meth:"
"`values()` call."
msgstr ""
"Мораль всего этого -- будьте осторожны при использовании ``distinct()`` и "
"сортировки по полям из связанных моделей. Также, при использовании "
"``distinct()`` и :meth:`values()` вместе, будьте осторожны сортируя по полям "
"не включенным в :meth:`values()`."

# 34765e81d5274c3f8b717f2d80f1ffbb
#: ../../ref/models/querysets.txt:445
msgid ""
"On PostgreSQL only, you can pass positional arguments (``*fields``) in order "
"to specify the names of fields to which the ``DISTINCT`` should apply. This "
"translates to a ``SELECT DISTINCT ON`` SQL query. Here's the difference. For "
"a normal ``distinct()`` call, the database compares *each* field in each row "
"when determining which rows are distinct. For a ``distinct()`` call with "
"specified field names, the database will only compare the specified field "
"names."
msgstr ""
"Только для PostgreSQL можно указать позиционный аргумент (``*fields``) "
"определяющий для каких полей применять ``DISTINCT``. Они будут добавлены в "
"``SELECT DISTINCT ON`` часть SQL запроса. Вот в чем разница. При обычном "
"вызове ``distinct()``, база данных сравнивает *каждое* поле каждой строки "
"для определения уникальности записи. При передаче полей в ``distinct()``, "
"база данных будет сравнивать только указанные поля."

# 9eb9408232844162b66ce5cef3025bc0
#: ../../ref/models/querysets.txt:453
msgid ""
"When you specify field names, you *must* provide an ``order_by()`` in the "
"``QuerySet``, and the fields in ``order_by()`` must start with the fields in "
"``distinct()``, in the same order."
msgstr ""
"Если вы указываете поля, вы *должны* определить и ``order_by()`` для "
"``QuerySet``, и поля в ``order_by()`` должны начинаться с полей указанных в "
"``distinct()``, в том же порядке."

# 468448fbce544d7c9d8fbea48c3d1025
#: ../../ref/models/querysets.txt:457
msgid ""
"For example, ``SELECT DISTINCT ON (a)`` gives you the first row for each "
"value in column ``a``. If you don't specify an order, you'll get some "
"arbitrary row."
msgstr ""
"Например, ``SELECT DISTINCT ON (a)`` возвращает вам первую запись для "
"каждого уникального значения колонки ``a``. Если вы не определите "
"сортировку, будут возвращены случайные записи для каждого уникального "
"значения."

# fde9c3fdeaee4e41ae6134df439fbd1a
#: ../../ref/models/querysets.txt:461
msgid "Examples (those after the first will only work on PostgreSQL)::"
msgstr "Примеры (все, кроме первого, будут работать только в PostgreSQL)::"

# 2073ece925b14b31aa399ff9c23be9c2
#: ../../ref/models/querysets.txt:482
msgid ""
"Keep in mind that :meth:`order_by` uses any default related model ordering "
"that has been defined. You might have to explicitly order by the relation "
"``_id`` or referenced field to make sure the ``DISTINCT ON`` expressions "
"match those at the beginning of the ``ORDER BY`` clause. For example, if the "
"``Blog`` model defined an :attr:`~django.db.models.Options.ordering` by "
"``name``::"
msgstr ""
"Обратите внимание, :meth:`order_by` используется сортировку, которая указана "
"в связанной модели. Возможно вам понадобится явно отсортировать по внешнему "
"ключу, или полю связанной модели, чтобы ``DISTINCT ON`` использовал поле "
"аналогичное первому полю в ``ORDER BY``. Например, если модель ``Blog`` "
"определена с :attr:`~django.db.models.Options.ordering` равным ``name``::"

# 9bbc7283cda9457a93bb29e100c3d4d2
#: ../../ref/models/querysets.txt:491
msgid ""
"...wouldn't work because the query would be ordered by ``blog__name`` thus "
"mismatching the ``DISTINCT ON`` expression. You'd have to explicitly order "
"by the relation `_id` field (``blog_id`` in this case) or the referenced one "
"(``blog__pk``) to make sure both expressions match."
msgstr ""
"...не будет работать т.к. запрос отсортирует по ``blog__name``, что не "
"соответствует полю в ``DISTINCT ON``. Вам необходимо явно отсортировать по "
"внешнему ключу (``blog_id`` в этому случае), или полю связанной модели "
"(``blog__pk``), чтобы поля совпадали."

# af5851511053417684d907a9326d9023
#: ../../ref/models/querysets.txt:497
#, fuzzy
msgid "``values()``"
msgstr "values"

# 49fb7386a28047a38968129991eba91f
#: ../../ref/models/querysets.txt:501
msgid ""
"Returns a ``QuerySet`` that returns dictionaries, rather than model "
"instances, when used as an iterable."
msgstr ""
"Возвращает ``QuerySet`` , который возвращает словари с результатом вместо "
"объектов моделей."

# cb5947d3cddb4e288c8bcaf10bd28e35
#: ../../ref/models/querysets.txt:504
msgid ""
"Each of those dictionaries represents an object, with the keys corresponding "
"to the attribute names of model objects."
msgstr ""
"Каждый словарь представляет объект, ключи которого соответствуют полям "
"модели."

# ac94864efe7e413881125d12d960d3f1
#: ../../ref/models/querysets.txt:507
msgid ""
"This example compares the dictionaries of ``values()`` with the normal model "
"objects::"
msgstr ""
"Этот пример показывает разницу между результатом возвращаемым ``values()`` и "
"объектами модели::"

# 6a895173a763438790f5974f0d8306a9
#: ../../ref/models/querysets.txt:518
msgid ""
"The ``values()`` method takes optional positional arguments, ``*fields``, "
"which specify field names to which the ``SELECT`` should be limited. If you "
"specify the fields, each dictionary will contain only the field keys/values "
"for the fields you specify. If you don't specify the fields, each dictionary "
"will contain a key and value for every field in the database table."
msgstr ""
"Метод ``values()`` принимает дополнительные позиционные аргументы, "
"``*fields``, которые определяют какие поля будут получены через ``SELECT``. "
"Каждый словарь будет содержать только указанные поля. Если поля не указаны, "
"каждый словарь будет содержать все данные из таблицы в базе данных."

#: ../../ref/models/querysets.txt:531
msgid ""
"The ``values()`` method also takes optional keyword arguments, "
"``**expressions``, which are passed through to :meth:`annotate`::"
msgstr ""

#: ../../ref/models/querysets.txt:538
msgid ""
"An aggregate within a ``values()`` clause is applied before other arguments "
"within the same ``values()`` clause. If you need to group by another value, "
"add it to an earlier ``values()`` clause instead. For example::"
msgstr ""

# e78f74bf322a45fbb3d7aadac36bf87a
#: ../../ref/models/querysets.txt:548
msgid "A few subtleties that are worth mentioning:"
msgstr "Следует упомянуть несколько тонкостей:"

# e4db51fd4b5e405383e764d1d9ea1047
#: ../../ref/models/querysets.txt:550
msgid ""
"If you have a field called ``foo`` that is a :class:`~django.db.models."
"ForeignKey`, the default ``values()`` call will return a dictionary key "
"called ``foo_id``, since this is the name of the hidden model attribute that "
"stores the actual value (the ``foo`` attribute refers to the related model). "
"When you are calling ``values()`` and passing in field names, you can pass "
"in either ``foo`` or ``foo_id`` and you will get back the same thing (the "
"dictionary key will match the field name you passed in)."
msgstr ""
"Если модель содержит поле ``foo`` типа :class:`~django.db.models."
"ForeignKey`, по-умолчанию ``values()`` вернет словарь с ключом ``foo_id``, т."
"к. это названия скрытого поля, которое на самом деле хранит значение "
"(атрибут ``foo`` отображает связанную модель). Вызывая ``values()`` вы "
"можете передать ``foo`` или ``foo_id`` и получите тот же результат (ключ "
"словаря будет равен переданному значению)."

# 3103ac6bd6f34454baf5fc60b4160233
# c5738a85fd984c2fa84d5a69a91a2452
# d9dec8adfce64fdcb8581558ebfde631
# c1089638b0ad4386bd46c32864e5fcac
#: ../../ref/models/querysets.txt:559 ../../ref/models/querysets.txt:1423
#: ../../ref/models/querysets.txt:1627 ../../ref/models/querysets.txt:1643
msgid "For example::"
msgstr "Например::"

# 51b23e8160934f9c82dda9f6b81f91a3
#: ../../ref/models/querysets.txt:570
msgid ""
"When using ``values()`` together with :meth:`distinct()`, be aware that "
"ordering can affect the results. See the note in :meth:`distinct` for "
"details."
msgstr ""
"Используя ``values()`` с :meth:`distinct()`, обратите внимание, что "
"сортировка может повлиять на результат. Подробности в описании метода :meth:"
"`distinct`."

# 1708b68a0b5d4d5b870cc5907d019f08
#: ../../ref/models/querysets.txt:574
msgid ""
"If you use a ``values()`` clause after an :meth:`extra()` call, any fields "
"defined by a ``select`` argument in the :meth:`extra()` must be explicitly "
"included in the ``values()`` call. Any :meth:`extra()` call made after a "
"``values()`` call will have its extra selected fields ignored."
msgstr ""
"Используя ``values()`` после вызова :meth:`extra()`, добавьте в ``values()`` "
"все поля указанные в аргументе ``select`` использованном при вызове :meth:"
"`extra()`. При вызове :meth:`extra()` после ``values()`` все указанные "
"дополнительные поля будут проигнорированы."

# 3e6043f57dee4181af7ffc769300beab
#: ../../ref/models/querysets.txt:580
msgid ""
"Calling :meth:`only()` and :meth:`defer()` after ``values()`` doesn't make "
"sense, so doing so will raise a ``NotImplementedError``."
msgstr ""
"Вызов :meth:`only()` или :meth:`defer()` после ``values()`` не имеет смысла. "
"В таком случае будет вызвано исключение ``NotImplementedError``."

# 1015bea283fc4547a2248e39469a320e
#: ../../ref/models/querysets.txt:583
msgid ""
"It is useful when you know you're only going to need values from a small "
"number of the available fields and you won't need the functionality of a "
"model instance object. It's more efficient to select only the fields you "
"need to use."
msgstr ""
"Полезен, если вам нужны только данные некоторых полей и не нужен функционал "
"объектов моделей. Более эффективно получить только необходимые данные."

# e0be586998f34c22a49475475a9f6309
#: ../../ref/models/querysets.txt:587
msgid ""
"Finally, note that you can call ``filter()``, ``order_by()``, etc. after the "
"``values()`` call, that means that these two calls are identical::"
msgstr ""
"Обратите внимание, при вызове ``filter()``, ``order_by()`` и других методов "
"после вызова ``values()``, означает, что следующие объекты одинаковы::"

# d65a646eb811447a9b6958db3e21d60b
#: ../../ref/models/querysets.txt:593
msgid ""
"The people who made Django prefer to put all the SQL-affecting methods "
"first, followed (optionally) by any output-affecting methods (such as "
"``values()``), but it doesn't really matter. This is your chance to really "
"flaunt your individualism."
msgstr ""
"Разработчики Django предпочитают использовать в первую очередь методы "
"влияющие на SQL-запрос, далее методы влияющие на вывод данных (такие как "
"``values()``), хотя это и не имеет значения. Это ваш шанс проявить "
"индивидуальность."

# f5eb1490873243d494cb93a58ebf85e9
#: ../../ref/models/querysets.txt:598
msgid ""
"You can also refer to fields on related models with reverse relations "
"through ``OneToOneField``, ``ForeignKey`` and ``ManyToManyField`` "
"attributes::"
msgstr ""
"Вы также можете обратиться к обратно связанным моделям через поля "
"``OneToOneField``, ``ForeignKey`` и ``ManyToManyField``::"

# 7557f8612db24cc198d2c6484189d537
#: ../../ref/models/querysets.txt:607
msgid ""
"Because :class:`~django.db.models.ManyToManyField` attributes and reverse "
"relations can have multiple related rows, including these can have a "
"multiplier effect on the size of your result set. This will be especially "
"pronounced if you include multiple such fields in your ``values()`` query, "
"in which case all possible combinations will be returned."
msgstr ""
"Так как :class:`~django.db.models.ManyToManyField` и обратная связь может "
"содержать множество связанных записей, выбор этих данных может многократно "
"увеличить размер возвращаемых данных. Это будет особенно заметно, если вы "
"включите несколько таких полей в ``values()``, в таком случае будут "
"возвращены все возможные комбинации значений."

#: ../../ref/models/querysets.txt:615
#, fuzzy
msgid "Support for ``**expressions`` was added."
msgstr "Была добавлена возможность сортировать по выражению."

# 579aab5752cb438d80b3c2f226e36cb8
#: ../../ref/models/querysets.txt:618
#, fuzzy
msgid "``values_list()``"
msgstr "values_list"

# 97303ab27631499da3fc7e3e9328ecf6
#: ../../ref/models/querysets.txt:622
#, fuzzy
msgid ""
"This is similar to ``values()`` except that instead of returning "
"dictionaries, it returns tuples when iterated over. Each tuple contains the "
"value from the respective field or expression passed into the "
"``values_list()`` call — so the first item is the first field, etc. For "
"example::"
msgstr ""
"Аналогичен ``values()``, но вместо словаря возвращает кортеж. Каждый кортеж "
"содержит значения полей указанных при вызове ``values_list()`` в том же "
"порядке — первый элемент значение первого поля и т.д. Например::"

# ccb1350a9f4141cfa5cad5c849fdb5d5
#: ../../ref/models/querysets.txt:633
msgid ""
"If you only pass in a single field, you can also pass in the ``flat`` "
"parameter. If ``True``, this will mean the returned results are single "
"values, rather than one-tuples. An example should make the difference "
"clearer::"
msgstr ""
"Если вы указали одно поле, можете указать аргумент ``flat``. При ``True``, "
"каждая запись будет возвращена как отдельное значение, а не одноэлементный "
"кортеж. Например::"

# 0b0afc3c5ba6418da21a36cf1b7de005
#: ../../ref/models/querysets.txt:643
msgid "It is an error to pass in ``flat`` when there is more than one field."
msgstr ""
"Если вы указали больше одного поля, использование ``flat`` будет ошибкой."

#: ../../ref/models/querysets.txt:645
msgid ""
"You can pass ``named=True`` to get results as a :func:`~python:collections."
"namedtuple`::"
msgstr ""

#: ../../ref/models/querysets.txt:651
msgid ""
"Using a named tuple may make use of the results more readable, at the "
"expense of a small performance penalty for transforming the results into a "
"named tuple."
msgstr ""

# a90ae6bd840642f39a79a2a6b105be21
#: ../../ref/models/querysets.txt:654
msgid ""
"If you don't pass any values to ``values_list()``, it will return all the "
"fields in the model, in the order they were declared."
msgstr ""
"Если поля не будут указаны при вызове ``values_list()``, будут возвращены "
"все поля модели в порядке, в котором они были объявлены."

#: ../../ref/models/querysets.txt:657
msgid ""
"A common need is to get a specific field value of a certain model instance. "
"To achieve that, use ``values_list()`` followed by a ``get()`` call::"
msgstr ""
"Распространенная задача получить значение поля из определенной записи. Для "
"этого используйте ``values_list()`` и ``get()``::"

#: ../../ref/models/querysets.txt:663
msgid ""
"``values()`` and ``values_list()`` are both intended as optimizations for a "
"specific use case: retrieving a subset of data without the overhead of "
"creating a model instance. This metaphor falls apart when dealing with many-"
"to-many and other multivalued relations (such as the one-to-many relation of "
"a reverse foreign key) because the \"one row, one object\" assumption "
"doesn't hold."
msgstr ""

#: ../../ref/models/querysets.txt:669
msgid ""
"For example, notice the behavior when querying across a :class:`~django.db."
"models.ManyToManyField`::"
msgstr ""

#: ../../ref/models/querysets.txt:678
msgid ""
"Authors with multiple entries appear multiple times and authors without any "
"entries have ``None`` for the entry headline."
msgstr ""

#: ../../ref/models/querysets.txt:681
msgid ""
"Similarly, when querying a reverse foreign key, ``None`` appears for entries "
"not having any author::"
msgstr ""

#: ../../ref/models/querysets.txt:689
#, fuzzy
msgid "Support for expressions in ``*fields`` was added."
msgstr ""
"Была добавлена возможность указать выражение при сортировке, например "
"``Lower``."

#: ../../ref/models/querysets.txt:693
#, fuzzy
msgid "The ``named`` parameter was added."
msgstr "Был добавлен аргумент ``output_field``."

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:696
#, fuzzy
msgid "``dates()``"
msgstr "dates"

# 39c9d32ce13e4247960fb10a992f4943
#: ../../ref/models/querysets.txt:700
msgid ""
"Returns a ``QuerySet`` that evaluates to a list of :class:`datetime.date` "
"objects representing all available dates of a particular kind within the "
"contents of the ``QuerySet``."
msgstr ""
"Возвращает ``QuerySet``, который возвращает список объектов :class:`datetime."
"date`, отображающих возможные даты в контексте ``QuerySet``."

# 7a8b45479ff14c29a5adbde580e97125
#: ../../ref/models/querysets.txt:704
msgid ""
"``field`` should be the name of a ``DateField`` of your model. ``kind`` "
"should be either ``\"year\"``, ``\"month\"`` or ``\"day\"``. Each ``datetime."
"date`` object in the result list is \"truncated\" to the given ``type``."
msgstr ""
"``field`` должен быть названием поля ``DateField`` вашей модели. ``kind`` "
"должен быть ``\"year\"``, ``\"month\"`` или ``\"day\"``. Каждый объект "
"``datetime.date`` - результат \"урезания\" данных в соответствии с указанным "
"``type``."

# af481c348edd403dbe26e806860a8cc2
#: ../../ref/models/querysets.txt:709
msgid "``\"year\"`` returns a list of all distinct year values for the field."
msgstr ""
"``\"year\"`` возвращает список уникальных значений года из всех дат "
"указанного поля."

# 4045d630ba0d47af887dd450631e3549
#: ../../ref/models/querysets.txt:710
msgid ""
"``\"month\"`` returns a list of all distinct year/month values for the field."
msgstr ""
"``\"month\"`` возвращает список уникальных значений года/месяца из всех дат "
"указанного поля."

# b3c5624dc54c4b8fa4ba0682ea138ef7
#: ../../ref/models/querysets.txt:712
msgid ""
"``\"day\"`` returns a list of all distinct year/month/day values for the "
"field."
msgstr ""
"``\"day\"`` возвращает список уникальных значений года/месяца/дня из всех "
"дат указанного поля."

# 500c765dc01140819e5dd68e8ac42e59
#: ../../ref/models/querysets.txt:715 ../../ref/models/querysets.txt:746
msgid ""
"``order``, which defaults to ``'ASC'``, should be either ``'ASC'`` or "
"``'DESC'``. This specifies how to order the results."
msgstr ""
"``order`` -- сортировка значений. По-умолчанию ``'ASC'``, должна быть "
"``'ASC'`` или ``'DESC'``."

# 12ffb7971cd54ddb86243f6be88eba97
# a1594fb3f3764aa29bb1251fe9792b80
# 23387ea901374de5b1c31ae9b2f22556
# b327b9678e274966b4d91cac79c5d6e1
#: ../../ref/models/querysets.txt:718 ../../ref/models/querysets.txt:784
#: ../../ref/models/querysets.txt:2487
msgid "Examples::"
msgstr "Например::"

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:732
#, fuzzy
msgid "``datetimes()``"
msgstr "datetimes"

# 39c9d32ce13e4247960fb10a992f4943
#: ../../ref/models/querysets.txt:736
msgid ""
"Returns a ``QuerySet`` that evaluates to a list of :class:`datetime."
"datetime` objects representing all available dates of a particular kind "
"within the contents of the ``QuerySet``."
msgstr ""
"Возвращает ``QuerySet``, который возвращает список объектов :class:`datetime."
"datetime`, отображающих возможные даты в контексте ``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#: ../../ref/models/querysets.txt:740
msgid "``field_name`` should be the name of a ``DateTimeField`` of your model."
msgstr "``field_name`` -- название поля модели типа ``DateTimeField``."

# 7a8b45479ff14c29a5adbde580e97125
#: ../../ref/models/querysets.txt:742
msgid ""
"``kind`` should be either ``\"year\"``, ``\"month\"``, ``\"day\"``, ``\"hour"
"\"``, ``\"minute\"`` or ``\"second\"``. Each ``datetime.datetime`` object in "
"the result list is \"truncated\" to the given ``type``."
msgstr ""
"``kind`` должен быть ``\"year\"``, ``\"month\"``, ``\"day\"``, ``\"hour\"``, "
"``\"minute\"`` или ``\"second\"``. Каждый объект ``datetime.datetime`` "
"результат \"урезания\" данных в соответствии с указанным ``kind``."

# bc9e881a6bbb4af09f0793ed6b9a89b2
#: ../../ref/models/querysets.txt:749
msgid ""
"``tzinfo`` defines the time zone to which datetimes are converted prior to "
"truncation. Indeed, a given datetime has different representations depending "
"on the time zone in use. This parameter must be a :class:`datetime.tzinfo` "
"object. If it's ``None``, Django uses the :ref:`current time zone <default-"
"current-time-zone>`. It has no effect when :setting:`USE_TZ` is ``False``."
msgstr ""
"``tzinfo`` указывает часовой пояс используемый при создании объектов "
"datetime. Принимает объект :class:`datetime.tzinfo`. Если передать ``None``, "
"Django использует :ref:`текущий часовой пояс <default-current-time-zone>`. "
"Не используется при :setting:`USE_TZ` равном ``False``."

# 57e651fbcf294534a031ebfb87a6cd60
#: ../../ref/models/querysets.txt:760
msgid ""
"This function performs time zone conversions directly in the database. As a "
"consequence, your database must be able to interpret the value of ``tzinfo."
"tzname(None)``. This translates into the following requirements:"
msgstr ""
"Функция выполняет преобразование даты на уровне базы данных. Поэтому ваша "
"база данных должна понимать значение вида ``tzinfo.tzname(None)``. Для этого "
"необходимо:"

#: ../../ref/models/querysets.txt:764
msgid ""
"SQLite: no requirements. Conversions are performed in Python with pytz_ "
"(installed when you install Django)."
msgstr ""

# 4729dc1f08964e7f95223516a0acb706
#: ../../ref/models/querysets.txt:766
msgid "PostgreSQL: no requirements (see `Time Zones`_)."
msgstr "PostgreSQL: нет дополнительных требований (смотрите `Time Zones`_)."

# 7620300112df42548672eaf4b476ca92
#: ../../ref/models/querysets.txt:767
msgid "Oracle: no requirements (see `Choosing a Time Zone File`_)."
msgstr ""
"Oracle: нет дополнительных требований (смотрите `Choosing a Time Zone "
"File`_)."

# ee76f7ef2af5491dbfd763b2d4cdd593
#: ../../ref/models/querysets.txt:768
#, fuzzy
msgid "MySQL: load the time zone tables with `mysql_tzinfo_to_sql`_."
msgstr ""
"MySQL: установите pytz_ и загрузите таблицы часовых поясов с помощью "
"`mysql_tzinfo_to_sql`_."

#: ../../ref/models/querysets.txt:776
msgid "``none()``"
msgstr ""

# 51b96358f163485ab9441693642e9d23
#: ../../ref/models/querysets.txt:780
msgid ""
"Calling none() will create a queryset that never returns any objects and no "
"query will be executed when accessing the results. A qs.none() queryset is "
"an instance of ``EmptyQuerySet``."
msgstr ""
"Вызов none() вернет queryset, который никогда не возвращает объекты и не "
"выполняет запросы. qs.none() возвращает экземпляр ``EmptyQuerySet``."

#: ../../ref/models/querysets.txt:793
msgid "``all()``"
msgstr ""

# 572293992d5a4f12b4507aaa97e801e3
#: ../../ref/models/querysets.txt:797
msgid ""
"Returns a *copy* of the current ``QuerySet`` (or ``QuerySet`` subclass).  "
"This can be useful in situations where you might want to pass in either a "
"model manager or a ``QuerySet`` and do further filtering on the result. "
"After calling ``all()`` on either object, you'll definitely have a "
"``QuerySet`` to work with."
msgstr ""
"Возвращает *копию* текущего ``QuerySet`` (или подкласса ``QuerySet``).  Это "
"может быть полезно, если вам нужно передать в функцию менеджер модели или "
"``QuerySet`` и выполнить дальнейшую фильтрацию результата. После вызова "
"``all()`` вы получите копию ``QuerySet``, которую можно передать в функцию "
"не боясь, что она изменит текущий ``QuerySet``."

# 5ad7112021e04e1abf46350d6808ad9d
#: ../../ref/models/querysets.txt:802
msgid ""
"When a ``QuerySet`` is :ref:`evaluated <when-querysets-are-evaluated>`, it "
"typically caches its results. If the data in the database might have changed "
"since a ``QuerySet`` was evaluated, you can get updated results for the same "
"query by calling ``all()`` on a previously evaluated ``QuerySet``."
msgstr ""
"Если ``QuerySet`` был :ref:`выполнен <when-querysets-are-evaluated>`, он "
"кэширует результат. Если данные в базе данных поменялись после выполнения "
"``QuerySet``, вы можете получить обновленный результат запроса, вызывав "
"``all()`` уже выполненного ``QuerySet``."

# be693002305d4620b81f6195a5f605e7
#: ../../ref/models/querysets.txt:808
#, fuzzy
msgid "``union()``"
msgstr "using"

#: ../../ref/models/querysets.txt:814
msgid ""
"Uses SQL's ``UNION`` operator to combine the results of two or more "
"``QuerySet``\\s. For example:"
msgstr ""

#: ../../ref/models/querysets.txt:819
msgid ""
"The ``UNION`` operator selects only distinct values by default. To allow "
"duplicate values, use the ``all=True`` argument."
msgstr ""

#: ../../ref/models/querysets.txt:822
msgid ""
"``union()``, ``intersection()``, and ``difference()`` return model instances "
"of the type of the first ``QuerySet`` even if the arguments are ``QuerySet``"
"\\s of other models. Passing different models works as long as the "
"``SELECT`` list is the same in all ``QuerySet``\\s (at least the types, the "
"names don't matter as long as the types in the same order). In such cases, "
"you must use the column names from the first ``QuerySet`` in ``QuerySet`` "
"methods applied to the resulting ``QuerySet``. For example::"
msgstr ""

#: ../../ref/models/querysets.txt:834
msgid ""
"In addition, only ``LIMIT``, ``OFFSET``, ``COUNT(*)``, ``ORDER BY``, and "
"specifying columns (i.e. slicing, :meth:`count`, :meth:`order_by`, and :meth:"
"`values()`/:meth:`values_list()`) are allowed on the resulting ``QuerySet``. "
"Further, databases place restrictions on what operations are allowed in the "
"combined queries. For example, most databases don't allow ``LIMIT`` or "
"``OFFSET`` in the combined queries."
msgstr ""

#: ../../ref/models/querysets.txt:843
msgid "``COUNT(*)`` support was added."
msgstr ""

# acc6068123c54c2f849ad58f62cbb6ad
#: ../../ref/models/querysets.txt:846
#, fuzzy
msgid "``intersection()``"
msgstr "iterator"

#: ../../ref/models/querysets.txt:852
msgid ""
"Uses SQL's ``INTERSECT`` operator to return the shared elements of two or "
"more ``QuerySet``\\s. For example:"
msgstr ""

#: ../../ref/models/querysets.txt:857 ../../ref/models/querysets.txt:871
msgid "See :meth:`union` for some restrictions."
msgstr ""

# 3afdacafdbad455b9e1e7a53ec7b6031
#: ../../ref/models/querysets.txt:860
#, fuzzy
msgid "``difference()``"
msgstr "defer"

#: ../../ref/models/querysets.txt:866
msgid ""
"Uses SQL's ``EXCEPT`` operator to keep only elements present in the "
"``QuerySet`` but not in some other ``QuerySet``\\s. For example::"
msgstr ""

# c49b527e87f04a66adda31c1a3327a74
#: ../../ref/models/querysets.txt:874
#, fuzzy
msgid "``select_related()``"
msgstr "select_related"

# 2dbb0260148b4133baccddfbf37f18eb
#: ../../ref/models/querysets.txt:878
msgid ""
"Returns a ``QuerySet`` that will \"follow\" foreign-key relationships, "
"selecting additional related-object data when it executes its query. This is "
"a performance booster which results in a single more complex query but means "
"later use of foreign-key relationships won't require database queries."
msgstr ""
"Возвращает ``QuerySet`` который автоматически включает в выборку данные "
"связанных объектов при выполнении запроса. Повышает производительность, т.к. "
"при доступе к связанным объектам через модель не потребуются дополнительные "
"запросы в базу данных."

# f4caa3922bd7491d99841d4199f56b42
#: ../../ref/models/querysets.txt:883
msgid ""
"The following examples illustrate the difference between plain lookups and "
"``select_related()`` lookups. Here's standard lookup::"
msgstr ""
"Этот пример отображает разницу между обычной выборкой и с "
"``select_related()``. Обычная выборка::"

# b563008653c34aee865d8f3f69ed0969
#: ../../ref/models/querysets.txt:892
msgid "And here's ``select_related`` lookup::"
msgstr "И с ``select_related``::"

#: ../../ref/models/querysets.txt:901
msgid "You can use ``select_related()`` with any queryset of objects::"
msgstr "Вы можете использовать ``select_related()`` с любым \"queryset\"::"

#: ../../ref/models/querysets.txt:913
msgid ""
"The order of ``filter()`` and ``select_related()`` chaining isn't important. "
"These querysets are equivalent::"
msgstr ""
"Порядок использования ``filter()`` и ``select_related()`` не важен. Эти "
"экземпляры ``QuerySet`` одинаковы::"

# e3f6354104e0493a9a828ef9334fdeea
#: ../../ref/models/querysets.txt:919
msgid ""
"You can follow foreign keys in a similar way to querying them. If you have "
"the following models::"
msgstr ""
"Можно указывать поля связанных моделей как и при запросе. Например, у нас "
"есть такие модели::"

# 26ababe5af374ddab78c493810a3d259
#: ../../ref/models/querysets.txt:941
msgid ""
"... then a call to ``Book.objects.select_related('author__hometown')."
"get(id=4)`` will cache the related ``Person`` *and* the related ``City``::"
msgstr ""
"...тогда вызов ``Book.objects.select_related('person__hometown').get(id=4)`` "
"получит данные связанных ``Person`` *и* связанных ``City``::"

# 7658fa95c6cc469d8ad2cc333a17d849
#: ../../ref/models/querysets.txt:954
msgid ""
"You can refer to any :class:`~django.db.models.ForeignKey` or :class:"
"`~django.db.models.OneToOneField` relation in the list of fields passed to "
"``select_related()``."
msgstr ""
"Вы можете указать любое :class:`~django.db.models.ForeignKey` или :class:"
"`~django.db.models.OneToOneField` поле в ``select_related()``."

# f0695e8976554521ad36bd94ee905e2b
#: ../../ref/models/querysets.txt:958
msgid ""
"You can also refer to the reverse direction of a :class:`~django.db.models."
"OneToOneField` in the list of fields passed to ``select_related`` — that is, "
"you can traverse a :class:`~django.db.models.OneToOneField` back to the "
"object on which the field is defined. Instead of specifying the field name, "
"use the :attr:`related_name <django.db.models.ForeignKey.related_name>` for "
"the field on the related object."
msgstr ""
"Вы можете указать обратную связь для :class:`~django.db.models."
"OneToOneField` в списке полей — то есть, вы можете получить объект в котором "
"определено поле :class:`~django.db.models.OneToOneField`. Вместо названия "
"поля используйте значение параметра :attr:`related_name <django.db.models."
"ForeignKey.related_name>`."

# b36da2e8a9fa4bd38d9bf40ea8449aa6
#: ../../ref/models/querysets.txt:965
msgid ""
"There may be some situations where you wish to call ``select_related()`` "
"with a lot of related objects, or where you don't know all of the relations. "
"In these cases it is possible to call ``select_related()`` with no "
"arguments. This will follow all non-null foreign keys it can find - nullable "
"foreign keys must be specified. This is not recommended in most cases as it "
"is likely to make the underlying query more complex, and return more data, "
"than is actually needed."
msgstr ""
"В некоторых ситуациях вам может понадобится указать большое количество полей "
"в ``select_related()``, или вы просто не знаете всех связей. В таком случае "
"можно использовать ``select_related()`` без аргументов. Будут использовать "
"все связи кроме связей с ``null=True``, такие связи необходимо указывать "
"явно. Такой способ не рекомендуется т.к. может привести к очень сложному "
"запросу и получению большого количества ненужных данных."

# 5782a17c48c4436e999a91a12322d796
#: ../../ref/models/querysets.txt:972
msgid ""
"If you need to clear the list of related fields added by past calls of "
"``select_related`` on a ``QuerySet``, you can pass ``None`` as a parameter::"
msgstr ""
"Чтобы очистить список полей указанных ранее ``select_related`` для "
"``QuerySet``, предайте ``None``::"

# 2826c34e4d1a4e39a09a6d35243d70b4
#: ../../ref/models/querysets.txt:977
msgid ""
"Chaining ``select_related`` calls works in a similar way to other methods - "
"that is that ``select_related('foo', 'bar')`` is equivalent to "
"``select_related('foo').select_related('bar')``."
msgstr ""
"Несколько вызовов ``select_related`` теперь работает как и для других "
"методов -- то есть ``select_related('foo', 'bar')`` аналогично "
"``select_related('foo').select_related('bar')``."

# c88e911f60014854a17560028894701a
#: ../../ref/models/querysets.txt:982
#, fuzzy
msgid "``prefetch_related()``"
msgstr "prefetch_related"

# 549d0360b83f45e5b22af301ab7d707c
#: ../../ref/models/querysets.txt:986
msgid ""
"Returns a ``QuerySet`` that will automatically retrieve, in a single batch, "
"related objects for each of the specified lookups."
msgstr ""
"Возвращает ``QuerySet``, который получает \"за один подход\" связанные "
"объекты для каждого из указанных параметров поиска."

# 9f0ccc75a72444f0afeb9cd747791de4
#: ../../ref/models/querysets.txt:989
msgid ""
"This has a similar purpose to ``select_related``, in that both are designed "
"to stop the deluge of database queries that is caused by accessing related "
"objects, but the strategy is quite different."
msgstr ""
"Смысл такой же, как и у ``select_related``, избежать нарастающего количества "
"запросов при обращении к связанным объектам, но принцип работы немного "
"другой."

# 9c1bd26fc3c1409caeb9d73b158aec1a
#: ../../ref/models/querysets.txt:993
msgid ""
"``select_related`` works by creating an SQL join and including the fields of "
"the related object in the ``SELECT`` statement. For this reason, "
"``select_related`` gets the related objects in the same database query. "
"However, to avoid the much larger result set that would result from joining "
"across a 'many' relationship, ``select_related`` is limited to single-valued "
"relationships - foreign key and one-to-one."
msgstr ""
"``select_related`` создает запрос SQL, объединяющий связанные таблицы и "
"включающий дополнительные поля в ``SELECT``. По этой причине, "
"``select_related`` получает связанные объекты в том же запросе. Однако, "
"чтобы избежать большого количества возвращаемых данных при обработке "
"\"множественных\" связей, ``select_related`` работает только со связями "
"возвращающими один объект - внешний ключ и связь один-к-одному."

# d3ca3301d5f04a74adc64b849150dec0
#: ../../ref/models/querysets.txt:1000
msgid ""
"``prefetch_related``, on the other hand, does a separate lookup for each "
"relationship, and does the 'joining' in Python. This allows it to prefetch "
"many-to-many and many-to-one objects, which cannot be done using "
"``select_related``, in addition to the foreign key and one-to-one "
"relationships that are supported by ``select_related``. It also supports "
"prefetching of :class:`~django.contrib.contenttypes.fields.GenericRelation` "
"and :class:`~django.contrib.contenttypes.fields.GenericForeignKey`, however, "
"it must be restricted to a homogeneous set of results. For example, "
"prefetching objects referenced by a ``GenericForeignKey`` is only supported "
"if the query is restricted to one ``ContentType``."
msgstr ""
"``prefetch_related``, с другой стороны, выбирает данные для каждой связи "
"отдельно, и выполняет \"объединение\" на уровне Python. Благодаря этому "
"могут быть обработаны связи многое-ко-многим и многое-к-одному, которые не "
"обрабатывает ``select_related``, в том числе и внешние ключи и связь один-к-"
"одному поддерживаемые ``select_related``. Также поддерживается "
"предварительная выборка для :class:`~django.contrib.contenttypes.fields."
"GenericRelation` и :class:`~django.contrib.contenttypes.fields."
"GenericForeignKey`, однако, можно выбирать только однородные данные. "
"Например, Подгружать объекты из ``GenericForeignKey`` можно только одного "
"``ContentType``."

# 008a1928e12d487aa0ede700f59f8cb2
#: ../../ref/models/querysets.txt:1011
msgid "For example, suppose you have these models::"
msgstr "Например, у вас есть две модели::"

# 35465e7b81454c2e9e1e6418666353d8
#: ../../ref/models/querysets.txt:1028
msgid "and run::"
msgstr "и выполняется такой код::"

# 753863380a5a47199cd6d3d853437c53
#: ../../ref/models/querysets.txt:1033
msgid ""
"The problem with this is that every time ``Pizza.__str__()`` asks for ``self."
"toppings.all()`` it has to query the database, so ``Pizza.objects.all()`` "
"will run a query on the Toppings table for **every** item in the Pizza "
"``QuerySet``."
msgstr ""
"Проблема в том, что ``Pizza.__str__()``, вызывая ``self.toppings.all()`` "
"выполняет запрос к базе данных, и ``Pizza.objects.all()`` выполнит запрос к "
"таблице Topping для **каждого** объекта Pizza в ``QuerySet``."

# e439e97e543849a98b81a06423129015
#: ../../ref/models/querysets.txt:1038
msgid "We can reduce to just two queries using ``prefetch_related``:"
msgstr ""
"Мы можем уменьшить количество запросов до двух, используя "
"``prefetch_related``:"

# bd6f5c62f9cf477caa6b78b79d31b29b
#: ../../ref/models/querysets.txt:1042
msgid ""
"This implies a ``self.toppings.all()`` for each ``Pizza``; now each time "
"``self.toppings.all()`` is called, instead of having to go to the database "
"for the items, it will find them in a prefetched ``QuerySet`` cache that was "
"populated in a single query."
msgstr ""
"Этот код аналогичен выполнению ``self.toppings.all()`` для каждого объекта "
"``Pizza`` . При вызове ``self.toppings.all()`` будут использоваться "
"подгруженные данные, вместо запроса к БД. Django найдет их в кэше "
"``QuerySet``, который был заполнен одним запросом."

# 4d10c7e6aa5f4733bcee31330f527481
#: ../../ref/models/querysets.txt:1047
msgid ""
"That is, all the relevant toppings will have been fetched in a single query, "
"and used to make ``QuerySets`` that have a pre-filled cache of the relevant "
"results; these ``QuerySets`` are then used in the ``self.toppings.all()`` "
"calls."
msgstr ""
"Все соответствующие начинки(toppings) будут получены одним запросом, чтобы "
"создать ``QuerySets``, который имеет предварительно заполненный кэш "
"соответствующих результатов. Этот ``QuerySets`` будет использован при вызове "
"``self.toppings.all()``."

# 57fb4b4edc2448c78f79f7a26f560ec0
#: ../../ref/models/querysets.txt:1051
msgid ""
"The additional queries in ``prefetch_related()`` are executed after the "
"``QuerySet`` has begun to be evaluated and the primary query has been "
"executed."
msgstr ""
"Запрос для загрузки данных, указанных в ``prefetch_related()`` будет "
"выполнен после выполнения основного запроса."

#: ../../ref/models/querysets.txt:1054
msgid ""
"If you have an iterable of model instances, you can prefetch related "
"attributes on those instances using the :func:`~django.db.models."
"prefetch_related_objects` function."
msgstr ""

# 10fa255f68f044dbb2e14e867da74c51
#: ../../ref/models/querysets.txt:1058
msgid ""
"Note that the result cache of the primary ``QuerySet`` and all specified "
"related objects will then be fully loaded into memory. This changes the "
"typical behavior of ``QuerySets``, which normally try to avoid loading all "
"objects into memory before they are needed, even after a query has been "
"executed in the database."
msgstr ""
"Обратите внимание, что будет \"закэширован\" также результат выполнения "
"основного ``QuerySet``, а также будут загружены все связанные объекты. Это "
"отличается от стандартного поведения ``QuerySets``, при котором Django "
"старается не загружать связанные данные как можно дольше."

# 3a4a1d81d12140e09e5217ecdbe41461
#: ../../ref/models/querysets.txt:1066
msgid ""
"Remember that, as always with ``QuerySets``, any subsequent chained methods "
"which imply a different database query will ignore previously cached "
"results, and retrieve data using a fresh database query. So, if you write "
"the following:"
msgstr ""
"Помните, для всех ``QuerySets`` любой последующий метод, который изменяет "
"запрос, проигнорирует ранее загруженный кэш и получит данные, выполнив новый "
"запрос. Итак, используя такой код:"

# cc5a38e36ca249b498d95ff562f0a09b
#: ../../ref/models/querysets.txt:1074
msgid ""
"...then the fact that ``pizza.toppings.all()`` has been prefetched will not "
"help you. The ``prefetch_related('toppings')`` implied ``pizza.toppings."
"all()``, but ``pizza.toppings.filter()`` is a new and different query. The "
"prefetched cache can't help here; in fact it hurts performance, since you "
"have done a database query that you haven't used. So use this feature with "
"caution!"
msgstr ""
"...тот факт, что ``pizza.toppings.all()`` предварительно загружает данные, "
"не поможет вам. ``prefetch_related('toppings')`` применяется к ``pizza."
"toppings.all()``, а ``pizza.toppings.filter()`` совершенно другой запрос. "
"Загруженный кэш не будет использоваться и будут выполнены дополнительные "
"запросы. Пользуйтесь этим методом осторожно!"

#: ../../ref/models/querysets.txt:1081
msgid ""
"Also, if you call the database-altering methods :meth:`~django.db.models."
"fields.related.RelatedManager.add`, :meth:`~django.db.models.fields.related."
"RelatedManager.remove`, :meth:`~django.db.models.fields.related."
"RelatedManager.clear` or :meth:`~django.db.models.fields.related."
"RelatedManager.set`, on :class:`related managers<django.db.models.fields."
"related.RelatedManager>`, any prefetched cache for the relation will be "
"cleared."
msgstr ""

#: ../../ref/models/querysets.txt:1091
msgid "The clearing of the prefetched cache described above was added."
msgstr ""

# 30ec294f1d1b45ef9d561c09d8fbebe9
#: ../../ref/models/querysets.txt:1093
msgid ""
"You can also use the normal join syntax to do related fields of related "
"fields. Suppose we have an additional model to the example above::"
msgstr ""
"Вы можете использовать стандартный синтаксис для обращения к связанным "
"моделям. Например, добавим еще одну модель в пример выше::"

# aa3de7da48e74729858e02c95fdab3ed
#: ../../ref/models/querysets.txt:1100
msgid "The following are all legal:"
msgstr "Можно использовать такой запрос:"

# 0765ed76370c4aac8b32b94a346d58d1
#: ../../ref/models/querysets.txt:1104
msgid ""
"This will prefetch all pizzas belonging to restaurants, and all toppings "
"belonging to those pizzas. This will result in a total of 3 database queries "
"- one for the restaurants, one for the pizzas, and one for the toppings."
msgstr ""
"Этот запрос выполнит предварительную загрузку всех пицц(Pizza) для "
"ресторанов(Restaurant) и всех ингредиентов(Topping) для пицц. В результате "
"будет выполнено 3 запроса - один для Restaurant, один для Pizza, и один для "
"Topping."

# 1bc723b8cd1e47a69ebf5503049d2624
#: ../../ref/models/querysets.txt:1110
#, fuzzy
msgid ""
"This will fetch the best pizza and all the toppings for the best pizza for "
"each restaurant. This will be done in 3 database queries - one for the "
"restaurants, one for the 'best pizzas', and one for the toppings."
msgstr ""
"Это вернет \"best pizza\" и все \"toppings\" для них для каждого ресторана. "
"Будет выполнено 3 запроса."

# 233b470234a044dea1c1a4dc463043f8
#: ../../ref/models/querysets.txt:1114
msgid ""
"Of course, the ``best_pizza`` relationship could also be fetched using "
"``select_related`` to reduce the query count to 2:"
msgstr ""
"Конечно, связь ``best_pizza`` может быть получена через ``select_related``, "
"чтобы уменьшить количество запросов до двух:"

# deae4b56bee74a058123faf94d41f183
#: ../../ref/models/querysets.txt:1119
msgid ""
"Since the prefetch is executed after the main query (which includes the "
"joins needed by ``select_related``), it is able to detect that the "
"``best_pizza`` objects have already been fetched, and it will skip fetching "
"them again."
msgstr ""
"Так как предварительная загрузка выполняется после основного запроса "
"(который включает все необходимые объединения таблиц для обработки "
"``select_related``), она способна определить что объекты ``best_pizza`` уже "
"получены и не выполнит их загрузку снова."

# 89590e17c2a44ebd8b013ceaf3c4d642
#: ../../ref/models/querysets.txt:1123
msgid ""
"Chaining ``prefetch_related`` calls will accumulate the lookups that are "
"prefetched. To clear any ``prefetch_related`` behavior, pass ``None`` as a "
"parameter:"
msgstr ""
"Использование нескольких вызовов ``prefetch_related`` соберет вместе все "
"предварительно загружаемые поля. Чтобы их обнулить, вызовите метод "
"``prefetch_related`` с аргументом ``None``::"

# 46a774303a8e4a7fa40a14a9936f9a7b
#: ../../ref/models/querysets.txt:1129
msgid ""
"One difference to note when using ``prefetch_related`` is that objects "
"created by a query can be shared between the different objects that they are "
"related to i.e. a single Python model instance can appear at more than one "
"point in the tree of objects that are returned. This will normally happen "
"with foreign key relationships. Typically this behavior will not be a "
"problem, and will in fact save both memory and CPU time."
msgstr ""
"Одна особенность вызова ``prefetch_related``, про которую следует упомянуть: "
"объекты созданные в результате выполнения запроса могут быть использованы "
"различными связанными объектами, то есть один экземпляр модели может "
"оказаться более чем в одной точке в дереве возвращенных объектов. Это обычно "
"случается с внешними ключами. Скорее всего это не вызовет никаких проблем, и "
"даже сохранит память и время CPU."

# 0224fa29d695415f9fb9841e6691546c
#: ../../ref/models/querysets.txt:1136
msgid ""
"While ``prefetch_related`` supports prefetching ``GenericForeignKey`` "
"relationships, the number of queries will depend on the data. Since a "
"``GenericForeignKey`` can reference data in multiple tables, one query per "
"table referenced is needed, rather than one query for all the items. There "
"could be additional queries on the ``ContentType`` table if the relevant "
"rows have not already been fetched."
msgstr ""
"Так как ``prefetch_related`` поддерживает предварительную загрузку "
"``GenericForeignKey``, количество запросов зависит от данных. Так как "
"``GenericForeignKey`` может ссылаться на данные из разных таблиц, необходим "
"один запрос на одну таблицу, вместо одного запроса для всех данных. Также "
"может понадобится дополнительный запрос к таблице ``ContentType``, если "
"соответствующие данные еще не загружены."

# 3738fd126f124d05a43e190ffd4e7d1c
#: ../../ref/models/querysets.txt:1143
msgid ""
"``prefetch_related`` in most cases will be implemented using an SQL query "
"that uses the 'IN' operator. This means that for a large ``QuerySet`` a "
"large 'IN' clause could be generated, which, depending on the database, "
"might have performance problems of its own when it comes to parsing or "
"executing the SQL query. Always profile for your use case!"
msgstr ""
"``prefetch_related`` в основном использует оператор 'IN' SQL запроса. Это "
"означает, что для больших ``QuerySet`` может быть создано сложное условие "
"'IN', что, в зависимости от базы данных, может привести к проблемам с "
"производительностью при разборе и выполнении SQL запроса. Всегда "
"анализируйте(profile) ваш запрос!"

# fb07b22e96bf4735aab0e4f4ebac9843
#: ../../ref/models/querysets.txt:1149
msgid ""
"Note that if you use ``iterator()`` to run the query, ``prefetch_related()`` "
"calls will be ignored since these two optimizations do not make sense "
"together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

# e2fe994e98914c0fae0de2156376ce6d
#: ../../ref/models/querysets.txt:1152
msgid ""
"You can use the :class:`~django.db.models.Prefetch` object to further "
"control the prefetch operation."
msgstr ""
"Вы можете использовать объект :class:`~django.db.models.Prefetch` для "
"большего контроля предварительной загрузкой."

# 4051bb4846aa42149f3f9710a874b24a
#: ../../ref/models/querysets.txt:1155
msgid ""
"In its simplest form ``Prefetch`` is equivalent to the traditional string "
"based lookups:"
msgstr ""
"В самом простом варианте ``Prefetch`` аналогичен обычному строковому "
"аргументу:"

# 442d1008dc0b4b28ad65f8d8187313ca
#: ../../ref/models/querysets.txt:1161
msgid ""
"You can provide a custom queryset with the optional ``queryset`` argument. "
"This can be used to change the default ordering of the queryset:"
msgstr ""
"Вы можете указать свой ``QuerySet`` в необязательном аргументе ``queryset``. "
"Это позволяет переопределить сортировку по умолчанию:"

# 0957cd7231384b5090623ddc85668277
#: ../../ref/models/querysets.txt:1167
msgid ""
"Or to call :meth:`~django.db.models.query.QuerySet.select_related()` when "
"applicable to reduce the number of queries even further:"
msgstr ""
"Или вызывать при возможности :meth:`~django.db.models.query.QuerySet."
"select_related()`, чтобы уменьшить количество запросов еще больше:"

# 552ab47663c54d8d9ecdf6263324fe4c
#: ../../ref/models/querysets.txt:1173
msgid ""
"You can also assign the prefetched result to a custom attribute with the "
"optional ``to_attr`` argument. The result will be stored directly in a list."
msgstr ""
"Можно также результат сохранить другом атрибуте, указав название в аргументе "
"``to_attr``. Результат будет сохранен непосредственно в списке."

# 3eca0cf340e047e7b0fb9411a2a290be
#: ../../ref/models/querysets.txt:1176
msgid ""
"This allows prefetching the same relation multiple times with a different "
"``QuerySet``; for instance:"
msgstr ""
"Это позволяет выполнить предварительную загрузку несколько раз для одной "
"связи, используя разные ``QuerySet``. Например:"

# 2c3696c3231149a8b6868c4d8b08da90
#: ../../ref/models/querysets.txt:1184
msgid ""
"Lookups created with custom ``to_attr`` can still be traversed as usual by "
"other lookups:"
msgstr ""
"Результат с собственным ``to_attr`` может использоваться в аргументах "
"запроса:"

# e2ca428d3ff04e25aaa4a40b4f62659d
#: ../../ref/models/querysets.txt:1192
msgid ""
"Using ``to_attr`` is recommended when filtering down the prefetch result as "
"it is less ambiguous than storing a filtered result in the related manager's "
"cache:"
msgstr ""
"Использование ``to_attr`` рекомендуется при фильтрации результата "
"предварительной загрузки т.к. это менее двусмысленно, чем сохранение "
"результата фильтрации в кэше связывающего менеджера:"

# b6dd7215109649ba9aca0759fdd2e57c
#: ../../ref/models/querysets.txt:1207
msgid ""
"Custom prefetching also works with single related relations like forward "
"``ForeignKey`` or ``OneToOneField``. Generally you'll want to use :meth:"
"`select_related()` for these relations, but there are a number of cases "
"where prefetching with a custom ``QuerySet`` is useful:"
msgstr ""
"Предварительная загрузка работает и для связей один ко многим, таких как "
"``ForeignKey`` или ``OneToOneField``. Обычно для них используется :meth:"
"`select_related()`, но есть несколько случаев, когда может быть полезна "
"предварительная загрузка с собственным ``QuerySet``:"

# d003fd311a38423d9efc0db46a261c9a
#: ../../ref/models/querysets.txt:1212
msgid ""
"You want to use a ``QuerySet`` that performs further prefetching on related "
"models."
msgstr ""
"Вы хотите использовать ``QuerySet``, который выполняет предварительную "
"загрузку для связанной модели."

# 5cc1d74b4d0b4c69818f569f2b0df3d7
#: ../../ref/models/querysets.txt:1215
msgid "You want to prefetch only a subset of the related objects."
msgstr "Вы хотите загрузить только часть связанных объектов."

# b6db7bd0b7e04a8f841bd7d1cd31cf81
#: ../../ref/models/querysets.txt:1217
msgid ""
"You want to use performance optimization techniques like :meth:`deferred "
"fields <defer()>`:"
msgstr ""
"Вы хотите оптимизировать запрос, :meth:`отфильтровав часть полей <defer()>`:"

# 8f7c4b1b400b4120b9e1e8f2056704fa
#: ../../ref/models/querysets.txt:1227
msgid "The ordering of lookups matters."
msgstr "Порядок аргументов имеет значение."

# 248e3fa46c6d4b0f803835cc5e32b274
#: ../../ref/models/querysets.txt:1229
msgid "Take the following examples:"
msgstr "Возьмем следующие примеры::"

# f8829ccd114f49cdb0961858f7b27778
#: ../../ref/models/querysets.txt:1233
msgid ""
"This works even though it's unordered because ``'pizzas__toppings'`` already "
"contains all the needed information, therefore the second argument "
"``'pizzas'`` is actually redundant."
msgstr ""
"В это примере ``'pizzas__toppings'`` уже получает всю необходимую "
"информацию, поэтому ``'pizzas'`` лишний. (FIXME)"

# 054c62e9a0bd4a89a777c3c2bc5c18d7
#: ../../ref/models/querysets.txt:1239
msgid ""
"This will raise a ``ValueError`` because of the attempt to redefine the "
"queryset of a previously seen lookup. Note that an implicit queryset was "
"created to traverse ``'pizzas'`` as part of the ``'pizzas__toppings'`` "
"lookup."
msgstr ""
"Вызовет ``ValueError`` при попытке подменить ``QuerySet`` предыдущей "
"перезагрузки. Обратите внимание, неявно был создан ``QuerySet`` ``'pizzas'`` "
"для ``'pizzas__toppings'``."

# 9c0cf7801dec47b2a38a9daf95f42d86
#: ../../ref/models/querysets.txt:1246
msgid ""
"This will trigger an ``AttributeError`` because ``'pizza_list'`` doesn't "
"exist yet when ``'pizza_list__toppings'`` is being processed."
msgstr ""
"Вызовет ``AttributeError`` т.к. ``'pizza_list'`` еще не существует при "
"обработке ``'pizza_list__toppings'``."

# 41b2758567d94e2bb7d35903d192feed
#: ../../ref/models/querysets.txt:1249
msgid ""
"This consideration is not limited to the use of ``Prefetch`` objects. Some "
"advanced techniques may require that the lookups be performed in a specific "
"order to avoid creating extra queries; therefore it's recommended to always "
"carefully order ``prefetch_related`` arguments."
msgstr ""
"Эти замечания относятся не только к использованию объектов ``Prefetch``. "
"Продвинутые запросы требуют внимания, чтобы избежать лишних запросов. Но "
"особенно внимательно следует относится к порядку аргументов для "
"``prefetch_related``."

# 3de60b9d93e9467288b16597a3aeafd4
#: ../../ref/models/querysets.txt:1255
#, fuzzy
msgid "``extra()``"
msgstr "``**extra``"

# d259661cdd444f0e8c4d38c129301258
#: ../../ref/models/querysets.txt:1259
msgid ""
"Sometimes, the Django query syntax by itself can't easily express a complex "
"``WHERE`` clause. For these edge cases, Django provides the ``extra()`` "
"``QuerySet`` modifier — a hook for injecting specific clauses into the SQL "
"generated by a ``QuerySet``."
msgstr ""
"Иногда, стандартных возможностей Django не хватает для создания сложного "
"условия ``WHERE`` запроса. Для таких случаев, Django предоставляет метод "
"``extra()`` ``QuerySet`` — метод позволяющий изменять  SQL сгенерированный "
"``QuerySet``."

#: ../../ref/models/querysets.txt:1264
msgid "Use this method as a last resort"
msgstr "Используйте этот метод в крайнем случае"

#: ../../ref/models/querysets.txt:1266
msgid ""
"This is an old API that we aim to deprecate at some point in the future. Use "
"it only if you cannot express your query using other queryset methods. If "
"you do need to use it, please `file a ticket <https://code.djangoproject.com/"
"newticket>`_ using the `QuerySet.extra keyword <https://code.djangoproject."
"com/query?status=assigned&status=new&keywords=~QuerySet.extra>`_ with your "
"use case (please check the list of existing tickets first) so that we can "
"enhance the QuerySet API to allow removing ``extra()``. We are no longer "
"improving or fixing bugs for this method."
msgstr ""
"Это старый API, который мы собираемся удалить в будущем. Используйте его, "
"только если другие методы ``QuerySet`` вам не помогают. Если вам пришлось "
"использовать этот метод, просим `создать \"тикет\" <https://code."
"djangoproject.com/newticket>`_, используя `тег QuerySet.extra <https://code."
"djangoproject.com/query?status=assigned&status=new&keywords=~QuerySet."
"extra>`_, и описать ваш случай (просим для начала ознакомиться с "
"существующим списком случаев), чтобы мы могли улучшить QuerySet API, и "
"удалить ``extra()``. Мы больше не улучшаем и не исправляем ошибки для этого "
"метода."

#: ../../ref/models/querysets.txt:1275
msgid "For example, this use of ``extra()``::"
msgstr "Например, это использование ``extra()``::"

# 46ea26d2a9f244268a100e9407d40d85
# 92ad5423ba9541819e942c734c6e7666
# 03305512d68f48819d082dcdf473db96
# 5c74e2dcd6d444c9a19dc3c73f649aa4
# 5aa8d6e8618c48c3be94d5c26a271fc5
# 48d1b44753ff4301be6c7f0f193e237d
# 905fc69346a2456babd76b663155d0c2
# 049c7c7798ce4d2a9b2f4e073e1dba4a
# 09afe94e5a654a16bfc456dc68636596
# 4a393b64d51d47eea9b79c0d803d4108
# 17e3207b845540da8abb27b21bdff0d4
# d64f76ce7139449695a255ca3fd0764d
# 7951d6720d58440a904b19337aac5c5c
# 8379281c0c194dfe8d56ed8b7c2dd56f
# c28ee383e69e4fc2bf54dfbf03ea8dcb
#: ../../ref/models/querysets.txt:1282
msgid "is equivalent to::"
msgstr "аналогично::"

#: ../../ref/models/querysets.txt:1286
msgid ""
"The main benefit of using :class:`~django.db.models.expressions.RawSQL` is "
"that you can set ``output_field`` if needed. The main downside is that if "
"you refer to some table alias of the queryset in the raw SQL, then it is "
"possible that Django might change that alias (for example, when the queryset "
"is used as a subquery in yet another query)."
msgstr ""
"Главный плюс использования :class:`~django.db.models.expressions.RawSQL` в "
"том, что вы можете указать ``output_field`` при необходимости. Главный минус "
"-- если вы будете использовать метку какой-то таблицы из ``QuerySet`` в SQL, "
"возможен случай, когда Django может изменить эту метку (например, если "
"``QuerySet`` используется как под-запрос в другом запросе)."

# e12d9fe4df4040b8b512c544e4d0dfec
#: ../../ref/models/querysets.txt:1294
#, fuzzy
msgid ""
"You should be very careful whenever you use ``extra()``. Every time you use "
"it, you should escape any parameters that the user can control by using "
"``params`` in order to protect against SQL injection attacks."
msgstr ""
"Вы должны быть предельно осторожны при использовании ``extra()``. Необходимо "
"экранировать все аргументы с помощью ``params``, которые передает "
"пользователь, чтобы избежать SQL-инъекций. Смотрите раздел о :ref:`защите от "
"SQL-инъекций <sql-injection-protection>`."

#: ../../ref/models/querysets.txt:1298
msgid ""
"You also must not quote placeholders in the SQL string. This example is "
"vulnerable to SQL injection because of the quotes around ``%s``::"
msgstr ""

#: ../../ref/models/querysets.txt:1303
msgid ""
"You can read more about how Django's :ref:`SQL injection protection <sql-"
"injection-protection>` works."
msgstr ""

# 06b847bf877049b8b0e89f52e3b22595
#: ../../ref/models/querysets.txt:1306
msgid ""
"By definition, these extra lookups may not be portable to different database "
"engines (because you're explicitly writing SQL code) and violate the DRY "
"principle, so you should avoid them if possible."
msgstr ""
"По определению, дополнительные параметры поиска определенные в ``extra()`` "
"не переносимы между различными типами данных(потому что вы используете "
"непосредственно SQL) и нарушает принцип DRY, поэтому вы должны избегать "
"использование этого метода."

# c4b07a1884d34cadb7a66854fbe8015d
#: ../../ref/models/querysets.txt:1310
msgid ""
"Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None "
"of the arguments is required, but you should use at least one of them."
msgstr ""
"Укажите одни или несколько параметров ``params``, ``select``, ``where`` или "
"``tables``. Ни один из аргументов не обязателен, но вы должны указать хотя "
"бы один."

# d477098199c549dea385dbc618304381
#: ../../ref/models/querysets.txt:1313
msgid "``select``"
msgstr "``select``"

# e2677340436845e38f1c1eeadc0f6b3f
#: ../../ref/models/querysets.txt:1315
msgid ""
"The ``select`` argument lets you put extra fields in the ``SELECT`` clause.  "
"It should be a dictionary mapping attribute names to SQL clauses to use to "
"calculate that attribute."
msgstr ""
"Параметр ``select`` позволяет добавить дополнительные поля в ``SELECT``. Это "
"должен быть словарь отображающий названия атрибутов и выражение SQL для "
"вычисления значения этого атрибута."

# fafc90c64c654582b9d9e27bf6a470e9
#: ../../ref/models/querysets.txt:1323
msgid ""
"As a result, each ``Entry`` object will have an extra attribute, "
"``is_recent``, a boolean representing whether the entry's ``pub_date`` is "
"greater than Jan. 1, 2006."
msgstr ""
"В результате, каждый объект ``Entry`` будет содержать дополнительный "
"атрибут, ``is_recent``, булево значение определяющее больше ли значение "
"``pub_date`` чем 1 января 2006."

# f74fe8ea7ff94428a66e466b3fca6b38
#: ../../ref/models/querysets.txt:1327
msgid ""
"Django inserts the given SQL snippet directly into the ``SELECT`` statement, "
"so the resulting SQL of the above example would be something like::"
msgstr ""
"Django вставит добавленный кусок SQL непосредственно в оператор ``SELECT``, "
"полученный SQL выглядит таким образом::"

# 311cf9d3932c448a9198013546ec6801
#: ../../ref/models/querysets.txt:1335
msgid ""
"The next example is more advanced; it does a subquery to give each resulting "
"``Blog`` object an ``entry_count`` attribute, an integer count of associated "
"``Entry`` objects::"
msgstr ""
"Следующий пример сложнее. Он добавляет подзапрос, чтобы добавить каждому "
"объекту ``Blog`` атрибут ``entry_count``, который равен количеству связанных "
"объектов ``Entry``::"

# 963282dfaebf4a4d90d8ffed765150a2
#: ../../ref/models/querysets.txt:1345
msgid ""
"In this particular case, we're exploiting the fact that the query will "
"already contain the ``blog_blog`` table in its ``FROM`` clause."
msgstr ""
"В это примере, мы используем тот факт, что запрос уже будет содержать "
"таблицу ``blog_blog`` в операторе ``FROM``."

# dd1c35b12b744f459c6310f3c405b46a
#: ../../ref/models/querysets.txt:1348
msgid "The resulting SQL of the above example would be::"
msgstr "Полученный SQL запрос выглядит таким образом::"

# d833e4e577c646539ca26fafe4303729
#: ../../ref/models/querysets.txt:1353
msgid ""
"Note that the parentheses required by most database engines around "
"subqueries are not required in Django's ``select`` clauses. Also note that "
"some database backends, such as some MySQL versions, don't support "
"subqueries."
msgstr ""
"Заметим, что скобки вокруг подзапроса, обязательные для некоторых баз "
"данных, не обязательны для параметра ``select`` в Django. Также заметим, что "
"некоторые типы баз данных, такие как некоторые версии MySQL, не поддерживают "
"подзапросы."

# c8f82a29773e419780c274f05434651e
#: ../../ref/models/querysets.txt:1358
msgid ""
"In some rare cases, you might wish to pass parameters to the SQL fragments "
"in ``extra(select=...)``. For this purpose, use the ``select_params`` "
"parameter. Since ``select_params`` is a sequence and the ``select`` "
"attribute is a dictionary, some care is required so that the parameters are "
"matched up correctly with the extra select pieces. In this situation, you "
"should use a :class:`collections.OrderedDict` for the ``select`` value, not "
"just a normal Python dictionary."
msgstr ""
"В некоторых редких случаях, вам понадобится передать параметры в фрагмент "
"SQL из ``extra(select=...)``. Для этого, используйте параметр "
"``select_params``. Так как ``select_params`` это последовательность, а "
"атрибут ``select`` словарь, необходима некоторая внимательность, чтобы "
"параметры корректно были добавлены в оператор ``SELECT``. В этом случае "
"следует использовать a :class:`collections.OrderedDict` для значения "
"``select``, вместо обычного словаря Python."

# 1923cc211ba8437b90a6ca5321cef560
#: ../../ref/models/querysets.txt:1366
msgid "This will work, for example::"
msgstr "Например::"

#: ../../ref/models/querysets.txt:1372
msgid ""
"If you need to use a literal ``%s`` inside your select string, use the "
"sequence ``%%s``."
msgstr ""
"Если вам необходимо использовать ``%s`` в запрашиваемой строке, используйте "
"``%%s``."

# c89f9dbedbe2441c8c70b5ba0f33f091
#: ../../ref/models/querysets.txt:1375
msgid "``where`` / ``tables``"
msgstr "``where`` / ``tables``"

# 8ff13dbb2f414cd0b147bb464f97f439
#: ../../ref/models/querysets.txt:1377
msgid ""
"You can define explicit SQL ``WHERE`` clauses — perhaps to perform non-"
"explicit joins — by using ``where``. You can manually add tables to the SQL "
"``FROM`` clause by using ``tables``."
msgstr ""
"Вы можете добавить оператор SQL ``WHERE`` — возможно для выполнения не "
"явного объединения таблиц — by using ``where``. Используя параметр "
"``tables`` можно добавить таблицы в оператор SQL ``FROM``."

# 15c331c702b043e68d0e634bb76a0727
#: ../../ref/models/querysets.txt:1381
msgid ""
"``where`` and ``tables`` both take a list of strings. All ``where`` "
"parameters are \"AND\"ed to any other search criteria."
msgstr ""
"``where`` и ``tables`` принимают список строк. Все параметры ``where`` будут "
"добавлены к остальным критериям через оператор \"AND\" ."

# e1286287c0154eb1b785dcebbcdec4e8
#: ../../ref/models/querysets.txt:1388
msgid "...translates (roughly) into the following SQL::"
msgstr "...будет переведено (примерно) в следующий SQL::"

# 713d4dbee21f487bb2fa345c5d1f24b9
#: ../../ref/models/querysets.txt:1392
msgid ""
"Be careful when using the ``tables`` parameter if you're specifying tables "
"that are already used in the query. When you add extra tables via the "
"``tables`` parameter, Django assumes you want that table included an extra "
"time, if it is already included. That creates a problem, since the table "
"name will then be given an alias. If a table appears multiple times in an "
"SQL statement, the second and subsequent occurrences must use aliases so the "
"database can tell them apart. If you're referring to the extra table you "
"added in the extra ``where`` parameter this is going to cause errors."
msgstr ""
"Будьте внимательны при добавлении в параметр ``tables`` таблиц, которые уже "
"используются запросом. В таком случае Django предполагает, что вы хотите "
"добавить их повторно. Это создает проблему, т.к. таблица будет добавлена с "
"псевдонимом(an alias). Если таблица несколько раз используется в запросе, "
"второй и последующие вхождения должны использовать псевдонимы, чтобы база "
"данных могла различить их. При обращении к добавленной таблице в параметре "
"``where`` вы получите ошибку."

# 842b9a6d4fac4b8d8ab926eefa4f72ac
#: ../../ref/models/querysets.txt:1402
msgid ""
"Normally you'll only be adding extra tables that don't already appear in the "
"query. However, if the case outlined above does occur, there are a few "
"solutions. First, see if you can get by without including the extra table "
"and use the one already in the query. If that isn't possible, put your "
"``extra()`` call at the front of the queryset construction so that your "
"table is the first use of that table. Finally, if all else fails, look at "
"the query produced and rewrite your ``where`` addition to use the alias "
"given to your extra table. The alias will be the same each time you "
"construct the queryset in the same way, so you can rely upon the alias name "
"to not change."
msgstr ""
"Скорее всего вы будете использовать дополнительные таблицы, которые еще не "
"добавлены в запрос. Однако, если все таки возникнет описанная выше ситуация, "
"существует несколько способов ее решить. Первый, посмотрите возможно ли "
"использовать уже добавленную в запрос таблицу. Если это не возможно, "
"используйте вызов ``extra()`` в начале конструкции запроса, чтобы ваша "
"таблица использовалась первой. В конце концов, если каким-то образом все "
"остальное вам не помогло, посмотрите на созданный запрос и перепишите "
"параметр ``where`` таким образом, чтобы использовался псевдоним назначенный "
"дополнительной таблице. При одинаковом способе создать запрос псевдоним "
"будет всегда не измененным."

# 1a5e940cb73b484ca39666c8fa38f4df
#: ../../ref/models/querysets.txt:1413
msgid "``order_by``"
msgstr "``order_by``"

# 65361163de7e445db05dc6a18d46b3e5
#: ../../ref/models/querysets.txt:1415
msgid ""
"If you need to order the resulting queryset using some of the new fields or "
"tables you have included via ``extra()`` use the ``order_by`` parameter to "
"``extra()`` and pass in a sequence of strings. These strings should either "
"be model fields (as in the normal :meth:`order_by()` method on querysets), "
"of the form ``table_name.column_name`` or an alias for a column that you "
"specified in the ``select`` parameter to ``extra()``."
msgstr ""
"Если вам необходимо отсортировать полученный ``QuerySet`` используя новые "
"поля или таблицы, которые вы добавили через ``extra()``, используйте "
"параметр ``order_by`` передав последовательность строк. Эти строки должны "
"быть полями модели (как и в обычном методе :meth:`order_by()`), в формате "
"``table_name.column_name`` или псевдонимы колонок которые вы указали в "
"параметре ``select`` при вызове ``extra()``."

# b7ff1c442c394f2182b9b9bd354ac00d
#: ../../ref/models/querysets.txt:1428
msgid ""
"This would sort all the items for which ``is_recent`` is true to the front "
"of the result set (``True`` sorts before ``False`` in a descending ordering)."
msgstr ""
"Это запрос должен отсортировать все записи, у которых ``is_recent`` равен "
"``True``, перед остальными записями (``True`` следует перед ``False`` при "
"ниспадающей сортировке)."

# f03db6ccfc0f4194a54586b94ab8477a
#: ../../ref/models/querysets.txt:1432
msgid ""
"This shows, by the way, that you can make multiple calls to ``extra()`` and "
"it will behave as you expect (adding new constraints each time)."
msgstr ""
"Вы можете заметить, между прочим, что можно выполнить несколько вызовов "
"``extra()`` (добавляя новые параметры каждый раз)."

# 9e193718998d4537860ecf5b0b8cba65
#: ../../ref/models/querysets.txt:1435
msgid "``params``"
msgstr "``params``"

# bb4b27c71c0f4cc2a4146feaa9e1b6be
#: ../../ref/models/querysets.txt:1437
msgid ""
"The ``where`` parameter described above may use standard Python database "
"string placeholders — ``'%s'`` to indicate parameters the database engine "
"should automatically quote. The ``params`` argument is a list of any extra "
"parameters to be substituted."
msgstr ""
"Параметр ``where`` описанный выше может использовать стандартный синтаксис "
"Python подстановки параметров в строку — ``'%s'``, чтобы указать какие "
"параметры должны быть экранированы базой данных. Аргумент ``params`` это "
"список дополнительных параметров, которые будут подставлены в условие "
"``where``."

# 7d12b53fac8047c6bb0e88e741a2b18b
#: ../../ref/models/querysets.txt:1446
msgid ""
"Always use ``params`` instead of embedding values directly into ``where`` "
"because ``params`` will ensure values are quoted correctly according to your "
"particular backend. For example, quotes will be escaped correctly."
msgstr ""
"Всегда используйте ``params`` вместо добавления значений непосредственно в "
"``where`` т.к. ``params`` гарантирует, что все значения будут экранированы в "
"соответствиями с синтаксисом используемой базы данных. Например, кавычки "
"будут экранированы правильно."

# 20cd30fc891c435583d2d1a75a857de9
#: ../../ref/models/querysets.txt:1451
msgid "Bad::"
msgstr "Не верно::"

# 2cada5cb69334006baed723e8a319829
#: ../../ref/models/querysets.txt:1455
msgid "Good::"
msgstr "Верно::"

# 4cbfc9eda2504e0ab79ab558a9d914b4
#: ../../ref/models/querysets.txt:1461
msgid ""
"If you are performing queries on MySQL, note that MySQL's silent type "
"coercion may cause unexpected results when mixing types. If you query on a "
"string type column, but with an integer value, MySQL will coerce the types "
"of all values in the table to an integer before performing the comparison. "
"For example, if your table contains the values ``'abc'``, ``'def'`` and you "
"query for ``WHERE mycolumn=0``, both rows will match. To prevent this, "
"perform the correct typecasting before using the value in a query."
msgstr ""
"Выполняя запрос в MySQL, обратите внимание на преобразование типов. Если  вы "
"выполняете запрос по текстовому полю, но используете числовое значение, "
"MySQL преобразует все значения поля в число перед сравнением. Например, если "
"таблица содержит значения ``'abc'``, ``'def'`` и в запросе ``WHERE "
"mycolumn=0``, обе строки попадут в результат. Чтобы избежать этого, "
"используйте значение правильного типа в запросе."

# 3afdacafdbad455b9e1e7a53ec7b6031
#: ../../ref/models/querysets.txt:1470
#, fuzzy
msgid "``defer()``"
msgstr "defer"

# 5fb61d8241314a7d8629423a425a203d
#: ../../ref/models/querysets.txt:1474
msgid ""
"In some complex data-modeling situations, your models might contain a lot of "
"fields, some of which could contain a lot of data (for example, text "
"fields), or require expensive processing to convert them to Python objects. "
"If you are using the results of a queryset in some situation where you don't "
"know if you need those particular fields when you initially fetch the data, "
"you can tell Django not to retrieve them from the database."
msgstr ""
"При сложной структуре данных модели могут содержать большое количество "
"полей, некоторые из которых могут содержать большие объемы данных(например, "
"текстовые поля), или использовать ресурсоемкий процесс преобразования данных "
"в объекты Python. Если вы точно знаете, что данные этих полей не будут "
"использоваться при работе с результатами запроса, вы можете указать Django "
"не выбирать эти поля из базы данных."

# 8a7ee38eda6e48f5a857685809cadd15
#: ../../ref/models/querysets.txt:1481
msgid ""
"This is done by passing the names of the fields to not load to ``defer()``::"
msgstr ""
"Это делается передачей названия полей, которые не должны быть загружены, в "
"метод ``defer()``::"

# 5043e37328554995a7a9d3bef5998780
#: ../../ref/models/querysets.txt:1485
msgid ""
"A queryset that has deferred fields will still return model instances. Each "
"deferred field will be retrieved from the database if you access that field "
"(one at a time, not all the deferred fields at once)."
msgstr ""
"Результат все также будет содержать объекты модели. Каждое не выбранное поле "
"будет получено из базы данных при обращении к нему (одна за раз, не все "
"\"отложенные\" поля сразу)."

# 2414a9daaa19429ea819d61b4dcac085
#: ../../ref/models/querysets.txt:1489
msgid ""
"You can make multiple calls to ``defer()``. Each call adds new fields to the "
"deferred set::"
msgstr ""
"Вы можете выполнить несколько вызовов ``defer()``. Каждый вызов добавит "
"новые поля в список \"отложенных\"::"

# 9b26c911e7364b98a3df1e2144bf0fee
#: ../../ref/models/querysets.txt:1495
msgid ""
"The order in which fields are added to the deferred set does not matter. "
"Calling ``defer()`` with a field name that has already been deferred is "
"harmless (the field will still be deferred)."
msgstr ""
"Порядок добавления полей не имеет значения. Вызов ``defer()`` с полем, "
"которое уже было добавлено в список \"отложенных\", ничего не изменит (поле "
"все также не будет выбираться из базы данных)."

# e3730cc7e91a4db8947ac048149bbce2
#: ../../ref/models/querysets.txt:1499
msgid ""
"You can defer loading of fields in related models (if the related models are "
"loading via :meth:`select_related()`) by using the standard double-"
"underscore notation to separate related fields::"
msgstr ""
"Вы можете указать поля связанных моделей (если эти модели загружаются через :"
"meth:`select_related()`) используя стандартный синтаксис двух нижних "
"подчеркиваний для разделения полей::"

# 4d3acc1cb7244585844db63a13fa8a8b
#: ../../ref/models/querysets.txt:1505
msgid ""
"If you want to clear the set of deferred fields, pass ``None`` as a "
"parameter to ``defer()``::"
msgstr ""
"Если вы хотите очистить список \"отложенных\" полей, передайте ``None`` как "
"параметр для ``defer()``::"

# 679b9e44b8f3487ba32aa4f4ba9a4f3c
#: ../../ref/models/querysets.txt:1511
msgid ""
"Some fields in a model won't be deferred, even if you ask for them. You can "
"never defer the loading of the primary key. If you are using :meth:"
"`select_related()` to retrieve related models, you shouldn't defer the "
"loading of the field that connects from the primary model to the related "
"one, doing so will result in an error."
msgstr ""
"Некоторые поля всегда будут выбираться из базы данных, даже если вы их "
"добавите в вызов ``defer()``. Всегда выбирается первичный ключ. Используя :"
"meth:`select_related()` для получения связанных моделей, не \"откладывайте\" "
"загрузку связывающего поля иначе получите ошибку."

# 8c60db197c4d46d29ef25f0c8e5ffed7
#: ../../ref/models/querysets.txt:1519
msgid ""
"The ``defer()`` method (and its cousin, :meth:`only()`, below) are only for "
"advanced use-cases. They provide an optimization for when you have analyzed "
"your queries closely and understand *exactly* what information you need and "
"have measured that the difference between returning the fields you need and "
"the full set of fields for the model will be significant."
msgstr ""
"Метод ``defer()`` (и его \"коллега\" :meth:`only()`) предназначены только "
"для опытных пользователей. Они предоставляют возможность оптимизировать "
"запрос. Но для начала вам следует проанализировать его, *точно* определить "
"какие данные вам необходимы и удостовериться, что разница между получением "
"всех полей и получением определенных, будет значительной."

# 86de8b7daf0c424ebf32ea779c4f9355
#: ../../ref/models/querysets.txt:1525
msgid ""
"Even if you think you are in the advanced use-case situation, **only use "
"defer() when you cannot, at queryset load time, determine if you will need "
"the extra fields or not**. If you are frequently loading and using a "
"particular subset of your data, the best choice you can make is to normalize "
"your models and put the non-loaded data into a separate model (and database "
"table). If the columns *must* stay in the one table for some reason, create "
"a model with ``Meta.managed = False`` (see the :attr:`managed attribute "
"<django.db.models.Options.managed>` documentation) containing just the "
"fields you normally need to load and use that where you might otherwise call "
"``defer()``. This makes your code more explicit to the reader, is slightly "
"faster and consumes a little less memory in the Python process."
msgstr ""
"Даже если вы думаете, что у вас сложная ситуация требующая использовать "
"``defer()``, используйте его только будучи уверенным, что \"отложенные\" "
"поля не понадобятся далее в коде. Если вы часто загружаете и используете "
"только часть полей, лучшим решением будет нормализировать модели и вынести "
"не загружаемые поля в отдельную модель(и таблицу базы данных). Если поля "
"*должны* по каким-то причинам находится в одной таблице, создайте модель с "
"``Meta.managed = False`` (смотрите документацию о :attr:`managed attribute "
"<django.db.models.Options.managed>`) содержащую только используемые поля, и "
"используйте ее вместо ``defer()``. Это делает ваш код более читабельным, "
"немного быстрее и экономит немного памяти используемой процессом Python."

#: ../../ref/models/querysets.txt:1538
msgid ""
"For example, both of these models use the same underlying database table::"
msgstr "Например, обе эти модели используют одну таблицу в базе данных::"

#: ../../ref/models/querysets.txt:1558
msgid ""
"If many fields need to be duplicated in the unmanaged model, it may be best "
"to create an abstract model with the shared fields and then have the "
"unmanaged and managed models inherit from the abstract model."
msgstr ""
"Если необходимо продублировать большое количество полей, возможно лучше "
"создать абстрактную модель со всеми полями, и наследовать обе модели от неё."

# d10c44560a604b16a8175e4fac57031a
# 5f5f007b756449fe9e963847fc4aa688
#: ../../ref/models/querysets.txt:1564 ../../ref/models/querysets.txt:1613
msgid ""
"When calling :meth:`~django.db.models.Model.save()` for instances with "
"deferred fields, only the loaded fields will be saved. See :meth:`~django.db."
"models.Model.save()` for more details."
msgstr ""
"При вызове :meth:`~django.db.models.Model.save()` для объектов с отложенными "
"полями, только загруженные поля будут сохранены. Подробности смотрите в "
"описании :meth:`~django.db.models.Model.save()`."

#: ../../ref/models/querysets.txt:1569
msgid "``only()``"
msgstr ""

# 9c86c8cdfbd645e2986802c35fcd31ce
#: ../../ref/models/querysets.txt:1573
msgid ""
"The ``only()`` method is more or less the opposite of :meth:`defer()`. You "
"call it with the fields that should *not* be deferred when retrieving a "
"model.  If you have a model where almost all the fields need to be deferred, "
"using ``only()`` to specify the complementary set of fields can result in "
"simpler code."
msgstr ""
"Метод ``only()``-- противоположность метода :meth:`defer()`. Вызывайте его с "
"полями, получение которых *не* должно быть отложено.  Если у вас есть "
"модель, почти все поля которой не должны выбираться из базы данных, "
"используйте ``only()``. Это сделает ваш код проще."

# 3609e904db4c4df0b4bcfe0dcb3c6e62
#: ../../ref/models/querysets.txt:1579
msgid ""
"Suppose you have a model with fields ``name``, ``age`` and ``biography``. "
"The following two querysets are the same, in terms of deferred fields::"
msgstr ""
"Например, у вас есть модель с полями ``name``, ``age`` и ``biography``. Эти "
"два запроса идентичны в плане полученных полей::"

# 08006732a6df4c2f826a7c5677070617
#: ../../ref/models/querysets.txt:1585
msgid ""
"Whenever you call ``only()`` it *replaces* the set of fields to load "
"immediately. The method's name is mnemonic: **only** those fields are loaded "
"immediately; the remainder are deferred. Thus, successive calls to "
"``only()`` result in only the final fields being considered::"
msgstr ""
"При вызове ``only()`` будет *заменено* множество загружаемых полей. Название "
"метода говорит само за себя: **только** эти поля должны быть загружены; все "
"остальные -- \"отложены\". Таким образом при последовательном вызове "
"``only()`` несколько раз, только поля из последнего вызова будут загружены::"

# 289793a330b14607b189dae4cfb8c2f5
#: ../../ref/models/querysets.txt:1593
msgid ""
"Since ``defer()`` acts incrementally (adding fields to the deferred list), "
"you can combine calls to ``only()`` and ``defer()`` and things will behave "
"logically::"
msgstr ""
"Так как ``defer()`` добавляет поля в список \"отложенных\" при множественном "
"вызове, вы можете совмещать вызовы ``only()`` и ``defer()``, что будет "
"работать вполне логично::"

# dee05b337045471ca43bce707de47a2a
#: ../../ref/models/querysets.txt:1604
msgid ""
"All of the cautions in the note for the :meth:`defer` documentation apply to "
"``only()`` as well. Use it cautiously and only after exhausting your other "
"options."
msgstr ""
"Все замечания описанные для метода :meth:`defer` применимы и к методу "
"``only()``. Используйте его с осторожностью и только в отсутствии других "
"вариантов."

# dda20bf37c8b490e83357a8d0dd0c3b2
#: ../../ref/models/querysets.txt:1608
msgid ""
"Using :meth:`only` and omitting a field requested using :meth:"
"`select_related` is an error as well."
msgstr ""
"При использовании :meth:`only` без полей, указанных в :meth:"
"`select_related`, будет вызвано исключение."

# be693002305d4620b81f6195a5f605e7
#: ../../ref/models/querysets.txt:1618
#, fuzzy
msgid "``using()``"
msgstr "using"

# 095673642a8347009402505bb8f4a742
#: ../../ref/models/querysets.txt:1622
msgid ""
"This method is for controlling which database the ``QuerySet`` will be "
"evaluated against if you are using more than one database.  The only "
"argument this method takes is the alias of a database, as defined in :"
"setting:`DATABASES`."
msgstr ""
"Этот метод контролирует какую базу данных будет использовать ``QuerySet`` "
"для запроса, если вы используете несколько баз данных.  Единственный "
"аргумент это псевдоним базы данных указанный в настройке проекта :setting:"
"`DATABASES`."

# a20c8197c2c240d6a5dfa723b62c89b9
#: ../../ref/models/querysets.txt:1636
#, fuzzy
msgid "``select_for_update()``"
msgstr "select_for_update"

# 0e55c2aba7894748bc2d007c5f1ad3ab
#: ../../ref/models/querysets.txt:1640
msgid ""
"Returns a queryset that will lock rows until the end of the transaction, "
"generating a ``SELECT ... FOR UPDATE`` SQL statement on supported databases."
msgstr ""
"Возвращает ``QuerySet``, блокирующий записи до завершения транзакции, "
"используя оператор SQL ``SELECT ... FOR UPDATE`` используемой базы данных."

# 0792902df92a4a47812cba16662d35a0
#: ../../ref/models/querysets.txt:1647
msgid ""
"All matched entries will be locked until the end of the transaction block, "
"meaning that other transactions will be prevented from changing or acquiring "
"locks on them."
msgstr ""
"Все, удовлетворяющие фильтрам, строки будут заблокированы до завершения "
"транзакции, то есть другие транзакции не смогут изменить или заблокировать "
"это строки."

# 95d7fbe01a0446028ce3ab946096fc9a
#: ../../ref/models/querysets.txt:1651
#, fuzzy
msgid ""
"Usually, if another transaction has already acquired a lock on one of the "
"selected rows, the query will block until the lock is released. If this is "
"not the behavior you want, call ``select_for_update(nowait=True)``. This "
"will make the call non-blocking. If a conflicting lock is already acquired "
"by another transaction, :exc:`~django.db.DatabaseError` will be raised when "
"the queryset is evaluated. You can also ignore locked rows by using "
"``select_for_update(skip_locked=True)`` instead. The ``nowait`` and "
"``skip_locked`` are mutually exclusive and attempts to call "
"``select_for_update()`` with both options enabled will result in a :exc:"
"`ValueError`."
msgstr ""
"Обычно, если другая транзакция заблокировала одну из выбранных записей, "
"запрос будет заблокирован до снятия блокировки. Если вы не желаете этого, "
"используйте ``select_for_update(nowait=True)``. Вызов будет не "
"блокированным, если записи уже заблокированы, будет вызвано исключение :exc:"
"`~django.db.DatabaseError` при вычислении ``QuerySet``."

#: ../../ref/models/querysets.txt:1662
msgid ""
"By default, ``select_for_update()`` locks all rows that are selected by the "
"query. For example, rows of related objects specified in :meth:"
"`select_related` are locked in addition to rows of the queryset's model. If "
"this isn't desired, specify the related objects you want to lock in "
"``select_for_update(of=(...))`` using the same fields syntax as :meth:"
"`select_related`. Use the value ``'self'`` to refer to the queryset's model."
msgstr ""

#: ../../ref/models/querysets.txt:1669
#, fuzzy
msgid "You can't use ``select_for_update()`` on nullable relations::"
msgstr "Вы можете использовать ``select_related()`` с любым \"queryset\"::"

#: ../../ref/models/querysets.txt:1676
msgid ""
"To avoid that restriction, you can exclude null objects if you don't care "
"about them::"
msgstr ""

# 8e0acd3a01d64552a267b44d229abd28
#: ../../ref/models/querysets.txt:1682
#, fuzzy
msgid ""
"Currently, the ``postgresql``, ``oracle``, and ``mysql`` database backends "
"support ``select_for_update()``. However, MySQL doesn't support the "
"``nowait``, ``skip_locked``, and ``of`` arguments."
msgstr ""
"На данный момент, ``postgresql``, ``oracle``, и ``mysql`` \"бэкенды\" базы "
"данных поддерживают ``select_for_update()``. Однако, MySQL не поддерживает "
"аргумент ``nowait``. Пользователи других баз данных должны уточнить эту "
"информацию в документации используемой базы данных."

# 07555036d70443c1abefc233b4f6a63e
#: ../../ref/models/querysets.txt:1686
#, fuzzy
msgid ""
"Passing ``nowait=True``, ``skip_locked=True``, or ``of`` to "
"``select_for_update()`` using database backends that do not support these "
"options, such as MySQL, raises a :exc:`~django.db.NotSupportedError`. This "
"prevents code from unexpectedly blocking."
msgstr ""
"Использование ``nowait=True`` в ``select_for_update()`` для базы данных, "
"которая не поддерживает ``nowait``, такой как MySQL, вызовет исключение :exc:"
"`~django.db.DatabaseError`. Это делается чтобы предотвратить непредвиденную "
"блокировку кода."

# 91469cf76c2547eabafe0aaab9973eb5
#: ../../ref/models/querysets.txt:1691
msgid ""
"Evaluating a queryset with ``select_for_update()`` in autocommit mode on "
"backends which support ``SELECT ... FOR UPDATE`` is a :exc:`~django.db."
"transaction.TransactionManagementError` error because the rows are not "
"locked in that case. If allowed, this would facilitate data corruption and "
"could easily be caused by calling code that expects to be run in a "
"transaction outside of one."
msgstr ""
"Выполнение выборки с ``select_for_update()`` в autocommit режиме для "
"бэкенда, который поддерживает ``SELECT ... FOR UPDATE``, вызовет :exc:"
"`~django.db.transaction.TransactionManagementError` т.к. строки не будут "
"заблокированы в этом случае. Если разрешить такое выполнение, это может "
"привести к повреждению данных т.к. код рассчитывает, что будет выполнен в "
"транзакции, хотя это не так."

# 468b0dff8e6147dbafa260f11136e211
#: ../../ref/models/querysets.txt:1698
msgid ""
"Using ``select_for_update()`` on backends which do not support ``SELECT ... "
"FOR UPDATE`` (such as SQLite) will have no effect. ``SELECT ... FOR UPDATE`` "
"will not be added to the query, and an error isn't raised if "
"``select_for_update()`` is used in autocommit mode."
msgstr ""
"Использование ``select_for_update()`` с базой данных, которая не "
"поддерживает ``SELECT ... FOR UPDATE`` (например, SQLite) не будет иметь "
"никакого эффекта. ``SELECT ... FOR UPDATE`` не будет добавлено к запросу, и "
"ошибка не будет вызвана, если ``select_for_update()`` используется в "
"autocommit режиме."

# 2928727d46b24614b5bf42f8e9d0790d
#: ../../ref/models/querysets.txt:1705
msgid ""
"Although ``select_for_update()`` normally fails in autocommit mode, since :"
"class:`~django.test.TestCase` automatically wraps each test in a "
"transaction, calling ``select_for_update()`` in a ``TestCase`` even outside "
"an :func:`~django.db.transaction.atomic()` block will (perhaps unexpectedly) "
"pass without raising a ``TransactionManagementError``. To properly test "
"``select_for_update()`` you should use :class:`~django.test."
"TransactionTestCase`."
msgstr ""
"Хотя ``select_for_update()`` вызывает ошибку в autocommit режиме, т.к. :"
"class:`~django.test.TestCase` автоматически использует транзакцию для "
"каждого теста, вызов ``select_for_update()`` в ``TestCase`` даже вне блока :"
"func:`~django.db.transaction.atomic()` будет выполнен без ошибки "
"``TransactionManagementError``. Для правильного тестирования "
"``select_for_update()`` используйте :class:`~django.test."
"TransactionTestCase`."

#: ../../ref/models/querysets.txt:1713
msgid "Certain expressions may not be supported"
msgstr ""

#: ../../ref/models/querysets.txt:1715
msgid ""
"PostgreSQL doesn't support ``select_for_update()`` with :class:`~django.db."
"models.expressions.Window` expressions."
msgstr ""

#: ../../ref/models/querysets.txt:1720
#, fuzzy
msgid "The ``skip_locked`` argument was added."
msgstr "Был добавлен аргумент ``output_field``."

#: ../../ref/models/querysets.txt:1724
#, fuzzy
msgid "The ``of`` argument was added."
msgstr "Был добавлен аргумент ``output_field``."

#: ../../ref/models/querysets.txt:1727
msgid "``raw()``"
msgstr ""

# 3b007fe3fd6b4dd5b3a9de99e751d6c8
#: ../../ref/models/querysets.txt:1731
msgid ""
"Takes a raw SQL query, executes it, and returns a ``django.db.models.query."
"RawQuerySet`` instance. This ``RawQuerySet`` instance can be iterated over "
"just like an normal ``QuerySet`` to provide object instances."
msgstr ""
"Принимает SQL запрос, выполняет его и возвращает объект ``django.db.models."
"query.RawQuerySet``. Этот объект ``RawQuerySet`` может быть проитерирован "
"как и обычный ``QuerySet`` для получения объектов результата."

# 3b801ed5ae9f4abca0ea2789f911b6ea
#: ../../ref/models/querysets.txt:1735
msgid "See the :doc:`/topics/db/sql` for more information."
msgstr "Смотрите :doc:`/topics/db/sql`."

# 933fcb87ad454b12b772fd4a2c7d47b8
#: ../../ref/models/querysets.txt:1739
msgid ""
"``raw()`` always triggers a new query and doesn't account for previous "
"filtering. As such, it should generally be called from the ``Manager`` or "
"from a fresh ``QuerySet`` instance."
msgstr ""
"``raw()`` всегда выполняет новый запрос к базе данных и игнорирует "
"предыдущую фильтрацию. Поэтому следует вызывать его из ``Manager`` или "
"чистого объекта ``QuerySet``."

# cf54942aad72476b975aeab0c6d46b05
#: ../../ref/models/querysets.txt:1744
#, fuzzy
msgid "Methods that do not return ``QuerySet``\\s"
msgstr "Методы, которые не возвращают QuerySets"

# e2cc8170101f4de6a8d642df4f66c0ba
#: ../../ref/models/querysets.txt:1746
msgid ""
"The following ``QuerySet`` methods evaluate the ``QuerySet`` and return "
"something *other than* a ``QuerySet``."
msgstr ""
"Следующие методы выполняют ``QuerySet`` и возвращают *не* ``QuerySet``."

# 5e5113f0ef414577825e47219fb7d53e
#: ../../ref/models/querysets.txt:1749
msgid ""
"These methods do not use a cache (see :ref:`caching-and-querysets`). Rather, "
"they query the database each time they're called."
msgstr ""
"Эти методы не используют кэш (смотрите :ref:`caching-and-querysets`) и "
"выполняют запрос к базе данных при каждом вызове."

#: ../../ref/models/querysets.txt:1753
msgid "``get()``"
msgstr ""

# a4c76c594925430f9360797d2ed288fd
#: ../../ref/models/querysets.txt:1757
msgid ""
"Returns the object matching the given lookup parameters, which should be in "
"the format described in `Field lookups`_."
msgstr ""
"Возвращает объект соответствующий параметрам поиска, которые должны быть "
"указанны в формате описанном в :ref:`разделе о параметрах поиска <field-"
"lookups>`"

# ceedda62705e4961aa2713b4025293b3
#: ../../ref/models/querysets.txt:1760
msgid ""
"``get()`` raises :exc:`~django.core.exceptions.MultipleObjectsReturned` if "
"more than one object was found. The :exc:`~django.core.exceptions."
"MultipleObjectsReturned` exception is an attribute of the model class."
msgstr ""
"``get()`` вызывает исключение :exc:`~django.core.exceptions."
"MultipleObjectsReturned`, если найдено более одно объекта. :exc:`~django."
"core.excpetions.MultipleObjectsReturned` -- атрибут класса модели."

# 8b9d9fa4a3d84d18af471fd705e7b7fd
#: ../../ref/models/querysets.txt:1765
msgid ""
"``get()`` raises a :exc:`~django.db.models.Model.DoesNotExist` exception if "
"an object wasn't found for the given parameters. This exception is an "
"attribute of the model class. Example::"
msgstr ""
"``get()`` вызывает исключение :exc:`~django.db.models.Model.DoesNotExist`, "
"если ни один объект не был найден. Это исключение также атрибут класса "
"модели. Например::"

# 1de14e70fc794c9fb9d8de5acbc06d5e
#: ../../ref/models/querysets.txt:1771
msgid ""
"The :exc:`~django.db.models.Model.DoesNotExist` exception inherits from :exc:"
"`django.core.exceptions.ObjectDoesNotExist`, so you can target multiple :exc:"
"`~django.db.models.Model.DoesNotExist` exceptions. Example::"
msgstr ""
"Исключение :exc:`~django.db.models.Model.DoesNotExist` унаследовано от :exc:"
"`django.core.exceptions.ObjectDoesNotExist`,таким образом можно обработать "
"несколько исключений :exc:`~django.db.models.Model.DoesNotExist`. Например::"

#: ../../ref/models/querysets.txt:1782
msgid ""
"If you expect a queryset to return one row, you can use ``get()`` without "
"any arguments to return the object for that row::"
msgstr ""

# 48c322aa8440460f81b4545e4404fcae
#: ../../ref/models/querysets.txt:1788
#, fuzzy
msgid "``create()``"
msgstr "create"

# dc1f60acc08941bf90036eec5558cfcc
#: ../../ref/models/querysets.txt:1792
msgid ""
"A convenience method for creating an object and saving it all in one step.  "
"Thus::"
msgstr "Удобный метод чтобы создать и сохранить объект. Таким образом::"

# 6e7c183bfa21425aab2a2e428662ae84
#: ../../ref/models/querysets.txt:1796
msgid "and::"
msgstr "и::"

# 76da19f0fec2474ea112e705f5b05126
#: ../../ref/models/querysets.txt:1801
msgid "are equivalent."
msgstr "эквивалентны."

# 1213699156fb41af9b4150ec19cb1b60
#: ../../ref/models/querysets.txt:1803
msgid ""
"The :ref:`force_insert <ref-models-force-insert>` parameter is documented "
"elsewhere, but all it means is that a new object will always be created. "
"Normally you won't need to worry about this. However, if your model contains "
"a manual primary key value that you set and if that value already exists in "
"the database, a call to ``create()`` will fail with an :exc:`~django.db."
"IntegrityError` since primary keys must be unique. Be prepared to handle the "
"exception if you are using manual primary keys."
msgstr ""
"Параметр :ref:`force_insert <ref-models-force-insert>` описан в другом "
"разделе, он означает, что всегда будет  создаваться новый объект. Обычно вам "
"не нужно беспокоиться об этом. Однако, если ваш объект содержит значение "
"первичного ключа и этот ключ уже существует в базе данных, метод "
"``create()`` вызовет исключение :exc:`~django.db.IntegrityError` т.к. "
"первичный ключ должен быть уникальным. Будьте готовы обработать исключение, "
"если вы самостоятельно указываете первичный ключ."

# 733254dc1264496dbe4cb36d871b2d9b
#: ../../ref/models/querysets.txt:1812
#, fuzzy
msgid "``get_or_create()``"
msgstr "get_or_create"

# e3c560b3981d4cfcbf09766623b6825e
#: ../../ref/models/querysets.txt:1816
msgid ""
"A convenience method for looking up an object with the given ``kwargs`` (may "
"be empty if your model has defaults for all fields), creating one if "
"necessary."
msgstr ""
"Удобный метод для поиска объекта по заданным параметрам поиска ``kwargs`` "
"(может быть пустым, если все поля содержат значения по умолчанию), и "
"создания нового при необходимости."

# 0b3c276a1737474fa728a52a3e7d52f1
#: ../../ref/models/querysets.txt:1819
msgid ""
"Returns a tuple of ``(object, created)``, where ``object`` is the retrieved "
"or created object and ``created`` is a boolean specifying whether a new "
"object was created."
msgstr ""
"Возвращает кортеж ``(object, created)``, где ``object`` полученный или "
"созданный объект и ``created`` -- булево значение, указывающее был ли создан "
"объект."

# 10b4d4b11a0f4074ad32685049291aca
#: ../../ref/models/querysets.txt:1823 ../../ref/models/querysets.txt:1948
msgid "This is meant as a shortcut to boilerplatish code. For example::"
msgstr "Этот метод удобно использовать для скриптов импорта данных. Например::"

# 69f33df6b87b42b1850c128fb7f06ed9
#: ../../ref/models/querysets.txt:1831
msgid ""
"This pattern gets quite unwieldy as the number of fields in a model goes up. "
"The above example can be rewritten using ``get_or_create()`` like so::"
msgstr ""
"Такой способ становится весьма громоздким при увеличении количества полей "
"модели. Пример выше может быть переписан с использованием метода "
"``get_or_create()``::"

# f45bcfa02f864a63bc20bd2a9c6eac1a
#: ../../ref/models/querysets.txt:1840
msgid ""
"Any keyword arguments passed to ``get_or_create()`` — *except* an optional "
"one called ``defaults`` — will be used in a :meth:`get()` call. If an object "
"is found, ``get_or_create()`` returns a tuple of that object and ``False``. "
"If multiple objects are found, ``get_or_create`` raises :exc:`~django.core."
"exceptions.MultipleObjectsReturned`. If an object is *not* found, "
"``get_or_create()`` will instantiate and save a new object, returning a "
"tuple of the new object and ``True``. The new object will be created roughly "
"according to this algorithm::"
msgstr ""
"Все именованные аргументы переданные в ``get_or_create()`` — *кроме* одного "
"не обязательного ``defaults`` — будут использованы при вызове :meth:`get()`. "
"Если объект найден, ``get_or_create()`` вернет этот объект и ``False``. Если "
"найдено несколько объектов - будет вызвано исключение :exc:`~django.core."
"exceptions.MultipleObjectsReturned`.  Если объект *не* найден, "
"``get_or_create()`` создаст и сохранит новый объект, возвращая новый объект "
"и ``True``. Новый объект будет создан примерно за таким алгоритмом::"

# ad18a6924b624c0096c7101f2630df89
#: ../../ref/models/querysets.txt:1854
#, fuzzy
msgid ""
"In English, that means start with any non-``'defaults'`` keyword argument "
"that doesn't contain a double underscore (which would indicate a non-exact "
"lookup). Then add the contents of ``defaults``, overriding any keys if "
"necessary, and use the result as the keyword arguments to the model class. "
"If there are any callables in ``defaults``, evaluate them. As hinted at "
"above, this is a simplification of the algorithm that is used, but it "
"contains all the pertinent details. The internal implementation has some "
"more error-checking than this and handles some extra edge-conditions; if "
"you're interested, read the code."
msgstr ""
"Это означает, что будут выбраны именованные аргументы кроме ``'defaults'`` и "
"не содержащие двойное подчеркивание (которые указывают на не-точный поиск). "
"Затем добавляются значения из ``defaults``, перезаписывая ключи при "
"необходимости, полученные данные используются как аргументы для конструктора "
"класса модели. Как уже указывалось выше, это упрощенный алгоритм, но все "
"важные детали указаны. Внутренняя реализация одержит больше проверок ошибок "
"и различных условий; если вам интересно, можете посмотреть исходный код."

# fc2b1c12110e425ca3dcf375800ef326
#: ../../ref/models/querysets.txt:1863
msgid ""
"If you have a field named ``defaults`` and want to use it as an exact lookup "
"in ``get_or_create()``, just use ``'defaults__exact'``, like so::"
msgstr ""
"Если модель содержит поле ``defaults`` и вы хотите использовать его в "
"параметрах поиска в ``get_or_create()``, просто используйте "
"``'defaults__exact'``::"

# ac3893de8cff4a62aab3cafad3e10525
#: ../../ref/models/querysets.txt:1868
msgid ""
"The ``get_or_create()`` method has similar error behavior to :meth:"
"`create()` when you're using manually specified primary keys. If an object "
"needs to be created and the key already exists in the database, an :exc:"
"`~django.db.IntegrityError` will be raised."
msgstr ""
"Метод ``get_or_create()`` использует аналогичное поведение с ошибками что и "
"метод :meth:`create()`, если вы самостоятельно определяете значение "
"первичного ключа. Если объект должен быть создан и значение первичного ключа "
"уже существует в базе данных, будет вызвано исключение :exc:`~django.db."
"IntegrityError`."

# fc0c7946f5364275970cd01dc58b8245
#: ../../ref/models/querysets.txt:1873
msgid ""
"This method is atomic assuming correct usage, correct database "
"configuration, and correct behavior of the underlying database. However, if "
"uniqueness is not enforced at the database level for the ``kwargs`` used in "
"a ``get_or_create`` call (see :attr:`~django.db.models.Field.unique` or :"
"attr:`~django.db.models.Options.unique_together`), this method is prone to a "
"race-condition which can result in multiple rows with the same parameters "
"being inserted simultaneously."
msgstr ""
"Этот метод атомарный при правильном использовании, правильной настройке и "
"работе БД. Однако, если уникальность полей не контролируется на уровне БД(:"
"attr:`~django.db.models.Field.unique` или :attr:`~django.db.models.Options."
"unique_together`), этот метод склонен к \"гонке-состояний\" и в БД могут "
"попасть не уникальные данные(прим. пер. - Django то проверить уникальность, "
"но при нескольких процессах запросы могут одновременно отправиться на "
"выполнения к БД, а там уже ничего не проверяется)."

# b919494887204dfc9fc2a93e35470019
#: ../../ref/models/querysets.txt:1881
msgid ""
"If you are using MySQL, be sure to use the ``READ COMMITTED`` isolation "
"level rather than ``REPEATABLE READ`` (the default), otherwise you may see "
"cases where ``get_or_create`` will raise an :exc:`~django.db.IntegrityError` "
"but the object won't appear in a subsequent :meth:`~django.db.models.query."
"QuerySet.get` call."
msgstr ""
"При использовании MySQL, убедитесь что используете ``READ COMMITTED`` вместо "
"``REPEATABLE READ`` (по умолчанию), иначе ``get_or_create`` может вызывать :"
"exc:`~django.db.IntegrityError`, но объект не будет возвращен последующим "
"вызовом :meth:`~django.db.models.query.QuerySet.get`."

# 5ac92a346afa45b5b51f2c59c4dd87e3
#: ../../ref/models/querysets.txt:1887
#, fuzzy
msgid ""
"Finally, a word on using ``get_or_create()`` in Django views. Please make "
"sure to use it only in ``POST`` requests unless you have a good reason not "
"to. ``GET`` requests shouldn't have any effect on data. Instead, use "
"``POST`` whenever a request to a page has a side effect on your data. For "
"more, see :rfc:`Safe methods <7231#section-4.2.1>` in the HTTP spec."
msgstr ""
"Наконец, несколько слов об использовании ``get_or_create()`` в "
"представлениях Django. Пожалуйста используйте его только для ``POST`` "
"запросов, если только у вас нет основательных причин не делать этого. "
"Запросы ``GET`` не должны влиять на данные; используйте запрос ``POST`` для "
"изменения данных. Подробнее смотрите раздел о `безопасных методах <http://"
"www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1>`_ в спецификации "
"HTTP."

# cf17f1902a8b46578d58abff9d2123b3
#: ../../ref/models/querysets.txt:1895
msgid ""
"You can use ``get_or_create()`` through :class:`~django.db.models."
"ManyToManyField` attributes and reverse relations. In that case you will "
"restrict the queries inside the context of that relation. That could lead "
"you to some integrity problems if you don't use it consistently."
msgstr ""
"Вы можете использовать ``get_or_create()`` с атрибутами :class:`~django.db."
"models.ManyToManyField` и обратными внешними связями. При это запросы будут "
"ограничены контекстом связи. Это может вызвать некоторые проблемы при "
"создании объектов."

# 248e3fa46c6d4b0f803835cc5e32b274
#: ../../ref/models/querysets.txt:1900
msgid "Being the following models::"
msgstr "Возьмем следующие модели::"

# fdb17d71ad3d44aeb828244c68209094
#: ../../ref/models/querysets.txt:1909
msgid ""
"You can use ``get_or_create()`` through Book's chapters field, but it only "
"fetches inside the context of that book::"
msgstr ""
"Вы можете использовать ``get_or_create()`` для поля ``chapters`` модели "
"``Book``, но будут учитывать только объекты связанные с конкретной книгой::"

# 5de2c7490a5d4732a056b55bb17ef048
#: ../../ref/models/querysets.txt:1922
msgid ""
"This is happening because it's trying to get or create \"Chapter 1\" through "
"the book \"Ulysses\", but it can't do any of them: the relation can't fetch "
"that chapter because it isn't related to that book, but it can't create it "
"either because ``title`` field should be unique."
msgstr ""
"Это произошло, потому что мы пытались получить или создать \"Chapter 1\" для "
"книги \"Ulysses\", но ни один объект не был найден, т.к. он не связан с этой "
"книгой, и мы получили ошибку при попытке его создать т.к. поле ``title`` "
"должно быть уникальным."

#: ../../ref/models/querysets.txt:1929 ../../ref/models/querysets.txt:1983
msgid "Added support for callable values in ``defaults``."
msgstr ""

# 733254dc1264496dbe4cb36d871b2d9b
#: ../../ref/models/querysets.txt:1932
#, fuzzy
msgid "``update_or_create()``"
msgstr "update_or_create"

# e3c560b3981d4cfcbf09766623b6825e
#: ../../ref/models/querysets.txt:1936
#, fuzzy
msgid ""
"A convenience method for updating an object with the given ``kwargs``, "
"creating a new one if necessary. The ``defaults`` is a dictionary of (field, "
"value) pairs used to update the object. The values in ``defaults`` can be "
"callables."
msgstr ""
"Удобный метод для обновления объекта по заданным параметрам поиска "
"``kwargs`` и создания нового при необходимости. ``defaults`` -- словарь "
"полей и значений для обновления объекта."

# 0b3c276a1737474fa728a52a3e7d52f1
#: ../../ref/models/querysets.txt:1940
msgid ""
"Returns a tuple of ``(object, created)``, where ``object`` is the created or "
"updated object and ``created`` is a boolean specifying whether a new object "
"was created."
msgstr ""
"Возвращает кортеж ``(object, created)``, где ``object`` полученный или "
"обновленный объект и ``created`` -- булево значение, указывающее был ли "
"создан объект."

# 499e8dd424e549158b7bc6ca71b74aa5
#: ../../ref/models/querysets.txt:1944
msgid ""
"The ``update_or_create`` method tries to fetch an object from database based "
"on the given ``kwargs``. If a match is found, it updates the fields passed "
"in the ``defaults`` dictionary."
msgstr ""
"Метод ``update_or_create`` пытается получить объект из базы данных, "
"используя ``kwargs``. Если объект найден, он обновляет поля указанные в "
"``defaults``."

# 69f33df6b87b42b1850c128fb7f06ed9
#: ../../ref/models/querysets.txt:1962
msgid ""
"This pattern gets quite unwieldy as the number of fields in a model goes up. "
"The above example can be rewritten using ``update_or_create()`` like so::"
msgstr ""
"Такой способ становится весьма громоздким при увеличении количества полей "
"модели. Пример выше может быть переписан с использованием метода "
"``update_or_create()``::"

# cbd620b00d9346008453667ed128eb09
#: ../../ref/models/querysets.txt:1970
msgid ""
"For detailed description how names passed in ``kwargs`` are resolved see :"
"meth:`get_or_create`."
msgstr ""
"Подробности о том, как обрабатывается ``kwargs``, смотрите в описании :meth:"
"`get_or_create`."

# 3e07a1346a154a9bb6616717d126c70c
#: ../../ref/models/querysets.txt:1973
msgid ""
"As described above in :meth:`get_or_create`, this method is prone to a race-"
"condition which can result in multiple rows being inserted simultaneously if "
"uniqueness is not enforced at the database level."
msgstr ""
"Как описано выше в :meth:`get_or_create`, этот метод подвержен состоянию "
"гонки, что может привести к созданию одинаковых строк в базе данных, если "
"уникальность полей не контролируется на уровне базы данных."

# ac3893de8cff4a62aab3cafad3e10525
#: ../../ref/models/querysets.txt:1977
#, fuzzy
msgid ""
"Like :meth:`get_or_create` and :meth:`create`, if you're using manually "
"specified primary keys and an object needs to be created but the key already "
"exists in the database, an :exc:`~django.db.IntegrityError` is raised."
msgstr ""
"Метод ``get_or_create()`` использует аналогичное поведение с ошибками что и "
"метод :meth:`create()`, если вы самостоятельно определяете значение "
"первичного ключа. Если объект должен быть создан и значение первичного ключа "
"уже существует в базе данных, будет вызвано исключение :exc:`~django.db."
"IntegrityError`."

# d429abc1e645455c940147c50ab985cd
#: ../../ref/models/querysets.txt:1986
#, fuzzy
msgid "``bulk_create()``"
msgstr "bulk_create"

# f38d91295c744ec9b91676653ab7f82c
#: ../../ref/models/querysets.txt:1990
msgid ""
"This method inserts the provided list of objects into the database in an "
"efficient manner (generally only 1 query, no matter how many objects there "
"are)::"
msgstr ""
"Этот метод позволяет сохранить в базе данных множество объектов одним "
"запросом::"

# e38565913b9b42f8944e3422063eb7e6
#: ../../ref/models/querysets.txt:1999
msgid "This has a number of caveats though:"
msgstr "Следует упомянуть ряд оговорок:"

# 76a81c0ef9c947488487d43a52de6cc3
#: ../../ref/models/querysets.txt:2001
msgid ""
"The model's ``save()`` method will not be called, and the ``pre_save`` and "
"``post_save`` signals will not be sent."
msgstr ""
"Метод модели ``save()`` не будет вызван, и сигналы ``pre_save`` и "
"``post_save`` не будут вызваны."

# 6924420c93264545b050302f9f9ecf4e
#: ../../ref/models/querysets.txt:2003
msgid ""
"It does not work with child models in a multi-table inheritance scenario."
msgstr "Не работает с дочерними моделями при multi-table наследовании."

# 3727e407fafa4d8da290c49ca51ba764
#: ../../ref/models/querysets.txt:2004
#, fuzzy
msgid ""
"If the model's primary key is an :class:`~django.db.models.AutoField` it "
"does not retrieve and set the primary key attribute, as ``save()`` does, "
"unless the database backend supports it (currently PostgreSQL)."
msgstr ""
"Если первичный ключ модели это :class:`~django.db.models.AutoField`, его "
"значение не будет получено и атрибут первичного ключа не будет установлен "
"как это делает метод ``save()`` ."

# 16f0d7804f364b7c9a9eb9380bf1fb63
#: ../../ref/models/querysets.txt:2007
msgid "It does not work with many-to-many relationships."
msgstr "Не работает со связями многое-ко-многим."

#: ../../ref/models/querysets.txt:2008
msgid ""
"It casts ``objs`` to a list, which fully evaluates ``objs`` if it's a "
"generator. The cast allows inspecting all objects so that any objects with a "
"manually set primary key can be inserted first. If you want to insert "
"objects in batches without evaluating the entire generator at once, you can "
"use this technique as long as the objects don't have any manually set "
"primary keys::"
msgstr ""

# f65561fbfeb84c8a9d7f34247b36b679
#: ../../ref/models/querysets.txt:2024
#, fuzzy
msgid ""
"The ``batch_size`` parameter controls how many objects are created in a "
"single query. The default is to create all objects in one batch, except for "
"SQLite where the default is such that at most 999 variables per query are "
"used."
msgstr ""
"Параметр ``batch_size`` указывает количество объектов, которые будут созданы "
"за один запрос. По умолчанию все объекты создаются одним запросом, кроме "
"SQLite, где есть ограничение на количество переменных в запросе равное 999."

# c7683f03673446c6ab62a0b58ab6ef2d
#: ../../ref/models/querysets.txt:2029
#, fuzzy
msgid "``count()``"
msgstr "count"

# 17a96d7d87224a1a9905cafe37f0f8cb
#: ../../ref/models/querysets.txt:2033
msgid ""
"Returns an integer representing the number of objects in the database "
"matching the ``QuerySet``. The ``count()`` method never raises exceptions."
msgstr ""
"Возвращает количество записей в базе данных отвечающем запросу ``QuerySet``. "
"Метод ``count()`` никогда не вызывает исключение."

# b15795049d074d11a35c29d720e38b37
#: ../../ref/models/querysets.txt:2044
msgid ""
"A ``count()`` call performs a ``SELECT COUNT(*)`` behind the scenes, so you "
"should always use ``count()`` rather than loading all of the record into "
"Python objects and calling ``len()`` on the result (unless you need to load "
"the objects into memory anyway, in which case ``len()`` will be faster)."
msgstr ""
"Метод ``count()`` использует ``SELECT COUNT(*)``, так что всегда используйте "
"метод ``count()`` вместо загрузки всех записей в объекты Python и вызов "
"``len()`` над результатом (если вам кончено в любом случае не понадобится "
"загружать их далее, в таком случае ``len()`` будет быстрее)."

#: ../../ref/models/querysets.txt:2049
msgid ""
"Note that if you want the number of items in a ``QuerySet`` and are also "
"retrieving model instances from it (for example, by iterating over it), it's "
"probably more efficient to use ``len(queryset)`` which won't cause an extra "
"database query like ``count()`` would."
msgstr ""
"Обратите внимание, если вам необходимо количество объектов в ``QuerySet`` и "
"сами объекты (например, цикл по ним), возможно эффективнее использовать "
"``len(queryset)``, чтобы избежать дополнительного запроса при выполнении "
"``count()``."

# b86d2ab4185543909ae12e93061bb1cf
#: ../../ref/models/querysets.txt:2055
#, fuzzy
msgid "``in_bulk()``"
msgstr "in_bulk"

# 6edb6624b7a342d08938636439c7f192
#: ../../ref/models/querysets.txt:2059
#, fuzzy
msgid ""
"Takes a list of field values (``id_list``) and the ``field_name`` for those "
"values, and returns a dictionary mapping each value to an instance of the "
"object with the given field value. If ``id_list`` isn't provided, all "
"objects in the queryset are returned. ``field_name`` must be a unique field, "
"and it defaults to the primary key."
msgstr ""
"Получает список первичных ключей и возвращает словарь, ассоциирующий объекты "
"с переданными ID."

# 86a3793113f4425ca7ebd768234eca7b
#: ../../ref/models/querysets.txt:2078
msgid ""
"If you pass ``in_bulk()`` an empty list, you'll get an empty dictionary."
msgstr ""
"При передаче в ``in_bulk()`` пустого списка будет получен пустой словарь."

#: ../../ref/models/querysets.txt:2082
#, fuzzy
msgid "The ``field_name`` parameter was added."
msgstr "Был добавлен аргумент ``output_field``."

# acc6068123c54c2f849ad58f62cbb6ad
#: ../../ref/models/querysets.txt:2085
#, fuzzy
msgid "``iterator()``"
msgstr "iterator"

# 73dba9f3e0154b9aa03243a0476e444f
#: ../../ref/models/querysets.txt:2089
msgid ""
"Evaluates the ``QuerySet`` (by performing the query) and returns an iterator "
"(see :pep:`234`) over the results. A ``QuerySet`` typically caches its "
"results internally so that repeated evaluations do not result in additional "
"queries. In contrast, ``iterator()`` will read results directly, without "
"doing any caching at the ``QuerySet`` level (internally, the default "
"iterator calls ``iterator()`` and caches the return value). For a "
"``QuerySet`` which returns a large number of objects that you only need to "
"access once, this can result in better performance and a significant "
"reduction in memory."
msgstr ""
"Вычисляет ``QuerySet`` (выполняя запрос) и возвращает итератор (смотрите :"
"pep:`234`) по результату. ``QuerySet`` обычно кэширует результат и повторное "
"обращение не вызывает повторное выполнение запросов. Метод ``iterator()`` "
"читает результаты непосредственно из базы данных, без кэширования на уровне "
"``QuerySet`` (итератор по-умолчанию вызывает ``iterator()`` и кэширует "
"возвращенное значение). Для ``QuerySet``, который возвращает большое "
"количество объектов и который будет использован всего лишь один раз, "
"использование этого метода может увеличить производительность и немного "
"уменьшить потребление памяти."

# 6ddbfbdde0b0433fb919283bab10857c
#: ../../ref/models/querysets.txt:2098
msgid ""
"Note that using ``iterator()`` on a ``QuerySet`` which has already been "
"evaluated will force it to evaluate again, repeating the query."
msgstr ""
"Заметим, что использование ``iterator()`` для ``QuerySet``, который уже был "
"вычислен, приведет к повторному вычислению и выполнению запроса к базе "
"данных."

# b35756d3cd9a4ee49466a724284c48c4
#: ../../ref/models/querysets.txt:2101
msgid ""
"Also, use of ``iterator()`` causes previous ``prefetch_related()`` calls to "
"be ignored since these two optimizations do not make sense together."
msgstr ""
"Заметим, если вы используете ``iterator()`` для выполнения запроса, вызов "
"``prefetch_related()`` будет проигнорирован т.к. использование этих двух "
"оптимизаций вместе не имеет смысла."

#: ../../ref/models/querysets.txt:2104
msgid ""
"Depending on the database backend, query results will either be loaded all "
"at once or streamed from the database using server-side cursors."
msgstr ""

#: ../../ref/models/querysets.txt:2108
msgid "With server-side cursors"
msgstr ""

#: ../../ref/models/querysets.txt:2110
msgid ""
"Oracle and :ref:`PostgreSQL <postgresql-server-side-cursors>` use server-"
"side cursors to stream results from the database without loading the entire "
"result set into memory."
msgstr ""

#: ../../ref/models/querysets.txt:2114
msgid "The Oracle database driver always uses server-side cursors."
msgstr ""

#: ../../ref/models/querysets.txt:2116
msgid ""
"With server-side cursors, the ``chunk_size`` parameter specifies the number "
"of results to cache at the database driver level. Fetching bigger chunks "
"diminishes the number of round trips between the database driver and the "
"database, at the expense of memory."
msgstr ""

#: ../../ref/models/querysets.txt:2121
msgid ""
"On PostgreSQL, server-side cursors will only be used when the :setting:"
"`DISABLE_SERVER_SIDE_CURSORS <DATABASE-DISABLE_SERVER_SIDE_CURSORS>` setting "
"is ``False``. Read :ref:`transaction-pooling-server-side-cursors` if you're "
"using a connection pooler configured in transaction pooling mode. When "
"server-side cursors are disabled, the behavior is the same as databases that "
"don't support server-side cursors."
msgstr ""

#: ../../ref/models/querysets.txt:2129
msgid "Without server-side cursors"
msgstr ""

#: ../../ref/models/querysets.txt:2131
msgid ""
"MySQL and SQLite don't support streaming results, hence the Python database "
"drivers load the entire result set into memory. The result set is then "
"transformed into Python row objects by the database adapter using the "
"``fetchmany()`` method defined in :pep:`249`."
msgstr ""

#: ../../ref/models/querysets.txt:2136
msgid ""
"The ``chunk_size`` parameter controls the size of batches Django retrieves "
"from the database driver. Larger batches decrease the overhead of "
"communicating with the database driver at the expense of a slight increase "
"in memory consumption."
msgstr ""

#: ../../ref/models/querysets.txt:2140
msgid ""
"The default value of ``chunk_size``, 2000, comes from `a calculation on the "
"psycopg mailing list <https://www.postgresql.org/message-"
"id/4D2F2C71.8080805%40dndg.it>`_:"
msgstr ""

#: ../../ref/models/querysets.txt:2143
msgid ""
"Assuming rows of 10-20 columns with a mix of textual and numeric data, 2000 "
"is going to fetch less than 100KB of data, which seems a good compromise "
"between the number of rows transferred and the data discarded if the loop is "
"exited early."
msgstr ""

#: ../../ref/models/querysets.txt:2150
msgid "PostgreSQL support for server-side cursors was added."
msgstr ""

#: ../../ref/models/querysets.txt:2154
#, fuzzy
msgid "The ``chunk_size`` parameter was added."
msgstr "Был добавлен аргумент ``output_field``."

# 208b177164b04f64889b2348092a7a6a
#: ../../ref/models/querysets.txt:2157
#, fuzzy
msgid "``latest()``"
msgstr "latest"

# a59d25c8101d4318aa291b3de3ce78cc
#: ../../ref/models/querysets.txt:2161
#, fuzzy
msgid "Returns the latest object in the table based on the given field(s)."
msgstr ""
"Возвращает последний объект, используя значение из поля даты указанного "
"параметром ``field_name``."

# 92c95fe7b6414491820ddf5d34908e1c
#: ../../ref/models/querysets.txt:2163
msgid ""
"This example returns the latest ``Entry`` in the table, according to the "
"``pub_date`` field::"
msgstr ""
"Этот пример возвращает последний объект ``Entry`` в таблице по полю "
"``pub_date``::"

#: ../../ref/models/querysets.txt:2168
msgid ""
"You can also choose the latest based on several fields. For example, to "
"select the ``Entry`` with the earliest ``expire_date`` when two entries have "
"the same ``pub_date``::"
msgstr ""

#: ../../ref/models/querysets.txt:2174
msgid ""
"The negative sign in ``'-expire_date'`` means to sort ``expire_date`` in "
"*descending* order. Since ``latest()`` gets the last result, the ``Entry`` "
"with the earliest ``expire_date`` is selected."
msgstr ""

# 46e53a048abe4842ab1948a410ac7ea9
#: ../../ref/models/querysets.txt:2178
#, fuzzy
msgid ""
"If your model's :ref:`Meta <meta-options>` specifies :attr:`~django.db."
"models.Options.get_latest_by`, you can omit any arguments to ``earliest()`` "
"or ``latest()``. The fields specified in :attr:`~django.db.models.Options."
"get_latest_by` will be used by default."
msgstr ""
"Если в :ref:`Meta <meta-options>` модели определен :attr:`~django.db.models."
"Options.get_latest_by`, вы можете не указывать аргумент ``field_name`` при "
"вызове ``earliest()`` или ``latest()``. Django будет использовать поле "
"указанное в :attr:`~django.db.models.Options.get_latest_by` как значение по-"
"умолчанию."

# 12ca2adda00e4890a443adaeb6769fb1
#: ../../ref/models/querysets.txt:2183
msgid ""
"Like :meth:`get()`, ``earliest()`` and ``latest()`` raise :exc:`~django.db."
"models.Model.DoesNotExist` if there is no object with the given parameters."
msgstr ""
"Как и :meth:`get()`, ``earliest()`` и ``latest()`` вызывает исключение :exc:"
"`~django.db.models.Model.DoesNotExist`, если объект не найден."

# 4b363776d5f14c71ab312253808eb6c2
#: ../../ref/models/querysets.txt:2187
msgid ""
"Note that ``earliest()`` and ``latest()`` exist purely for convenience and "
"readability."
msgstr ""
"Заметим что ``earliest()`` и ``latest()`` существует исключительно для "
"удобства и читаемости."

#: ../../ref/models/querysets.txt:2192
#, fuzzy
msgid "Support for several arguments was added."
msgstr "Была добавлена возможность сортировать по выражению."

# 4b363776d5f14c71ab312253808eb6c2
#: ../../ref/models/querysets.txt:2194
#, fuzzy
msgid "``earliest()`` and ``latest()`` may return instances with null dates."
msgstr ""
"Заметим что ``earliest()`` и ``latest()`` существует исключительно для "
"удобства и читаемости."

#: ../../ref/models/querysets.txt:2196
msgid ""
"Since ordering is delegated to the database, results on fields that allow "
"null values may be ordered differently if you use different databases. For "
"example, PostgreSQL and MySQL sort null values as if they are higher than "
"non-null values, while SQLite does the opposite."
msgstr ""

#: ../../ref/models/querysets.txt:2201
msgid "You may want to filter out null values::"
msgstr ""

# d762ed34648e4f7280d68c4885bc76f4
#: ../../ref/models/querysets.txt:2206
#, fuzzy
msgid "``earliest()``"
msgstr "earliest"

# 766675a64d734956a37b1a3a2f939a0e
#: ../../ref/models/querysets.txt:2210
msgid ""
"Works otherwise like :meth:`~django.db.models.query.QuerySet.latest` except "
"the direction is changed."
msgstr ""
"Работает как и :meth:`~django.db.models.query.QuerySet.latest` только "
"наоборот."

# 45e7628d4bd04f3b90916551b1a0390c
#: ../../ref/models/querysets.txt:2214
#, fuzzy
msgid "``first()``"
msgstr "first"

# 73fad5b23e0642e29eeaed90d74523ac
#: ../../ref/models/querysets.txt:2218
#, fuzzy
msgid ""
"Returns the first object matched by the queryset, or ``None`` if there is no "
"matching object. If the ``QuerySet`` has no ordering defined, then the "
"queryset is automatically ordered by the primary key. This can affect "
"aggregation results as described in :ref:`aggregation-ordering-interaction`."
msgstr ""
"Возвращает первый объект из выборки, или ``None`` если ничего не найдено. "
"Если для ``QuerySet`` не указана сортировка, он будет отсортирован по "
"первичному ключу."

# b8f3a309033b420c9d374bbfcd3c4e36
#: ../../ref/models/querysets.txt:2227
msgid ""
"Note that ``first()`` is a convenience method, the following code sample is "
"equivalent to the above example::"
msgstr "``first()`` создан просто для удобства и аналогичен следующему коду::"

#: ../../ref/models/querysets.txt:2236
msgid "``last()``"
msgstr ""

# d28a559f789f422cb279a02c8e6047e6
#: ../../ref/models/querysets.txt:2240
msgid ""
"Works like  :meth:`first()`, but returns the last object in the queryset."
msgstr ""
"Работает как и :meth:`first()`, но возвращает последний объект из выборки."

# bfeeeab3484b4fcc918460675ff3ef05
#: ../../ref/models/querysets.txt:2243
#, fuzzy
msgid "``aggregate()``"
msgstr "aggregate"

# d55f4538662444eba46ec70f6ff639f3
#: ../../ref/models/querysets.txt:2247
#, fuzzy
msgid ""
"Returns a dictionary of aggregate values (averages, sums, etc.) calculated "
"over the ``QuerySet``. Each argument to ``aggregate()`` specifies a value "
"that will be included in the dictionary that is returned."
msgstr ""
"Возвращает словарь агрегированных значений (среднее значение, сума и др.) "
"вычисленных для ``QuerySet``. Каждый аргумент ``aggregate()`` определяет "
"значение, которые будет включено в возвращаемый словарь."

#: ../../ref/models/querysets.txt:2251
msgid ""
"The aggregation functions that are provided by Django are described in "
"`Aggregation Functions`_ below. Since aggregates are also :doc:`query "
"expressions </ref/models/expressions>`, you may combine aggregates with "
"other aggregates or values to create complex aggregates."
msgstr ""
"Функции агрегации Django описаны в :ref:`aggregation-functions`. Так как они "
"являются :doc:`выражениями запроса </ref/models/expressions>`, вы можете "
"комбинировать функции агрегации друг с другом или значениями, чтобы создать "
"сложные агрегации."

# c51b80cd24bd4d82a249065668c34bdd
#: ../../ref/models/querysets.txt:2256
msgid ""
"Aggregates specified using keyword arguments will use the keyword as the "
"name for the annotation. Anonymous arguments will have a name generated for "
"them based upon the name of the aggregate function and the model field that "
"is being aggregated. Complex aggregates cannot use anonymous arguments and "
"must specify a keyword argument as an alias."
msgstr ""
"Агрегация, указанная с помощью именованного аргумента, использует имя "
"аргумента как название ключа в возвращаемом словаре. Для анонимных "
"аргументов названия ключей будут созданы из названия функции агрегации и "
"названия поля модели используемого в агрегации данных. Сложные агрегации не "
"могут использовать анонимные аргументы и вы должны указать именованные."

# 1913362ad43347b2a98db63df08b4bff
#: ../../ref/models/querysets.txt:2262
msgid ""
"For example, when you are working with blog entries, you may want to know "
"the number of authors that have contributed blog entries::"
msgstr ""
"Например, работая с записями блога, вы возможно захотите узнать сколько "
"записей в выбранных через ``QuerySet`` блогах::"

# b61aba939cdb4885a8631a6545bbadb7
#: ../../ref/models/querysets.txt:2269
msgid ""
"By using a keyword argument to specify the aggregate function, you can "
"control the name of the aggregation value that is returned::"
msgstr ""
"Используя именованный аргумент для определения функции агрегации, вы можете "
"указать название возвращаемого значения::"

# 21912a482abc4405ba8a73d2c249d1f5
#: ../../ref/models/querysets.txt:2279
#, fuzzy
msgid "``exists()``"
msgstr "exists"

# 3ad285524a3845abb360c97c1282895a
#: ../../ref/models/querysets.txt:2283
msgid ""
"Returns ``True`` if the :class:`.QuerySet` contains any results, and "
"``False`` if not. This tries to perform the query in the simplest and "
"fastest way possible, but it *does* execute nearly the same query as a "
"normal :class:`.QuerySet` query."
msgstr ""
"Возвращает ``True`` если :class:`.QuerySet` содержит какой-либо результат, "
"иначе - ``False``. Выполняет на столько простой и быстрый запрос, на сколько "
"это возможно, почти идентичный обычному запросу :class:`.QuerySet`."

# 437dcb476eac4f15adf69bc23744e8e1
#: ../../ref/models/querysets.txt:2288
msgid ""
":meth:`~.QuerySet.exists` is useful for searches relating to both object "
"membership in a :class:`.QuerySet` and to the existence of any objects in a :"
"class:`.QuerySet`, particularly in the context of a large :class:`.QuerySet`."
msgstr ""
":meth:`~.QuerySet.exists` полезен для определения нахождения объекта в :"
"class:`.QuerySet` и наличия какого-либо объекта в :class:`.QuerySet`, "
"особенно для больших :class:`.QuerySet`."

# 01eec27a41dd4a268277947f41b655e2
#: ../../ref/models/querysets.txt:2292
msgid ""
"The most efficient method of finding whether a model with a unique field (e."
"g. ``primary_key``) is a member of a :class:`.QuerySet` is::"
msgstr ""
"Самый эффективный способ определить принадлежит ли объект с уникальным полем "
"(например, ``primary_key``) какому-либо :class:`.QuerySet`::"

# c29c5015b9e8455d8a2dee56df6e1da2
#: ../../ref/models/querysets.txt:2299
msgid ""
"Which will be faster than the following which requires evaluating and "
"iterating through the entire queryset::"
msgstr ""
"Что будет на много быстрее, чем получение и итерация по всему результату::"

# 20b63c866c9f4ebda7664ecb46d64f61
#: ../../ref/models/querysets.txt:2305
msgid "And to find whether a queryset contains any items::"
msgstr "И для определения есть ли какой-либо объект в результате::"

# c0eb7a77829747719027f3a30a7a0420
#: ../../ref/models/querysets.txt:2310
msgid "Which will be faster than::"
msgstr "Это будет быстрее чем::"

# b016e9f883734062aba44f6fad62f527
#: ../../ref/models/querysets.txt:2315
msgid ""
"... but not by a large degree (hence needing a large queryset for efficiency "
"gains)."
msgstr ""
"... но не на много(разве что результат содержит большое количество записей)."

# 3f644a7cf9d44244b98391c7769cf49f
#: ../../ref/models/querysets.txt:2318
msgid ""
"Additionally, if a ``some_queryset`` has not yet been evaluated, but you "
"know that it will be at some point, then using ``some_queryset.exists()`` "
"will do more overall work (one query for the existence check plus an extra "
"one to later retrieve the results) than simply using "
"``bool(some_queryset)``, which retrieves the results and then checks if any "
"were returned."
msgstr ""
"Если ``some_queryset`` не был еще вычислен, но вы точно знаете что будет "
"вычислен в любом случае, тогда вызов ``some_query_set.exists()`` выполнит "
"больше работы (один запрос для проверки наличия данных и один для получения "
"данных) чем просто ``bool(some_queryset)``, который получит результат и "
"проверит не пустой ли он."

# 2572fda74ca44d289833cc0cba802033
#: ../../ref/models/querysets.txt:2325
#, fuzzy
msgid "``update()``"
msgstr "update"

# a4c91155b1dd41c88ec0db1a173a3b46
#: ../../ref/models/querysets.txt:2329
msgid ""
"Performs an SQL update query for the specified fields, and returns the "
"number of rows matched (which may not be equal to the number of rows updated "
"if some rows already have the new value)."
msgstr ""
"Выполняет SQL запрос, обновляющий данные указанных полей и возвращает "
"количество измененных записей(которое может быть не равно количеству "
"обновленных записей, если некоторые из них уже содержали новое значение)."

# 7e03b96273aa49a58c2db0cb2894a390
#: ../../ref/models/querysets.txt:2333
msgid ""
"For example, to turn comments off for all blog entries published in 2010, "
"you could do this::"
msgstr ""
"Например, чтобы отключить комментарии для всех записей опубликованных в 2010 "
"годы, нужно выполнить такой запрос::"

# 22cf494cf25d42b0929e99b30ec9f3e9
#: ../../ref/models/querysets.txt:2338
msgid ""
"(This assumes your ``Entry`` model has fields ``pub_date`` and "
"``comments_on``.)"
msgstr ""
"(Пример подразумевает что модель ``Entry`` содержит поля ``pub_date`` и "
"``comments_on``.)"

# faf468726ffc4ef5a6b9160a2a9b0a9c
#: ../../ref/models/querysets.txt:2340
msgid ""
"You can update multiple fields — there's no limit on how many. For example, "
"here we update the ``comments_on`` and ``headline`` fields::"
msgstr ""
"Вы можете изменить несколько полей — нет ограничения на количество полей. "
"Например, изменим поля ``comments_on`` и ``headline``::"

# d5effcc09c334221bc79a2fc6dc3569a
#: ../../ref/models/querysets.txt:2345
msgid ""
"The ``update()`` method is applied instantly, and the only restriction on "
"the :class:`.QuerySet` that is updated is that it can only update columns in "
"the model's main table, not on related models. You can't do this, for "
"example::"
msgstr ""
"Метод ``update()`` выполняет запрос сразу после вызова метода. Единственное "
"ограничение для :class:`.QuerySet` это то, что могут быть изменены поля "
"только главной модели, а не связанной. Вы не можете сделать такое::"

# 3a55314724fb4f5d8a6c460c9898300b
#: ../../ref/models/querysets.txt:2351
msgid "Filtering based on related fields is still possible, though::"
msgstr "Однако вы можете использовать фильтры по полям связанной модели::"

# 30e646114e6c458fb47e302c6b7911df
#: ../../ref/models/querysets.txt:2355
msgid ""
"You cannot call ``update()`` on a :class:`.QuerySet` that has had a slice "
"taken or can otherwise no longer be filtered."
msgstr ""
"Метод ``update()`` не может быть вызван для :class:`.QuerySet` с примененным "
"срезом, или который не может быть отфильтрован по какой-либо другой причине."

# c685709233f040009860bd95b74cc47c
#: ../../ref/models/querysets.txt:2358
msgid "The ``update()`` method returns the number of affected rows::"
msgstr "Метод ``update()`` возвращает количество измененных записей::"

# 13882289825d4bdd8a6e8498e59f6c97
#: ../../ref/models/querysets.txt:2369
msgid ""
"If you're just updating a record and don't need to do anything with the "
"model object, the most efficient approach is to call ``update()``, rather "
"than loading the model object into memory. For example, instead of doing "
"this::"
msgstr ""
"Если вам нужно всего лишь изменить запись и не нужно ничего делать с "
"объектом модели, более эффективно использовать метод ``update()``, чем "
"загружать объект в память. Например, вместо этого::"

# dd5ce4a1ef454fba9c4043eb63f68545
#: ../../ref/models/querysets.txt:2377
msgid "...do this::"
msgstr "...делайте так::"

# ca0d678b2a9e4e418c2b1aa668532a32
#: ../../ref/models/querysets.txt:2381
msgid ""
"Using ``update()`` also prevents a race condition wherein something might "
"change in your database in the short period of time between loading the "
"object and calling ``save()``."
msgstr ""
"Использование ``update()`` также предотвращает ситуации, когда что-то может "
"быть изменено в базе данных в тот короткий период времени между загрузкой "
"данных и вызовом ``save()``."

# e0ebad2b134c44c79b449bc990b41f33
#: ../../ref/models/querysets.txt:2385
msgid ""
"Finally, realize that ``update()`` does an update at the SQL level and, "
"thus, does not call any ``save()`` methods on your models, nor does it emit "
"the :attr:`~django.db.models.signals.pre_save` or :attr:`~django.db.models."
"signals.post_save` signals (which are a consequence of calling :meth:`Model."
"save() <django.db.models.Model.save>`). If you want to update a bunch of "
"records for a model that has a custom :meth:`~django.db.models.Model.save()` "
"method, loop over them and call :meth:`~django.db.models.Model.save()`, like "
"this::"
msgstr ""
"Учтите, что метод ``update()`` использует непосредственно SQL запрос. Метод "
"``save()`` модели не будет вызван, сигналы :attr:`~django.db.models.signals."
"pre_save` или :attr:`~django.db.models.signals.post_save` не будут вызваны "
"(которые являются следствием вызова :meth:`Model.save() <django.db.models."
"Model.save>`). Если вы хотите обновить объекты модели с переопределенным "
"методом :meth:`~django.db.models.Model.save()`, пройдитесь по каждому и "
"вызовите метод :meth:`~django.db.models.Model.save()`, например::"

# 4b8f43a4018a42c0a1a66605ecbb75e3
#: ../../ref/models/querysets.txt:2399
#, fuzzy
msgid "``delete()``"
msgstr "delete"

# 53f0a6c8591d4972bdf8ba341367186e
#: ../../ref/models/querysets.txt:2403
msgid ""
"Performs an SQL delete query on all rows in the :class:`.QuerySet` and "
"returns the number of objects deleted and a dictionary with the number of "
"deletions per object type."
msgstr ""
"Выполняет SQL запрос для удаления записей в :class:`.QuerySet` и возвращает "
"количество удаленных объектов, и словарь с количеством удаленных объектов "
"для каждого типа объекта."

# 30e646114e6c458fb47e302c6b7911df
#: ../../ref/models/querysets.txt:2407
msgid ""
"The ``delete()`` is applied instantly. You cannot call ``delete()`` on a :"
"class:`.QuerySet` that has had a slice taken or can otherwise no longer be "
"filtered."
msgstr ""
"Метод ``delete()`` выполняют запрос сразу после вызова метода. Метод "
"``delete()`` не может быть выполнен для :class:`.QuerySet`, к которому был "
"применен срез или который не может быть отфильтрован по любой другой причине."

# c625ae58e6e74f64ae4700d54defa837
#: ../../ref/models/querysets.txt:2411
msgid "For example, to delete all the entries in a particular blog::"
msgstr "Например, удалим все записи для определенного блога::"

# 8846a1b9b7c34df0b9d4d3395ce93ab6
#: ../../ref/models/querysets.txt:2419
msgid ""
"By default, Django's :class:`~django.db.models.ForeignKey` emulates the SQL "
"constraint ``ON DELETE CASCADE`` — in other words, any objects with foreign "
"keys pointing at the objects to be deleted will be deleted along with them. "
"For example::"
msgstr ""
"По-умолчанию, Django для :class:`~django.db.models.ForeignKey` эмулирует "
"поведение ``ON DELETE CASCADE`` в SQL — другими словами, объекты, имеющие "
"внешние ключи на удаляемый объект, будут удалены. Например::"

# bf469a4f57424409857e959dc7d3912d
#: ../../ref/models/querysets.txt:2430
msgid ""
"This cascade behavior is customizable via the :attr:`~django.db.models."
"ForeignKey.on_delete` argument to the :class:`~django.db.models.ForeignKey`."
msgstr ""
"Такое каскадное поведение можно настроить, используя аргумент :attr:`~django."
"db.models.ForeignKey.on_delete` для поля :class:`~django.db.models."
"ForeignKey`."

# 84906fc72d9a421d9671ed99afe8aafb
#: ../../ref/models/querysets.txt:2434
msgid ""
"The ``delete()`` method does a bulk delete and does not call any "
"``delete()`` methods on your models. It does, however, emit the :data:"
"`~django.db.models.signals.pre_delete` and :data:`~django.db.models.signals."
"post_delete` signals for all deleted objects (including cascaded deletions)."
msgstr ""
"Метод ``delete()`` выполняет массовое удаление и не вызывает метод "
"``delete()`` модели. Однако, будут вызваны сигналы :data:`~django.db.models."
"signals.pre_delete` и :data:`~django.db.models.signals.post_delete` для всех "
"удаленных объектов (включая объекты, удаленные каскадным удалением)."

# 7f89c058ecec4ce9a26da380e2f3747a
#: ../../ref/models/querysets.txt:2440
msgid ""
"Django needs to fetch objects into memory to send signals and handle "
"cascades. However, if there are no cascades and no signals, then Django may "
"take a fast-path and delete objects without fetching into memory. For large "
"deletes this can result in significantly reduced memory usage. The amount of "
"executed queries can be reduced, too."
msgstr ""
"Django необходимо загрузить все объекты в память и послать сигнал для "
"каскадной обработки. Однако, если нет необходимости в посылании сигнала для "
"каскадного поведения, Django может удалить объекты без загрузки в память. "
"При удалении большого количества объектов, можно значительно сократить "
"количество используемой памяти. Также сократится количество запросов."

# d1fdf64b1c9344908c5be2a25a0fdec0
#: ../../ref/models/querysets.txt:2446
msgid ""
"ForeignKeys which are set to :attr:`~django.db.models.ForeignKey.on_delete` "
"``DO_NOTHING`` do not prevent taking the fast-path in deletion."
msgstr ""
"Внешние ключи со значением :attr:`~django.db.models.ForeignKey.on_delete` "
"``DO_NOTHING`` не мешают быстрому удалению."

# 8dcfa05df51b4108ac3173385f3f448d
#: ../../ref/models/querysets.txt:2449
msgid ""
"Note that the queries generated in object deletion is an implementation "
"detail subject to change."
msgstr ""
"Заметим, что запросы, созданные при удалении объектов не обсуждаются т.к. "
"являются деталями реализации Django."

# a58a0f02305d4c7ea1a0570c703e261d
#: ../../ref/models/querysets.txt:2453
#, fuzzy
msgid "``as_manager()``"
msgstr "as_manager"

# f3bf567b6bad4befa362bcd7f10e9fee
#: ../../ref/models/querysets.txt:2457
msgid ""
"Class method that returns an instance of :class:`~django.db.models.Manager` "
"with a copy of the ``QuerySet``’s methods. See :ref:`create-manager-with-"
"queryset-methods` for more details."
msgstr ""
"Метод класса, который возвращает экземпляр :class:`~django.db.models."
"Manager`, который содержит копию методов ``QuerySet``. Смотрите :ref:`create-"
"manager-with-queryset-methods`."

# 6f7c8ae944d44149a7f4ff47bcd9d252
#: ../../ref/models/querysets.txt:2464
#, fuzzy
msgid "``Field`` lookups"
msgstr "Операторы фильтрации"

# 51a52e84582f4171938ee8b0bfc913cf
#: ../../ref/models/querysets.txt:2466
msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the ``QuerySet`` methods :meth:"
"`filter()`, :meth:`exclude()` and :meth:`get()`."
msgstr ""
"Операторы фильтрации используются для создания оператора ``WHERE`` в SQL. "
"Они используются как именованные аргументы для методов ``QuerySet``: :meth:"
"`filter()`, :meth:`exclude()` и :meth:`get()`."

# ae6ddfe541a64124b34b96b3977286e6
#: ../../ref/models/querysets.txt:2470
msgid ""
"For an introduction, see :ref:`models and database queries documentation "
"<field-lookups-intro>`."
msgstr ""
"Введение смотрите в разделе о :ref:`моделях и выполнении запросов к базе "
"данных <field-lookups-intro>`."

# 2ea5fc37f3bd4f60a4cb3c8859c938a7
#: ../../ref/models/querysets.txt:2473
msgid ""
"Django's built-in lookups are listed below. It is also possible to write :"
"doc:`custom lookups </howto/custom-lookups>` for model fields."
msgstr ""
"Встроенные операторы фильтрации представлены ниже. Также можно создать :doc:"
"`собственный фильтр </howto/custom-lookups>` для поля модели."

# 3576bdef87c64b289729f7109a0d0888
#: ../../ref/models/querysets.txt:2476
msgid ""
"As a convenience when no lookup type is provided (like in ``Entry.objects."
"get(id=14)``) the lookup type is assumed to be :lookup:`exact`."
msgstr ""
"По умолчанию, если тип фильтра явно не указан (например, ``Entry.objects."
"get(id=14)``), подразумевается :lookup:`exact`."

# d477098199c549dea385dbc618304381
#: ../../ref/models/querysets.txt:2482
#, fuzzy
msgid "``exact``"
msgstr "``select``"

# a9234d56d6b84edbbf3b8d8794028b17
#: ../../ref/models/querysets.txt:2484
msgid ""
"Exact match. If the value provided for comparison is ``None``, it will be "
"interpreted as an SQL ``NULL`` (see :lookup:`isnull` for more details)."
msgstr ""
"Точное совпадение. Если передано значение ``None``, оно будет "
"интерпретировано как SQL ``NULL`` (смотрите подробности в описании :lookup:"
"`isnull`)."

# d332fc1c658a4492ae9b562a479dfdab
# 24d5295c790c46f9a975fcd88f1e3ba7
# 86bd9402d19f48fe82b1bf3e6b1ee382
#: ../../ref/models/querysets.txt:2492 ../../ref/models/querysets.txt:2520
#: ../../ref/models/querysets.txt:3077 ../../ref/models/querysets.txt:3101
msgid "SQL equivalents::"
msgstr "Аналог SQL::"

# d336d94e2981416cab4f703c9a8b483a
#: ../../ref/models/querysets.txt:2497
msgid "MySQL comparisons"
msgstr "Сравнение в MySQL"

# 56ead27abcc8461283aa4cf1d6797f50
#: ../../ref/models/querysets.txt:2499
msgid ""
"In MySQL, a database table's \"collation\" setting determines whether "
"``exact`` comparisons are case-sensitive. This is a database setting, *not* "
"a Django setting. It's possible to configure your MySQL tables to use case-"
"sensitive comparisons, but some trade-offs are involved. For more "
"information about this, see the :ref:`collation section <mysql-collation>` "
"in the :doc:`databases </ref/databases>` documentation."
msgstr ""
"В MySQL, настройка \"collation\" таблицы базы данных определяет будет ли "
"использовано регистрозависимое сравнение для ``exact``. Это настройка базы "
"данных, *не* Django. Можно настроить регистрозависимое сравнение для таблиц "
"MySQL. Подробности смотрите в :ref:`разделе о сравнении <mysql-collation>` "
"документации о :doc:`базах данных </ref/databases>`."

# ecfdd7bed2094711a71275393092098b
#: ../../ref/models/querysets.txt:2509
#, fuzzy
msgid "``iexact``"
msgstr "iexact"

# a9234d56d6b84edbbf3b8d8794028b17
#: ../../ref/models/querysets.txt:2511
msgid ""
"Case-insensitive exact match. If the value provided for comparison is "
"``None``, it will be interpreted as an SQL ``NULL`` (see :lookup:`isnull` "
"for more details)."
msgstr ""
"Точное совпадение, регистро-независимое. Если передано значение ``None``, "
"оно будет интерпретировано как SQL ``NULL`` (смотрите подробности в "
"описании :lookup:`isnull`)."

# 24fc5adf9f7c4fafab99fa1468e29d2b
#: ../../ref/models/querysets.txt:2525
msgid ""
"Note the first query will match ``'Beatles Blog'``, ``'beatles blog'``, "
"``'BeAtLes BLoG'``, etc."
msgstr ""
"Обратите внимание, будет найден ``'Beatles Blog'``, ``'beatles blog'``, "
"``'BeAtLes BLoG'`` и тд."

# 5721949e947344ab938e482a15c53876
# 753c500df00346ea825479d890567eb0
# 3f9f778d286d4b8a86af907ab87f2071
# 8bc25df1174b413f8ff49fa1d317d625
# cbab254db9324ded81da966f8b75210b
# cdeef32237c64a06ba3c4d8d28eccddd
#: ../../ref/models/querysets.txt:2528 ../../ref/models/querysets.txt:2552
#: ../../ref/models/querysets.txt:2574 ../../ref/models/querysets.txt:2707
#: ../../ref/models/querysets.txt:2727 ../../ref/models/querysets.txt:2748
msgid "SQLite users"
msgstr "Пользователям SQLite"

# 31922d4f9efd46af950059bc8e326b70
#: ../../ref/models/querysets.txt:2530
#, fuzzy
msgid ""
"When using the SQLite backend and non-ASCII strings, bear in mind the :ref:"
"`database note <sqlite-string-matching>` about string comparisons. SQLite "
"does not do case-insensitive matching for non-ASCII strings."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`. SQLite не выполняет "
"регистронезависимое сравнение Unicode строк."

# dbbc4737795e4a4885885819f055ddb6
#: ../../ref/models/querysets.txt:2537
#, fuzzy
msgid "``contains``"
msgstr "contains"

# 67343a542c2b4215be9327d0e4f1f55b
#: ../../ref/models/querysets.txt:2539
msgid "Case-sensitive containment test."
msgstr "Регистрозависимая проверка на вхождение."

# 46ea26d2a9f244268a100e9407d40d85
# 92ad5423ba9541819e942c734c6e7666
# 03305512d68f48819d082dcdf473db96
# 5c74e2dcd6d444c9a19dc3c73f649aa4
# 5aa8d6e8618c48c3be94d5c26a271fc5
# 48d1b44753ff4301be6c7f0f193e237d
# 905fc69346a2456babd76b663155d0c2
# 049c7c7798ce4d2a9b2f4e073e1dba4a
# 09afe94e5a654a16bfc456dc68636596
# 4a393b64d51d47eea9b79c0d803d4108
# 17e3207b845540da8abb27b21bdff0d4
# d64f76ce7139449695a255ca3fd0764d
# 7951d6720d58440a904b19337aac5c5c
# 8379281c0c194dfe8d56ed8b7c2dd56f
# c28ee383e69e4fc2bf54dfbf03ea8dcb
#: ../../ref/models/querysets.txt:2545 ../../ref/models/querysets.txt:2570
#: ../../ref/models/querysets.txt:2590 ../../ref/models/querysets.txt:2649
#: ../../ref/models/querysets.txt:2685 ../../ref/models/querysets.txt:2703
#: ../../ref/models/querysets.txt:2723 ../../ref/models/querysets.txt:2744
#: ../../ref/models/querysets.txt:2767 ../../ref/models/querysets.txt:2817
#: ../../ref/models/querysets.txt:2840 ../../ref/models/querysets.txt:2864
#: ../../ref/models/querysets.txt:2984 ../../ref/models/querysets.txt:3009
#: ../../ref/models/querysets.txt:3034 ../../ref/models/querysets.txt:3057
msgid "SQL equivalent::"
msgstr "Аналог SQL::"

# e5d327a989cb4a898992968cc8489424
#: ../../ref/models/querysets.txt:2549
msgid ""
"Note this will match the headline ``'Lennon honored today'`` but not "
"``'lennon honored today'``."
msgstr ""
"Заметим, что будет найдена строка ``'Lennon honored today'``, но не "
"``'lennon honored today'``."

# d7808b395aa945fa9d064e4b5430a13c
#: ../../ref/models/querysets.txt:2554
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``contains`` acts "
"like ``icontains`` for SQLite. See the :ref:`database note <sqlite-string-"
"matching>` for more information."
msgstr ""
"SQLite не поддерживает регистрозависимый оператор ``LIKE``; ``contains`` "
"работает так же как и ``icontains`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 3fd1c8a55daf4573977c0a7222291e88
#: ../../ref/models/querysets.txt:2562
#, fuzzy
msgid "``icontains``"
msgstr "icontains"

# 77b1dc9d5c064180abdc64a1ca07f124
#: ../../ref/models/querysets.txt:2564
msgid "Case-insensitive containment test."
msgstr "Регистронезависимая проверка на вхождение."

# 3a8bf3be9bb64a409e14445f8ec03060
# e63d0675b70646bd88a85572c3fafc4e
# 19daad0c85bd4d89953acee3b9f59a77
#: ../../ref/models/querysets.txt:2576 ../../ref/models/querysets.txt:2709
#: ../../ref/models/querysets.txt:2750
#, fuzzy
msgid ""
"When using the SQLite backend and non-ASCII strings, bear in mind the :ref:"
"`database note <sqlite-string-matching>` about string comparisons."
msgstr ""
"Используя SQLite и Unicode (не-ASCII) строки, помните :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

#: ../../ref/models/querysets.txt:2582
msgid "``in``"
msgstr ""

#: ../../ref/models/querysets.txt:2584
msgid "In a given iterable; often a list, tuple, or queryset."
msgstr ""

# 060a14ce774b4558bbe7f4a1d5be3445
#: ../../ref/models/querysets.txt:2594
msgid ""
"You can also use a queryset to dynamically evaluate the list of values "
"instead of providing a list of literal values::"
msgstr "Вы можете также передать ``QuerySet`` для получения списка значений::"

# 09549617c55b4da0be0d7c80bd940757
#: ../../ref/models/querysets.txt:2600
msgid "This queryset will be evaluated as subselect statement::"
msgstr "Он будет использован как подзапрос::"

# 4a105d294b9e4eefa408d733720bc6a7
#: ../../ref/models/querysets.txt:2604
msgid ""
"If you pass in a ``QuerySet`` resulting from ``values()`` or "
"``values_list()`` as the value to an ``__in`` lookup, you need to ensure you "
"are only extracting one field in the result. For example, this will work "
"(filtering on the blog names)::"
msgstr ""
"Передавая в ``QuerySet``, который является результат вызова ``values()`` или "
"``values_list()``, как аргумент для фильтра ``__in``, вы должны быть "
"уверенным, что результат содержит данные только одного поля. Например, этот "
"код будет работать (фильтр по названиям блога)::"

# 6e61d91c22c44361af2c75b994c0cdc2
#: ../../ref/models/querysets.txt:2612
msgid ""
"This example will raise an exception, since the inner query is trying to "
"extract two field values, where only one is expected::"
msgstr ""
"Этот пример вызовет исключение т.к. подзапрос выбирает два поля в то время, "
"как ожидается одно::"

# 85c53b20156f42f7b4521042293c1446
#: ../../ref/models/querysets.txt:2621
msgid "Performance considerations"
msgstr "О производительности"

# 1894acc1d7c04b8da51f2a490e298bef
#: ../../ref/models/querysets.txt:2623
msgid ""
"Be cautious about using nested queries and understand your database server's "
"performance characteristics (if in doubt, benchmark!). Some database "
"backends, most notably MySQL, don't optimize nested queries very well. It is "
"more efficient, in those cases, to extract a list of values and then pass "
"that into the second query. That is, execute two queries instead of one::"
msgstr ""
"Будьте осторожны при использовании вложенных запросов и учитывайте "
"производительность вышей базы данных (если сомневаетесь, протестируйте "
"его!). Некоторые типы баз данных, особенно MySQL, не очень хорошо "
"оптимизируют вложенные запросы. В таком случае более эффективно получить "
"список значений первым запросом и передать в другой::"

# 3dffaf2d368b41228ba28d3674580965
#: ../../ref/models/querysets.txt:2634
msgid ""
"Note the ``list()`` call around the Blog ``QuerySet`` to force execution of "
"the first query. Without it, a nested query would be executed, because :ref:"
"`querysets-are-lazy`."
msgstr ""
"Отметим использование ``list()`` с первым ``QuerySet``, чтобы спровоцировать "
"выполнение запроса. Без этого, он будет использован как подзапрос т.к. :ref:"
"`querysets-are-lazy`."

#: ../../ref/models/querysets.txt:2641
msgid "``gt``"
msgstr ""

# 298b78972f8445dcb2ac8f0f189e6096
#: ../../ref/models/querysets.txt:2643
msgid "Greater than."
msgstr "Больше чем."

#: ../../ref/models/querysets.txt:2656
msgid "``gte``"
msgstr ""

# 700d1b4529a247b08eb6d54ec431bc0d
#: ../../ref/models/querysets.txt:2658
msgid "Greater than or equal to."
msgstr "Больше чем или равно."

#: ../../ref/models/querysets.txt:2663
msgid "``lt``"
msgstr ""

# 5f12fe0149774a9b86f7c8c583d35b65
#: ../../ref/models/querysets.txt:2665
msgid "Less than."
msgstr "Меньше чем."

#: ../../ref/models/querysets.txt:2670
msgid "``lte``"
msgstr ""

# e99ffbafead64b74b48a32b9d67edc85
#: ../../ref/models/querysets.txt:2672
msgid "Less than or equal to."
msgstr "Меньше чем или равно."

# 7ff40223fac34ad18eba45a83140a83b
#: ../../ref/models/querysets.txt:2677
#, fuzzy
msgid "``startswith``"
msgstr "startswith"

# 88cbfd11577c4dd183bf087d0899bef9
#: ../../ref/models/querysets.txt:2679
msgid "Case-sensitive starts-with."
msgstr "Регистрозависимая проверка начинается ли поле с указанного значения."

# 92612c5066fb4c5ca34d09c691000470
#: ../../ref/models/querysets.txt:2689
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``startswith`` "
"acts like ``istartswith`` for SQLite."
msgstr ""
"SQLite не поддерживает регистрозависимый оператор ``LIKE``; ``startswith`` "
"работает так же как и ``istartswith`` для SQLite."

# 111d6588245743338bc6865cffd6b528
#: ../../ref/models/querysets.txt:2695
#, fuzzy
msgid "``istartswith``"
msgstr "istartswith"

# ff564778fbed4940ad6ca9079a6afb00
#: ../../ref/models/querysets.txt:2697
msgid "Case-insensitive starts-with."
msgstr "Регистронезависимая проверка начинается ли поле с указанного значения."

# 4c98a20fb2914c2c86251bb55eb9e77c
#: ../../ref/models/querysets.txt:2715
#, fuzzy
msgid "``endswith``"
msgstr "endswith"

# a000eade0e104eeb869237a1a2221e86
#: ../../ref/models/querysets.txt:2717
msgid "Case-sensitive ends-with."
msgstr "Регистрозависимая проверка оканчивается ли поле с указанного значения."

# ed826e4d9d2e44c9bf4517ef099b194f
#: ../../ref/models/querysets.txt:2729
msgid ""
"SQLite doesn't support case-sensitive ``LIKE`` statements; ``endswith`` acts "
"like ``iendswith`` for SQLite. Refer to the :ref:`database note <sqlite-"
"string-matching>` documentation for more."
msgstr ""
"SQLite не поддерживает регистрозависимый оператор ``LIKE``; ``endswith`` "
"работает так же как и ``iendswith`` для SQLite. Смотрите :ref:`замечание о "
"сравнении строк в SQLite <sqlite-string-matching>`."

# 1922221732f14962b994fd2ea4ba7f0d
#: ../../ref/models/querysets.txt:2736
#, fuzzy
msgid "``iendswith``"
msgstr "iendswith"

# 071c72167d2043aca090635e4060f292
#: ../../ref/models/querysets.txt:2738
msgid "Case-insensitive ends-with."
msgstr ""
"Регистронезависимая проверка оканчивается ли поле с указанного значения."

# 9ed5736e60ef43b8a31f2631034d5f8c
#: ../../ref/models/querysets.txt:2756
#, fuzzy
msgid "``range``"
msgstr "range"

# d4da44bd202649b08723993ca9536afc
#: ../../ref/models/querysets.txt:2758
msgid "Range test (inclusive)."
msgstr "Проверка на вхождение в диапазон (включающий)."

# 5b0e615a17dc44aa88d03060f4da36fa
#: ../../ref/models/querysets.txt:2771
msgid ""
"You can use ``range`` anywhere you can use ``BETWEEN`` in SQL — for dates, "
"numbers and even characters."
msgstr ""
"Вы можете использовать ``range`` там же, где можно использовать ``BETWEEN`` "
"в SQL — для дат, чисел и даже строк."

# cbc6051bce8b47f483abef9bbbf52dd1
#: ../../ref/models/querysets.txt:2776
msgid ""
"Filtering a ``DateTimeField`` with dates won't include items on the last "
"day, because the bounds are interpreted as \"0am on the given date\". If "
"``pub_date`` was a ``DateTimeField``, the above expression would be turned "
"into this SQL::"
msgstr ""
"Фильтрация ``DateTimeField`` по датам не включит записи последнего дня, так "
"как границы интерпретируются как \"00:00 указанного дня\". Если ``pub_date`` "
"было ``DateTimeField``, мы бы получили следующий SQL запрос::"

# 5c754e62cf0f45c29f94439364df0eaf
#: ../../ref/models/querysets.txt:2783
msgid "Generally speaking, you can't mix dates and datetimes."
msgstr "В общем вы не можете использовать date и datetime вместе."

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:2788
#, fuzzy
msgid "``date``"
msgstr "date"

#: ../../ref/models/querysets.txt:2790
msgid ""
"For datetime fields, casts the value as date. Allows chaining additional "
"field lookups. Takes a date value."
msgstr ""
"Для поля даты и времени преобразует значение в дату. Позволяет использовать "
"дополнительные проверки поля. Принимает дату."

# 9c3d1a50ec6e4c268855f16ee1bf6b13
#: ../../ref/models/querysets.txt:2798 ../../ref/models/querysets.txt:2894
#: ../../ref/models/querysets.txt:2916 ../../ref/models/querysets.txt:2942
#: ../../ref/models/querysets.txt:2964
msgid ""
"(No equivalent SQL code fragment is included for this lookup because "
"implementation of the relevant query varies among different database "
"engines.)"
msgstr ""
"(Аналог SQL не представлен т.к. реализация отличается для различных баз "
"данных.)"

# ecf5440bd93740eeb2573c7040cf13a1
# 6dafa4cefdb942d59883f89e03fe2ede
# 07eee6920e6948afbe05d413239c5fa9
#: ../../ref/models/querysets.txt:2801 ../../ref/models/querysets.txt:2897
#: ../../ref/models/querysets.txt:2967
msgid ""
"When :setting:`USE_TZ` is ``True``, fields are converted to the current time "
"zone before filtering."
msgstr ""
"При :setting:`USE_TZ` равном ``True``, значение поля будет преобразовано в "
"текущий часовой пояс."

# f4d814190b4344149dbc839518920ac4
#: ../../ref/models/querysets.txt:2807
#, fuzzy
msgid "``year``"
msgstr "year"

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:2809
msgid ""
"For date and datetime fields, an exact year match. Allows chaining "
"additional field lookups. Takes an integer year."
msgstr ""
"Проверка года для полей date/datetime. Позволяет использовать дополнительные "
"проверки поля. Принимает числовое значение года."

# 29083d0d847d4a7e8bff552fb33ec6c8
# 56fee1cc131943e1922b92d0ce10e52e
# 8c63272bae8e4af4b3187a69dae74c62
#: ../../ref/models/querysets.txt:2822 ../../ref/models/querysets.txt:2845
#: ../../ref/models/querysets.txt:2869 ../../ref/models/querysets.txt:2990
#: ../../ref/models/querysets.txt:3015 ../../ref/models/querysets.txt:3040
msgid "(The exact SQL syntax varies for each database engine.)"
msgstr "(Точный синтаксис SQL зависит от базы данных.)"

# ca86f547fe3e4d25ae9bcceddbea4f06
#: ../../ref/models/querysets.txt:2824
msgid ""
"When :setting:`USE_TZ` is ``True``, datetime fields are converted to the "
"current time zone before filtering."
msgstr ""
"При :setting:`USE_TZ` равном ``True``, значение поля datetime будет "
"преобразовано в текущий часовой пояс."

# 003f2b547be24a74b2a8ffcb2f3a0d8a
#: ../../ref/models/querysets.txt:2830
#, fuzzy
msgid "``month``"
msgstr "month"

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:2832
msgid ""
"For date and datetime fields, an exact month match. Allows chaining "
"additional field lookups. Takes an integer 1 (January) through 12 (December)."
msgstr ""
"Проверка месяца для полей date/datetime. Позволяет использовать "
"дополнительные проверки поля. Принимает целое число от 1 (январь) до 12 "
"(декабрь)."

# d7ac25bd166447f6a18f68c10dcead4d
# 1657530897cb450aaf3a77912c1aed93
# e65ec0b30af046eead5d5a0a254828c0
#: ../../ref/models/querysets.txt:2847 ../../ref/models/querysets.txt:2874
#: ../../ref/models/querysets.txt:2923 ../../ref/models/querysets.txt:2945
msgid ""
"When :setting:`USE_TZ` is ``True``, datetime fields are converted to the "
"current time zone before filtering. This requires :ref:`time zone "
"definitions in the database <database-time-zone-definitions>`."
msgstr ""
"При :setting:`USE_TZ` равном ``True``, значение поля datetime будет "
"преобразовано в текущий часовой пояс. Для этого необходимо :ref:`настроить "
"часовые пояса для базы данных <database-time-zone-definitions>`."

#: ../../ref/models/querysets.txt:2854
msgid "``day``"
msgstr ""

# 774d8c63fc154b85a91ae9aba6b60abd
#: ../../ref/models/querysets.txt:2856
msgid ""
"For date and datetime fields, an exact day match. Allows chaining additional "
"field lookups. Takes an integer day."
msgstr ""
"Проверка дня месяца для полей date/datetime. Позволяет использовать "
"дополнительные проверки поля. Принимает номер дня месяца."

# 86d6c940d9aa427d822aae2f525b374c
#: ../../ref/models/querysets.txt:2871
msgid ""
"Note this will match any record with a pub_date on the third day of the "
"month, such as January 3, July 3, etc."
msgstr ""
"Заметим, что будут найдены записи, у которых значение ``pub_date`` это дата "
"3-го числа любого месяца, такие как 3-го января, 3-го июля и тд."

# 431be0498e904a54ad9c34278ca3bbb4
#: ../../ref/models/querysets.txt:2881
#, fuzzy
msgid "``week``"
msgstr "week_day"

#: ../../ref/models/querysets.txt:2885
msgid ""
"For date and datetime fields, return the week number (1-52 or 53) according "
"to `ISO-8601 <https://en.wikipedia.org/wiki/ISO-8601>`_, i.e., weeks start "
"on a Monday and the first week contains the year's first Thursday."
msgstr ""

# 431be0498e904a54ad9c34278ca3bbb4
#: ../../ref/models/querysets.txt:2903
#, fuzzy
msgid "``week_day``"
msgstr "week_day"

# 92392f5c054441589284b93eadbeef2e
#: ../../ref/models/querysets.txt:2905
msgid ""
"For date and datetime fields, a 'day of the week' match. Allows chaining "
"additional field lookups."
msgstr ""
"Проверка дня недели для полей date/datetime. Позволяет использовать "
"дополнительные проверки поля."

# 3b6f9608043a48feb7b8fedd160c34c3
#: ../../ref/models/querysets.txt:2908
msgid ""
"Takes an integer value representing the day of week from 1 (Sunday) to 7 "
"(Saturday)."
msgstr "Принимает номер дня недели от 1 (воскресение) до 7 (суббота)."

# 567c6d131a684d7a8d1019ac60c9749f
#: ../../ref/models/querysets.txt:2919
msgid ""
"Note this will match any record with a ``pub_date`` that falls on a Monday "
"(day 2 of the week), regardless of the month or year in which it occurs. "
"Week days are indexed with day 1 being Sunday and day 7 being Saturday."
msgstr ""
"Будут найдены записи, у которых дата в ``pub_date`` -- понедельник (второй "
"день недели), независимо от месяца и года. Дни недели пронумерованы от "
"1(воскресение) до 7(суббота)."

#: ../../ref/models/querysets.txt:2930
msgid "``quarter``"
msgstr ""

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:2934
#, fuzzy
msgid ""
"For date and datetime fields, a 'quarter of the year' match. Allows chaining "
"additional field lookups. Takes an integer value between 1 and 4 "
"representing the quarter of the year."
msgstr ""
"Проверка года для полей date/datetime. Позволяет использовать дополнительные "
"проверки поля. Принимает числовое значение года."

#: ../../ref/models/querysets.txt:2938
msgid ""
"Example to retrieve entries in the second quarter (April 1 to June 30)::"
msgstr ""

# 357b1daa9bcd4dea9ec83499a76f89d3
#: ../../ref/models/querysets.txt:2952
#, fuzzy
msgid "``time``"
msgstr "datetimes"

#: ../../ref/models/querysets.txt:2956
#, fuzzy
msgid ""
"For datetime fields, casts the value as time. Allows chaining additional "
"field lookups. Takes a :class:`datetime.time` value."
msgstr ""
"Для поля даты и времени преобразует значение в дату. Позволяет использовать "
"дополнительные проверки поля. Принимает дату."

# 2c265bf22e7546199e257c59162de6b3
#: ../../ref/models/querysets.txt:2973
#, fuzzy
msgid "``hour``"
msgstr "hour"

# fd13d794f2a2494689122c5fc066e0cd
#: ../../ref/models/querysets.txt:2975
msgid ""
"For datetime and time fields, an exact hour match. Allows chaining "
"additional field lookups. Takes an integer between 0 and 23."
msgstr ""
"Проверка часа для полей date/datetime. Позволяет использовать дополнительные "
"проверки поля. Принимает число от 0 до 23."

# ecf5440bd93740eeb2573c7040cf13a1
# 6dafa4cefdb942d59883f89e03fe2ede
# 07eee6920e6948afbe05d413239c5fa9
#: ../../ref/models/querysets.txt:2992 ../../ref/models/querysets.txt:3042
msgid ""
"For datetime fields, when :setting:`USE_TZ` is ``True``, values are "
"converted to the current time zone before filtering."
msgstr ""
"При :setting:`USE_TZ` равном ``True``, значение будет преобразовано в "
"текущий часовой пояс перед фильтрацией."

# 923004e7068d457e8cd0b2a01c193ba6
#: ../../ref/models/querysets.txt:2998
#, fuzzy
msgid "``minute``"
msgstr "minute"

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:3000
msgid ""
"For datetime and time fields, an exact minute match. Allows chaining "
"additional field lookups. Takes an integer between 0 and 59."
msgstr ""
"Проверка минуты для полей date/datetime. Позволяет использовать "
"дополнительные проверки поля. Принимает целое число от 0 до 59."

# ecf5440bd93740eeb2573c7040cf13a1
# 6dafa4cefdb942d59883f89e03fe2ede
# 07eee6920e6948afbe05d413239c5fa9
#: ../../ref/models/querysets.txt:3017
msgid ""
"For datetime fields, When :setting:`USE_TZ` is ``True``, values are "
"converted to the current time zone before filtering."
msgstr ""
"При :setting:`USE_TZ` равном ``True``, значение будет преобразовано в "
"текущий часовой пояс перед фильтрацией."

# d4a6e72b8d13474bb43911547f92f1c6
#: ../../ref/models/querysets.txt:3023
#, fuzzy
msgid "``second``"
msgstr "second"

# 8ab04c7938334d4cb1b2571c04614547
#: ../../ref/models/querysets.txt:3025
msgid ""
"For datetime and time fields, an exact second match. Allows chaining "
"additional field lookups. Takes an integer between 0 and 59."
msgstr ""
"Проверка секунды для полей date/datetime. Позволяет использовать "
"дополнительные проверки поля. Принимает целое число от 0 до 59."

# 0f8c1aba3b344712a47b748a97f71791
#: ../../ref/models/querysets.txt:3048
#, fuzzy
msgid "``isnull``"
msgstr "isnull"

# b960054304bd41fb8c7ecfedc385b26b
#: ../../ref/models/querysets.txt:3050
msgid ""
"Takes either ``True`` or ``False``, which correspond to SQL queries of ``IS "
"NULL`` and ``IS NOT NULL``, respectively."
msgstr ""
"Принимает ``True`` или ``False``, что соответствует SQL запросу ``IS NULL`` "
"и ``IS NOT NULL``, соответственно."

# 6e9ccec583714105bfd48647f2903e39
#: ../../ref/models/querysets.txt:3064
#, fuzzy
msgid "``regex``"
msgstr "regex"

# 227495836b474b5986622a6c1950ac2b
#: ../../ref/models/querysets.txt:3066
msgid "Case-sensitive regular expression match."
msgstr "Регистрозависимая проверка регулярным выражением."

# 740fd2774c72493b9c8e212ef912da36
#: ../../ref/models/querysets.txt:3068
msgid ""
"The regular expression syntax is that of the database backend in use. In the "
"case of SQLite, which has no built in regular expression support, this "
"feature is provided by a (Python) user-defined REGEXP function, and the "
"regular expression syntax is therefore that of Python's ``re`` module."
msgstr ""
"Синтаксис регулярных выражений зависит от базы данных. Для SQLite, который "
"не поддерживает регулярные выражения, эта функция обеспечена на уровне "
"Python, поэтому используется синтаксис модуля Python ``re``."

# 9b3fc2d9a56548c3ba11e0247a34b673
#: ../../ref/models/querysets.txt:3087
msgid ""
"Using raw strings (e.g., ``r'foo'`` instead of ``'foo'``) for passing in the "
"regular expression syntax is recommended."
msgstr ""
"Рекомендуется использовать \"raw\" строки (например, ``r'foo'`` вместо "
"``'foo'``) для регулярных выражений."

# 2d839032a9214965a439641605172826
#: ../../ref/models/querysets.txt:3093
#, fuzzy
msgid "``iregex``"
msgstr "iregex"

# 05e579fa80194fe0a677ec04c254126a
#: ../../ref/models/querysets.txt:3095
msgid "Case-insensitive regular expression match."
msgstr "Регистронезависимая проверка регулярным выражением."

# 729b14fd249648b9b31bb0ef98f94119
#: ../../ref/models/querysets.txt:3114
msgid "Aggregation functions"
msgstr "Функции агрегации"

# 0db7cc5369fc410abe92d4b71fce6968
#: ../../ref/models/querysets.txt:3118
msgid ""
"Django provides the following aggregation functions in the ``django.db."
"models`` module. For details on how to use these aggregate functions, see :"
"doc:`the topic guide on aggregation </topics/db/aggregation>`. See the :"
"class:`~django.db.models.Aggregate` documentation to learn how to create "
"your aggregates."
msgstr ""
"Django предоставляет ряд функций агрегации в модуле ``django.db.models``. "
"Подробности, как использовать функции агрегации, смотрите в :doc:`разделе об "
"агрегации </topics/db/aggregation>`. В разеделе :class:`~django.db.models."
"Aggregate` вы можете узнать как создать собственные агрегации."

# 1684120b1d984f14b5bec205b7448f67
#: ../../ref/models/querysets.txt:3126
msgid ""
"SQLite can't handle aggregation on date/time fields out of the box. This is "
"because there are no native date/time fields in SQLite and Django currently "
"emulates these features using a text field. Attempts to use aggregation on "
"date/time fields in SQLite will raise ``NotImplementedError``."
msgstr ""
"SQLite не умеет использовать агрегацию для полей даты и времени. Это потому "
"что там нет встроенных полей даты и времени и Django эмулирует их используя "
"текстовое поле. При использовании такой агрегации с SQLite вызовет "
"``NotImplementedError``."

# caee78aebf2f4f4e9c8957d01ae7fe68
#: ../../ref/models/querysets.txt:3132
msgid "Note"
msgstr "Внимание"

# 010ff6e66c4649f3acae157f5ada54e1
#: ../../ref/models/querysets.txt:3134
msgid ""
"Aggregation functions return ``None`` when used with an empty ``QuerySet``. "
"For example, the ``Sum`` aggregation function returns ``None`` instead of "
"``0`` if the ``QuerySet`` contains no entries. An exception is ``Count``, "
"which does return ``0`` if the ``QuerySet`` is empty."
msgstr ""
"Функция агрегации вернет ``None``, если используется для пустого "
"``QuerySet``. Например, ``Sum`` вернет ``None`` вместо ``0``, если "
"``QuerySet`` не содержит записей. Исключением является ``Count``, который "
"вернет ``0`` для пустого ``QuerySet``."

#: ../../ref/models/querysets.txt:3139
msgid "All aggregates have the following parameters in common:"
msgstr "Функции агрегации обычно принимают следующие параметры:"

#: ../../ref/models/querysets.txt:3142
msgid "``expression``"
msgstr "``expression``"

#: ../../ref/models/querysets.txt:3144
msgid ""
"A string that references a field on the model, or a :doc:`query expression </"
"ref/models/expressions>`."
msgstr ""
"Строка, которая указывает на поле модели, или :doc:`выражение </ref/models/"
"expressions>`."

#: ../../ref/models/querysets.txt:3148
msgid "``output_field``"
msgstr "``output_field``"

#: ../../ref/models/querysets.txt:3150
msgid ""
"An optional argument that represents the :doc:`model field </ref/models/"
"fields>` of the return value"
msgstr ""
"Необязательный аргумент, который определяет :doc:`поле модели </ref/models/"
"fields>` результата."

#: ../../ref/models/querysets.txt:3155
msgid ""
"When combining multiple field types, Django can only determine the "
"``output_field`` if all fields are of the same type. Otherwise, you must "
"provide the ``output_field`` yourself."
msgstr ""
"При использовании нескольких полей Django может определить ``output_field`` "
"в том случае, если все поля одного типа. Иначе необходимо явно указать "
"``output_field``."

# 19a92a74d013406e9d778a85e53da6a8
#: ../../ref/models/querysets.txt:3160
#, fuzzy
msgid "``filter``"
msgstr "filter"

#: ../../ref/models/querysets.txt:3164
msgid ""
"An optional :class:`Q object <django.db.models.Q>` that's used to filter the "
"rows that are aggregated."
msgstr ""

#: ../../ref/models/querysets.txt:3167
msgid ""
"See :ref:`conditional-aggregation` and :ref:`filtering-on-annotations` for "
"example usage."
msgstr ""

# 3de60b9d93e9467288b16597a3aeafd4
#: ../../ref/models/querysets.txt:3171
msgid "``**extra``"
msgstr "``**extra``"

#: ../../ref/models/querysets.txt:3173
msgid ""
"Keyword arguments that can provide extra context for the SQL generated by "
"the aggregate."
msgstr ""
"Именованные аргументы, которая указывают дополнительный контекст для SQL, "
"созданного для агрегации."

#: ../../ref/models/querysets.txt:3177
msgid "``Avg``"
msgstr ""

# 4f087bf53f1846879bddb58150ef6abd
#: ../../ref/models/querysets.txt:3181
msgid ""
"Returns the mean value of the given expression, which must be numeric unless "
"you specify a different ``output_field``."
msgstr ""
"Возвращает среднее значение указанного выражения, которое должно быть "
"численным, если только вы не указали другой ``output_field``.."

# 6690fc6440444e229991c12a0bad51d7
#: ../../ref/models/querysets.txt:3184
msgid "Default alias: ``<field>__avg``"
msgstr "Псевдоним по-умолчанию: ``<field>__avg``"

# 3697fdcfb61d47f48026e21adf8a69dc
# 731b2c19d6d74c118da15e41828e0958
# f11f6e6ff69a493e8ea9e58573a648c5
#: ../../ref/models/querysets.txt:3185
msgid ""
"Return type: ``float`` (or the type of whatever ``output_field`` is "
"specified)"
msgstr ""
"Тип возвращаемого значения: ``float`` (или тип указанного ``output_field``)."

# 0c409d1475354def93edde29830f7ac4
#: ../../ref/models/querysets.txt:3189
#, fuzzy
msgid "``Count``"
msgstr "Count"

# 7620ea9ffc0648bf96b86af00b52b4f3
#: ../../ref/models/querysets.txt:3193
msgid ""
"Returns the number of objects that are related through the provided "
"expression."
msgstr "Возвращает количество объектов связанных через указанное выражение."

# ebcbab5dfc8948ac9da204f618439c2b
#: ../../ref/models/querysets.txt:3196
msgid "Default alias: ``<field>__count``"
msgstr "Псевдоним по-умолчанию: ``<field>__count``"

# 8f27a0c018b8479f89cb3436efa6200e
#: ../../ref/models/querysets.txt:3197
msgid "Return type: ``int``"
msgstr "Тип возвращаемого значения: ``int``"

# 7b78afaeef4f4c68a747e09ad5aa3808
# 965c986ae74645b68ccd5fd615dc7890
# 79693bc662c34ffab94db87939cbf07a
#: ../../ref/models/querysets.txt:3199 ../../ref/models/querysets.txt:3237
#: ../../ref/models/querysets.txt:3271
msgid "Has one optional argument:"
msgstr "Принимает один не обязательный параметр:"

# 475af4945fa7432ea3c6ccb205836fd7
#: ../../ref/models/querysets.txt:3203
msgid ""
"If ``distinct=True``, the count will only include unique instances. This is "
"the SQL equivalent of ``COUNT(DISTINCT <field>)``. The default value is "
"``False``."
msgstr ""
"При ``distinct=True``, будут подсчитаны только уникальные объекты. SQL "
"эквивалент -- ``COUNT(DISTINCT <field>)``. Значение по-умолчанию ``False``."

#: ../../ref/models/querysets.txt:3208
msgid "``Max``"
msgstr ""

# c39eab0e29cc4c9e8f5c4906ffd2e0bd
#: ../../ref/models/querysets.txt:3212
msgid "Returns the maximum value of the given expression."
msgstr "Возвращает максимальное значение указанного выражения."

# ced5a09597d44654940ee0335d460243
#: ../../ref/models/querysets.txt:3214
msgid "Default alias: ``<field>__max``"
msgstr "Псевдоним по-умолчанию: ``<field>__max``"

# 3697fdcfb61d47f48026e21adf8a69dc
# 731b2c19d6d74c118da15e41828e0958
# f11f6e6ff69a493e8ea9e58573a648c5
#: ../../ref/models/querysets.txt:3215 ../../ref/models/querysets.txt:3225
#: ../../ref/models/querysets.txt:3259
msgid "Return type: same as input field, or ``output_field`` if supplied"
msgstr "Тип возвращаемого значения: тип указанного поля, или ``output_field``."

#: ../../ref/models/querysets.txt:3218
msgid "``Min``"
msgstr ""

# 961c01be2a224222b5d329b06bee39e3
#: ../../ref/models/querysets.txt:3222
msgid "Returns the minimum value of the given expression."
msgstr "Возвращает минимальное значение указанного выражения."

# e32617a3373d412782bdfc2d70347a5e
#: ../../ref/models/querysets.txt:3224
msgid "Default alias: ``<field>__min``"
msgstr "Псевдоним по-умолчанию: ``<field>__min``"

# 6a9353ad6067426e9973c9e219303ad3
#: ../../ref/models/querysets.txt:3228
#, fuzzy
msgid "``StdDev``"
msgstr "StdDev"

# 0c05bca7d1314a0c967070c0b345f71d
#: ../../ref/models/querysets.txt:3232
msgid "Returns the standard deviation of the data in the provided expression."
msgstr "Возвращает стандартное отклонение для данных указанного выражения."

# b52735b21eac46eb9a5d41d9ff8489cd
#: ../../ref/models/querysets.txt:3234
msgid "Default alias: ``<field>__stddev``"
msgstr "Псевдоним по-умолчанию: ``<field>__stddev``"

# e9374dd835b64a0796f49cafb63d2793
# dc35896edcc54a28b706b32c314569ec
# 8af88572fb7043c295515783d6a8f2bf
#: ../../ref/models/querysets.txt:3235 ../../ref/models/querysets.txt:3269
msgid "Return type: ``float``"
msgstr "Тип возвращаемого значения: ``float``"

# 24195ce6426e45c38ee7918f58c49587
#: ../../ref/models/querysets.txt:3241
msgid ""
"By default, ``StdDev`` returns the population standard deviation. However, "
"if ``sample=True``, the return value will be the sample standard deviation."
msgstr ""
"По-умолчанию, ``StdDev`` возвращает \"population\" стандартное отклонение. "
"Однако, если использовать аргумент ``sample=True``, возвращаемое значение "
"будет \"sample\" стандартное отклонение."

# d7c936b527844024b693325d101d99ea
# 1560d8b820ba4d34836a95d0a611ed4d
#: ../../ref/models/querysets.txt:3244 ../../ref/models/querysets.txt:3278
msgid "SQLite"
msgstr "SQLite"

# 3e965735e1444d8885183edd5981400c
#: ../../ref/models/querysets.txt:3246
msgid ""
"SQLite doesn't provide ``StdDev`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``StdDev`` из коробки. Реализация доступна в качестве "
"модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."

#: ../../ref/models/querysets.txt:3252
msgid "``Sum``"
msgstr ""

# 3d3652bb66364c77a828d2e0197165ac
#: ../../ref/models/querysets.txt:3256
msgid "Computes the sum of all values of the given expression."
msgstr "Возвращает сумму всех значений указанного выражения."

# 28ecdfc98f5e42a5a0bc42c286d93393
#: ../../ref/models/querysets.txt:3258
msgid "Default alias: ``<field>__sum``"
msgstr "Псевдоним по-умолчанию: ``<field>__sum``"

# 3a32fc4286914984813cde2c218131c2
#: ../../ref/models/querysets.txt:3262
#, fuzzy
msgid "``Variance``"
msgstr "Variance"

# 783e403140ed4b3bbbec4334b291bc5f
#: ../../ref/models/querysets.txt:3266
msgid "Returns the variance of the data in the provided expression."
msgstr "Возвращает дисперсию значений в указанном выражении."

# 36da04f912d944988d28bedf8f989068
#: ../../ref/models/querysets.txt:3268
msgid "Default alias: ``<field>__variance``"
msgstr "Псевдоним по-умолчанию: ``<field>__variance``"

# 10d003b4052e43a0ba85413ce4eae0b5
#: ../../ref/models/querysets.txt:3275
msgid ""
"By default, ``Variance`` returns the population variance. However, if "
"``sample=True``, the return value will be the sample variance."
msgstr ""
"По-умолчанию, ``Variance`` возвращает \"population\" дисперсию. Однако, если "
"использовать аргумент ``sample=True``, возвращаемое значение будет \"sample"
"\" дисперсия."

# 7bab55b99e094dd299f28af98b427972
#: ../../ref/models/querysets.txt:3280
msgid ""
"SQLite doesn't provide ``Variance`` out of the box. An implementation is "
"available as an extension module for SQLite. Consult the `SQlite "
"documentation`_ for instructions on obtaining and installing this extension."
msgstr ""
"SQLite не поддерживает ``Variance`` из коробки. Реализация доступна в "
"качестве модуля расширения для SQLite. Смотрите инструкцию по установке в "
"`документации SQlite <http://www.sqlite.org/contrib>`_."

#: ../../ref/models/querysets.txt:3288
#, fuzzy
msgid "Query-related tools"
msgstr "Объекты, используемые при запросах"

#: ../../ref/models/querysets.txt:3290
msgid ""
"This section provides reference material for query-related tools not "
"documented elsewhere."
msgstr "Этот раздел описывает объекты, которые используются при запросах"

#: ../../ref/models/querysets.txt:3294
msgid "``Q()`` objects"
msgstr "Объекты ``Q()``"

#: ../../ref/models/querysets.txt:3298
msgid ""
"A ``Q()`` object, like an :class:`~django.db.models.F` object, encapsulates "
"a SQL expression in a Python object that can be used in database-related "
"operations."
msgstr ""
"Объект ``Q()``, как и :class:`~django.db.models.F`, инкапсулирует SQL "
"выражение в Python объекте, который может использоваться для указания "
"операций над базой данных."

#: ../../ref/models/querysets.txt:3302
msgid ""
"In general, ``Q() objects`` make it possible to define and reuse conditions. "
"This permits the :ref:`construction of complex database queries <complex-"
"lookups-with-q>` using ``|`` (``OR``) and ``&`` (``AND``) operators; in "
"particular, it is not otherwise possible to use ``OR`` in ``QuerySets``."
msgstr ""
"Объекты ``Q()`` позволяют определить условия и использовать их повторно. Это "
"позволяет :ref:`создавать сложные запросы к базе данных <complex-lookups-"
"with-q>`, используя операторы ``|`` (``OR``) и ``&`` (``AND``); в частности, "
"это единственный способ использовать ``OR`` в ``QuerySets``."

#: ../../ref/models/querysets.txt:3308
msgid "``Prefetch()`` objects"
msgstr "Объекты ``Prefetch()``"

#: ../../ref/models/querysets.txt:3312
msgid ""
"The ``Prefetch()`` object can be used to control the operation of :meth:"
"`~django.db.models.query.QuerySet.prefetch_related()`."
msgstr ""
"Объект ``Prefetch()`` может использоваться для управления операцией :meth:"
"`~django.db.models.query.QuerySet.prefetch_related()`."

#: ../../ref/models/querysets.txt:3315
msgid ""
"The ``lookup`` argument describes the relations to follow and works the same "
"as the string based lookups passed to :meth:`~django.db.models.query."
"QuerySet.prefetch_related()`. For example:"
msgstr ""
"Аргумент ``lookup`` указывает на связь и работает аналогично аргументу :meth:"
"`~django.db.models.query.QuerySet.prefetch_related()`. Например:"

#: ../../ref/models/querysets.txt:3327
msgid ""
"The ``queryset`` argument supplies a base ``QuerySet`` for the given lookup. "
"This is useful to further filter down the prefetch operation, or to call :"
"meth:`~django.db.models.query.QuerySet.select_related()` from the prefetched "
"relation, hence reducing the number of queries even further:"
msgstr ""
"Аргумент ``queryset`` указывает ``QuerySet`` для ``lookup``. Он позволяет "
"выполнить дополнительную фильтрацию, или использовать :meth:`~django.db."
"models.query.QuerySet.select_related()`, дополнительно уменьшая количество "
"запросов:"

#: ../../ref/models/querysets.txt:3339
msgid ""
"The ``to_attr`` argument sets the result of the prefetch operation to a "
"custom attribute:"
msgstr ""
"Аргумент ``to_attr`` указывает в каком атрибуте будет сохранен результат:"

#: ../../ref/models/querysets.txt:3350
msgid ""
"When using ``to_attr`` the prefetched result is stored in a list. This can "
"provide a significant speed improvement over traditional "
"``prefetch_related`` calls which store the cached result within a "
"``QuerySet`` instance."
msgstr ""
"При использовании ``to_attr`` результат сохраняется в списке. Это может "
"ускорить работу ``prefetch_related`` т.к. по умолчанию результат сохраняется "
"в кэше объекта ``QuerySet``."

# c88e911f60014854a17560028894701a
#: ../../ref/models/querysets.txt:3356
#, fuzzy
msgid "``prefetch_related_objects()``"
msgstr "prefetch_related"

#: ../../ref/models/querysets.txt:3360
msgid ""
"Prefetches the given lookups on an iterable of model instances. This is "
"useful in code that receives a list of model instances as opposed to a "
"``QuerySet``; for example, when fetching models from a cache or "
"instantiating them manually."
msgstr ""

#: ../../ref/models/querysets.txt:3364
msgid ""
"Pass an iterable of model instances (must all be of the same class) and the "
"lookups or :class:`Prefetch` objects you want to prefetch for. For example::"
msgstr ""

#: ../../ref/models/querysets.txt:3372
#, fuzzy
msgid "``FilteredRelation()`` objects"
msgstr "Объекты ``Prefetch()``"

#: ../../ref/models/querysets.txt:3380
msgid "The name of the field on which you'd like to filter the relation."
msgstr ""

# e2fe994e98914c0fae0de2156376ce6d
#: ../../ref/models/querysets.txt:3384
#, fuzzy
msgid "A :class:`~django.db.models.Q` object to control the filtering."
msgstr ""
"Вы можете использовать объект :class:`~django.db.models.Prefetch` для "
"большего контроля предварительной загрузкой."

#: ../../ref/models/querysets.txt:3386
msgid ""
"``FilteredRelation`` is used with :meth:`~.QuerySet.annotate()` to create an "
"``ON`` clause when a ``JOIN`` is performed. It doesn't act on the default "
"relationship but on the annotation name (``pizzas_vegetarian`` in example "
"below)."
msgstr ""

#: ../../ref/models/querysets.txt:3391
msgid ""
"For example, to find restaurants that have vegetarian pizzas with "
"``'mozzarella'`` in the name::"
msgstr ""

#: ../../ref/models/querysets.txt:3401
msgid ""
"If there are a large number of pizzas, this queryset performs better than::"
msgstr ""

#: ../../ref/models/querysets.txt:3408
msgid ""
"because the filtering in the ``WHERE`` clause of the first queryset will "
"only operate on vegetarian pizzas."
msgstr ""

#: ../../ref/models/querysets.txt:3411
msgid "``FilteredRelation`` doesn't support:"
msgstr ""

#: ../../ref/models/querysets.txt:3413
msgid "Conditions that span relational fields. For example::"
msgstr ""

#: ../../ref/models/querysets.txt:3424
msgid ":meth:`.QuerySet.only` and :meth:`~.QuerySet.prefetch_related`."
msgstr ""

#: ../../ref/models/querysets.txt:3425
msgid ""
"A :class:`~django.contrib.contenttypes.fields.GenericForeignKey` inherited "
"from a parent model."
msgstr ""

# 51e66a26f4e64b77b808ba178f80076a
#~ msgid ""
#~ "It is also possible to order a queryset by a related field, without "
#~ "incurring the cost of a JOIN, by referring to the ``_id`` of the related "
#~ "field::"
#~ msgstr ""
#~ "Обратите внимание, можно использовать сортировку по внешнему ключу без "
#~ "использования ``JOIN``, указав связанное поле с ``_id``::"

#, fuzzy
#~ msgid ""
#~ "Support for setting primary keys on objects created using "
#~ "``bulk_create()`` when using PostgreSQL was added."
#~ msgstr "Была добавлена поддержка ``bulk_create()`` для прокси-моделей."

# df807c3d6a114491b303f2ce04458f9a
#~ msgid ""
#~ "Depending on which database you're using (e.g. PostgreSQL vs. MySQL), "
#~ "``count()`` may return a long integer instead of a normal Python integer. "
#~ "This is an underlying implementation quirk that shouldn't pose any real-"
#~ "world problems."
#~ msgstr ""
#~ "В зависимости от типа базы данных (например, PostgreSQL vs. MySQL), "
#~ "``count()`` может вернуть long integer вместо обычно целого Python. Это "
#~ "особенности реализации, которые не должны создавать проблем."

# b014e830075744ff8728686028c73565
#, fuzzy
#~ msgid "In older versions, ``id_list`` was a required argument."
#~ msgstr "Предыдущие версии Django требуют ``kwargs``."

# 87ea959d64274072873bb0c8167796b4
#~ msgid "In a given list."
#~ msgstr "Проверяет на вхождение в список значений."

# db6edd7fde1c4b9486c42146373b906c
#, fuzzy
#~ msgid "``search``"
#~ msgstr "search"

# 4a83426ab742406da796b34e4fd38ca5
#~ msgid ""
#~ "A boolean full-text search, taking advantage of full-text indexing. This "
#~ "is like :lookup:`contains` but is significantly faster due to full-text "
#~ "indexing."
#~ msgstr ""
#~ "Полнотекстовый поиск, который использует преимущества полнотекстового "
#~ "индекса. Работает как и :lookup:`contains` но значительно быстрее "
#~ "благодаря полнотекстовому индексу."

# 0332f758885746daa36ec358647475b5
#~ msgid ""
#~ "Note this is only available in MySQL and requires direct manipulation of "
#~ "the database to add the full-text index. By default Django uses BOOLEAN "
#~ "MODE for full text searches. See the `MySQL documentation`_ for "
#~ "additional details."
#~ msgstr ""
#~ "Работает только в MySQL и требует самостоятельного добавления "
#~ "полнотекстового индекса. По-умолчанию Django использует BOOLEAN MODE для "
#~ "полнотекстового поиска. Подробности в `документации MySQL <http://dev."
#~ "mysql.com/doc/refman/5.1/en/fulltext-boolean.html>`_."

# c02286dfc0714cb79386449c1a4f59fe
#~ msgid ""
#~ "SQLite: install pytz_ — conversions are actually performed in Python."
#~ msgstr "SQLite: установите pytz_ — преобразование выполняется в Python."

#~ msgid "Support for using ``bulk_create()`` with proxy models was added."
#~ msgstr "Была добавлена поддержка ``bulk_create()`` для прокси-моделей."

# ae3893892f9949d3adebed149ff9d3ff
#~ msgid ""
#~ "Some Python database drivers like ``psycopg2`` perform caching if using "
#~ "client side cursors (instantiated with ``connection.cursor()`` and what "
#~ "Django's ORM uses). Using ``iterator()`` does not affect caching at the "
#~ "database driver level. To disable this caching, look at `server side "
#~ "cursors`_."
#~ msgstr ""
#~ "Некоторые драйвера базы данных на Python, например ``psycopg2``, "
#~ "используют кэширование для client side курсора (созданный через "
#~ "``connection.cursor()``, такой используется в Django ORM). Использование "
#~ "``iterator()`` не влияет на кэширование на уровне драйвера базы данных. "
#~ "Чтобы избежать кэширования используйте `server side cursors`_."

#~ msgid "The return value describing the number of objects deleted was added."
#~ msgstr ""
#~ "Было добавлено возвращаемое значение, которое содержит количество "
#~ "удаленных объектов."

#~ msgid "Allowed chaining additional field lookups."
#~ msgstr "Позволяет использовать дополнительные проверки поля."

#~ msgid ""
#~ "Added support for :class:`~django.db.models.TimeField` on SQLite (other "
#~ "databases supported it as of 1.7)."
#~ msgstr ""
#~ "Добавлена поддержка :class:`~django.db.models.TimeField` для SQLite "
#~ "(другие базы данных поддерживают с 1.7)."

#~ msgid ""
#~ "The ``output_field`` parameter was added to allow aggregating over non-"
#~ "numeric columns, such as ``DurationField``."
#~ msgstr ""
#~ "Был добавлен параметр ``output_field``, чтобы позволить агрегировать не "
#~ "числовые поля, например ``DurationField``."

#~ msgid ""
#~ "Previous versions of Django only allowed aggregate functions to be used "
#~ "as annotations. It is now possible to annotate a model with all kinds of "
#~ "expressions."
#~ msgstr ""
#~ "В предыдущих версиях Django можно было использовать только функции "
#~ "агрегации. Теперь можно использовать любые типы выражений."

# 8389c0aa80de40d7823b3188341d69d1
#~ msgid "order_by"
#~ msgstr "order_by"

# 11d5eb8529f54db2a837985ac116e865
#~ msgid "none"
#~ msgstr "none"

# a2890d41c32d43eb9432fc98eb1227b8
#~ msgid "all"
#~ msgstr "all"

# 3de60b9d93e9467288b16597a3aeafd4
#~ msgid "extra"
#~ msgstr "extra"

#~ msgid "Prior to 1.8, you were unable to escape a literal ``%s``."
#~ msgstr "До 1.8 нельзя было экранировать ``%s``."

# 9f71a64c63c64187aaff40d5dd2b2bf9
#~ msgid "only"
#~ msgstr "only"

# 96754e30161f42b88fca1f5ba08ab429
#~ msgid "raw"
#~ msgstr "raw"

# 215fe858f64a4e35b05940589525f55c
#~ msgid "get"
#~ msgstr "get"

# 359c284c59554f579b28b6356a4888bb
#~ msgid "last"
#~ msgstr "last"

# bca209d42092487e9964c7652b9a211b
#~ msgid "exact"
#~ msgstr "exact"

# fcb2730a5a3e4b8597ae9319634d8f27
#~ msgid "in"
#~ msgstr "in"

# efdcfa281a21404fb26fcb8bb34bdef5
#~ msgid "gt"
#~ msgstr "gt"

# 93226a1d19bc4775a46b54ad66c3a196
#~ msgid "gte"
#~ msgstr "gte"

# 2c2ab2f71bb84b9fa62774f8804dd5b1
#~ msgid "lt"
#~ msgstr "lt"

# 634baf15353246e7a3262c1daa6772ba
#~ msgid "lte"
#~ msgstr "lte"

# 3a7fa46732934635ba5767f67a5aaa83
#~ msgid "day"
#~ msgstr "day"

#~ msgid ""
#~ "Aggregate functions are now able to reference multiple fields in complex "
#~ "computations."
#~ msgstr ""
#~ "Функции агрегации теперь могут принимать несколько полей для сложных "
#~ "вычислений."

# b62b96d46a654d3491ba4da2641de110
#~ msgid "Avg"
#~ msgstr "Avg"

# ada47e189ee6457db1dfe81a771f62ba
#~ msgid "Max"
#~ msgstr "Max"

# 005622d3bbfa4271956016793ade610f
#~ msgid "Min"
#~ msgstr "Min"

# c15dfc1c05a14212bb0fc4be6550fc31
#~ msgid "Sum"
#~ msgstr "Sum"

# 51e66a26f4e64b77b808ba178f80076a
#~ msgid ""
#~ "The ability to order a queryset by a related field, without incurring the "
#~ "cost of a JOIN was added."
#~ msgstr ""
#~ "Была добавлена возможность использовать сортировку по внешнему ключу без "
#~ "использования ``JOIN``"

# 5a3f90d25b7b44c098e57cce9fd1d623
#~ msgid ""
#~ "The last point above is new. Previously, calling :meth:`only()` and :meth:"
#~ "`defer()` after ``values()`` was allowed, but it either crashed or "
#~ "returned incorrect results."
#~ msgstr ""
#~ "Было добавлено поведение из последнего пункта. Ранее вызов :meth:`only()` "
#~ "или :meth:`defer()` после ``values()`` был разрешен, но он приводил к "
#~ "ошибке или возвращал не верный результат."

# b0ad5e5c848348dea33d1f14a680895d
#~ msgid ""
#~ "Note that this method returns a ``ValuesListQuerySet``. This class "
#~ "behaves like a list. Most of the time this is enough, but if you require "
#~ "an actual Python list object, you can simply call ``list()`` on it, which "
#~ "will evaluate the queryset."
#~ msgstr ""
#~ "Обратите внимание, этот запрос возвращает ``ValuesListQuerySet``. Этот "
#~ "класс работает как список. В большинстве случаев этого достаточно, однако "
#~ "если вам действительно нужен список Python, вы можете использовать "
#~ "``list()``, который выполнит ``QuerySet``."

#~ msgid ""
#~ "Previously the latter would have been equivalent to "
#~ "``select_related('bar')``."
#~ msgstr ""
#~ "Ранее последний вариант был бы эквивалентен ``select_related('bar')``."

# e560ebec387645f3b04d3e19f39214ca
#~ msgid ""
#~ "It is now an error to execute a query with ``select_for_update()`` in "
#~ "autocommit mode. With earlier releases in the 1.6 series it was a no-op."
#~ msgstr ""
#~ "Использовании ``select_for_update()`` в autocommit режиме теперь вызывает "
#~ "исключение."

# 2d663e00e4fd40f1b9b9d8ffee9e7065
#~ msgid ""
#~ "``raw`` was moved to the ``QuerySet`` class. It was previously only on :"
#~ "class:`~django.db.models.Manager`."
#~ msgstr ""
#~ "``raw`` был перенесен в класс ``QuerySet``. Ранее был доступен только в :"
#~ "class:`~django.db.models.Manager`."

# c790d016148f48d9bbcf0b0cf507598b
#~ msgid "Case-insensitive exact match."
#~ msgstr "Регистронезависимое точное совпадение."

# a9234d56d6b84edbbf3b8d8794028b17
#~ msgid ""
#~ "If the value provided for comparison is ``None``, it will be interpreted "
#~ "as an SQL ``NULL`` (see :lookup:`isnull` for more details)."
#~ msgstr ""
#~ "Если передано значение ``None``, оно будет интерпретировано как SQL "
#~ "``NULL`` (смотрите подробности в описании :lookup:`isnull`)."

# 0528f3a870d4462abb105f30ba474788
#~ msgid ""
#~ "Be warned, though, that this could have a large memory overhead, because "
#~ "Django will load each element of the list into memory. In contrast, "
#~ "iterating over a ``QuerySet`` will take advantage of your database to "
#~ "load data and instantiate objects only as you need them."
#~ msgstr ""
#~ "Будьте осторожны, так как при этом может быть использовано большое "
#~ "количество памяти, т.к. Django загрузит каждый элемент списка в память. В "
#~ "отличии от итерации по ``QuerySet``, при которой будут получены данные из "
#~ "базы данных, но объекты будут созданы только при обращении к ним."

# 864b816187e342588c274fee7e4b1a21
#~ msgid ""
#~ "Annotates each object in the ``QuerySet`` with the provided list of "
#~ "aggregate values (averages, sums, etc) that have been computed over the "
#~ "objects that are related to the objects in the ``QuerySet``. Each "
#~ "argument to ``annotate()`` is an annotation that will be added to each "
#~ "object in the ``QuerySet`` that is returned."
#~ msgstr ""
#~ "\"Аннотирует\" каждый объект в ``QuerySet`` агрегированным значением "
#~ "(среднее, сумма и др.), которое будет вычислено из данных связанных "
#~ "объектов, которые связанны с объектами из ``QuerySet``. Аргументы "
#~ "``annotate()`` это \"аннотация\", которая будет добавлена для каждого "
#~ "объекта возвращаемого ``QuerySet``."

# de174d006189426bb977b1724a79c2b4
#~ msgid "...since the ``Blog`` model has no default ordering specified."
#~ msgstr "...т.к. модель ``Blog`` не содержит сортировки по-умолчанию."

# 2e89cc58122a46ba88755e31c3752ff4
#~ msgid ""
#~ "``dates`` used to return a list of :class:`datetime.datetime` objects."
#~ msgstr ""
#~ "``dates`` используется, чтобы получить список объектов :class:`datetime."
#~ "datetime`."

# 4c676dfb14b54e969e866cc4eb76811d
#~ msgid "``field`` should be the name of a ``DateField`` of your model."
#~ msgstr "``field`` -- название поля модели типа ``DateField``."

# af4c1ae4d2b647c596651163f56f0d46
#~ msgid "``dates`` used to accept operating on a ``DateTimeField``."
#~ msgstr "``dates`` может использоваться для ``DateTimeField``."

# 28a4898245f3431383d4f394c9cbb7bb
#~ msgid ""
#~ "The only thing to be careful about when using select parameters in "
#~ "``extra()`` is to avoid using the substring ``\"%%s\"`` (that's *two* "
#~ "percent characters before the ``s``) in the select strings. Django's "
#~ "tracking of parameters looks for ``%s`` and an escaped ``%`` character "
#~ "like this isn't detected. That will lead to incorrect results."
#~ msgstr ""
#~ "Единственное, что нужно помнить используя параметры в ``extra()`` -- "
#~ "избегать использование ``\"%%s\"`` (тут *два* знака процента перед ``s``) "
#~ "в параметре ``select``. Django ищет ``%s`` и экранированный символ ``%`` "
#~ "не будет распознан. Это приведет к неверным результатам."

# e5857f02298d4e58bcdf7f6a439ff2c6
#~ msgid ""
#~ "Though you usually won't create one manually — you'll go through a :class:"
#~ "`~django.db.models.Manager` — here's the formal declaration of a "
#~ "``QuerySet``:"
#~ msgstr ""
#~ "Хоть вам и не нужно создавать экземпляр ``QuerySet`` самостоятельно — он "
#~ "создается через :class:`~django.db.models.Manager` — вот как это "
#~ "происходит:"

# c42207566e5848fea57f695f19c1ce3c
#~ msgid ""
#~ "Note that, by default, ``select_related()`` does not follow foreign keys "
#~ "that have ``null=True``."
#~ msgstr ""
#~ "Заметим, по-умолчанию ``select_related()`` не учитывает внешние ключи с "
#~ "``null=True``."

# 1f46130a9ade4bb688f2110f4ee5aa5c
#~ msgid ""
#~ "Usually, using ``select_related()`` can vastly improve performance "
#~ "because your app can avoid many database calls. However, there are times "
#~ "you are only interested in specific related models, or have deeply nested "
#~ "sets of relationships, and in these cases ``select_related()`` can be "
#~ "optimized by explicitly passing the related field names you are "
#~ "interested in. Only the specified relations will be followed."
#~ msgstr ""
#~ "Обычно, использование ``select_related()`` может значительно увеличить "
#~ "производительность т.к. ваше приложение не будет выполнять дополнительные "
#~ "запросы при доступе к связанным объектам. Однако, в случае глубокой "
#~ "вложенности связанных объектов, ``select_related()`` может привести к "
#~ "\"обработке\" слишком большого количества связей, и создаст в конечном "
#~ "итоге сложный и значительно медленный запрос. Вы можете передать названия "
#~ "внешних ключей, которые следует обрабатывать."

# 79ff5ffc434c4030ab8a94299c91e338
#~ msgid ""
#~ "You can even do this for models that are more than one relation away by "
#~ "separating the field names with double underscores, just as for filters. "
#~ "For example, if you have this model::"
#~ msgstr ""
#~ "Вы можете определять связанные модели любой вложенности, разделяя имена "
#~ "внешних ключей двойным нижним подчеркиванием. Например, у вас есть "
#~ "модель::"

# ec74245305334c98ab756c026129189b
#~ msgid ""
#~ "...and you only needed to work with the ``room`` and ``subject`` "
#~ "attributes, you could write this::"
#~ msgstr "...и вам нужны только  ``room`` и ``subject``::"

# 6e7d6366f5524863bcfd865a431a0256
#~ msgid "This is also valid::"
#~ msgstr "Также можно::"

# 840699198ee1475c9ffdf250ab771ac7
#~ msgid "...and would also pull in the ``building`` relation."
#~ msgstr "...в результате будет также использована связь ``building``."

# 62befa03faea415d880cf52741f205fe
#~ msgid ""
#~ "You can refer to any :class:`~django.db.models.ForeignKey` or :class:"
#~ "`~django.db.models.OneToOneField` relation in the list of fields passed "
#~ "to ``select_related()``. This includes foreign keys that have "
#~ "``null=True`` (which are omitted in a no-parameter ``select_related()`` "
#~ "call). It's an error to use both a list of fields and the ``depth`` "
#~ "parameter in the same ``select_related()`` call; they are conflicting "
#~ "options."
#~ msgstr ""
#~ "Можно указать любые :class:`~django.db.models.ForeignKey` или :class:"
#~ "`~django.db.models.OneToOneField` связи при вызове ``select_related()``. "
#~ "Принимаются только внешние ключи с ``null=True`` (которые будет "
#~ "использова ны при вызове ``select_related()`` без аргументов). Нельзя "
#~ "использовать аргумент ``depth`` и список полей вместе, эти параметры "
#~ "несовместимы."

# 13743d5ec15143f898643c04641f1dee
#~ msgid "A depth limit of relationships to follow can also be specified::"
#~ msgstr "Глубину следования связям можно указать следующим образом::"

# 0cd784213a2c4dafad8091eada5a4bc7
#~ msgid ""
#~ "A :class:`~django.db.models.OneToOneField` is not traversed in the "
#~ "reverse direction if you are performing a depth-based "
#~ "``select_related()`` call."
#~ msgstr ""
#~ "Обратная связь для :class:`~django.db.models.OneToOneField` не "
#~ "учитывается при вызове ``select_related()``, если она явно не указана в "
#~ "аргументах."

# 2c62b3d966954c679352032d48778072
#~ msgid ""
#~ "As of Django 1.4, you can pass positional arguments (``*fields``) in "
#~ "order to specify the names of fields to which the ``DISTINCT`` should "
#~ "apply. This translates to a ``SELECT DISTINCT ON`` SQL query."
#~ msgstr ""
#~ "С Django 1.4, можно передать позиционные аргументы (``*fields``), "
#~ "указывая какие поля должны использоваться с ``DISTINCT``. Все это будет "
#~ "преобразовано в ``SELECT DISTINCT ON`` SQL запрос."

# a39ab3008bfc4a6b8235716f206b45cd
#~ msgid "This ability to specify field names is only available in PostgreSQL."
#~ msgstr "Возможность указывать поля доступна только в PostgreSQL."

# 39c9d32ce13e4247960fb10a992f4943
#~ msgid ""
#~ "Returns a ``DateQuerySet`` — a ``QuerySet`` that evaluates to a list of "
#~ "``datetime.datetime`` objects representing all available dates of a "
#~ "particular kind within the contents of the ``QuerySet``."
#~ msgstr ""
#~ "Возвращает ``DateQuerySet`` — ``QuerySet`` возвращающий список объектов "
#~ "``datetime.datetime`` отображающих возможные даты в контексте "
#~ "``QuerySet``."

# 4c676dfb14b54e969e866cc4eb76811d
#~ msgid ""
#~ "``field`` should be the name of a ``DateField`` or ``DateTimeField`` of "
#~ "your model."
#~ msgstr ""
#~ "``field`` -- название поля модели типа ``DateField`` или "
#~ "``DateTimeField``."

# 83a5dbf9c43e4918b590f89ffd646df3
#~ msgid ""
#~ "When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
#~ "uses UTC in the database connection, which means the aggregation is "
#~ "performed in UTC. This is a known limitation of the current "
#~ "implementation."
#~ msgstr ""
#~ "Если включена :doc:`поддержка временных зон </topics/i18n/timezones>`, "
#~ "Django будет использовать UTC при подключении к базе данных, то есть "
#~ "агрегация выполняется в UTC. Это ограничение текущей реализации."

# 671567eab87f48ef92ef488392402340
#~ msgid ""
#~ "Returns an ``EmptyQuerySet`` — a ``QuerySet`` subclass that always "
#~ "evaluates to an empty list. This can be used in cases where you know that "
#~ "you should return an empty result set and your caller is expecting a "
#~ "``QuerySet`` object (instead of returning an empty list, for example.)"
#~ msgstr ""
#~ "Возвращает ``EmptyQuerySet`` — подкласс ``QuerySet`` который всегда "
#~ "возвращает пустой список. Полезен, если необходимо вернуть пустой "
#~ "результат, но код ожидает объект ``QuerySet`` (вместо того, что бы "
#~ "возвращать пустой список, например.)"

# 9792df60230541faab024b6366fe7928
#~ msgid ""
#~ "Note that using ``select_for_update()`` will cause the current "
#~ "transaction to be considered dirty, if under transaction management. This "
#~ "is to ensure that Django issues a ``COMMIT`` or ``ROLLBACK``, releasing "
#~ "any locks held by the ``SELECT FOR UPDATE``."
#~ msgstr ""
#~ "Следует отметить, что использование ``select_for_update()`` приводит к "
#~ "тому, что текущая транзакция считается \"грязной\" (если используется "
#~ "управление транзакциями). Это происходит, потому что Django блокирует "
#~ "указанные записи в БД и держит их до выполнения фиксации(``COMMIT``) или "
#~ "отката(``ROLLBACK``) произведённых изменений, освобождая поставленные "
#~ "ранее блокировки в базе данных."

# 2c9d52cc99be446aacd1620c56e67d2b
#~ msgid ""
#~ "When :doc:`time zone support </topics/i18n/timezones>` is enabled, Django "
#~ "uses UTC in the database connection, which means the ``year``, ``month``, "
#~ "``day`` and ``week_day`` lookups are performed in UTC. This is a known "
#~ "limitation of the current implementation."
#~ msgstr ""
#~ "Если используются :doc:`временные зоны </topics/i18n/timezones>` , Django "
#~ "использует UTC при подключении к базе данных, это означает что фильтры "
#~ "``year``, ``month``, ``day`` и ``week_day`` будут выполнены в UTC. Это "
#~ "ограничение текущей реализации."

# e8c07900458743418c31612eda81153e
#~ msgid ""
#~ "It is permissible to specify a multi-valued field to order the results by "
#~ "(for example, a :class:`~django.db.models.ManyToManyField` field). "
#~ "Normally this won't be a sensible thing to do and it's really an advanced "
#~ "usage feature. However, if you know that your queryset's filtering or "
#~ "available data implies that there will only be one ordering piece of data "
#~ "for each of the main items you are selecting, the ordering may well be "
#~ "exactly what you want to do. Use ordering on multi-valued fields with "
#~ "care and make sure the results are what you expect."
#~ msgstr ""
#~ "Для сортировки можно указать поле с множеством значений (например, :class:"
#~ "`~django.db.models.ManyToManyField` field). Как правильно, это не очень "
#~ "разумно и является функционалом для продвинутых пользователей. Однако, "
#~ "если вы уверены что фильтры \"queryset\" или существующие данные "
#~ "подразумеваю, что для каждого объекта существует только одно значение, "
#~ "используемое для сортировки -- вполне вероятно что в результате вы "
#~ "получите то, что и ожидали получить. Используйте такую сортировку с "
#~ "осторожность и убедитесь что результат отвечает вашим требованиям."

# 89f80a351e3e47c7a308985aa0797fbb
#~ msgid ""
#~ "The problem with this code is that it will run a query on the Toppings "
#~ "table for **every** item in the Pizza ``QuerySet``.  Using "
#~ "``prefetch_related``, this can be reduced to two:"
#~ msgstr ""
#~ "Проблема в том, что будет выполнен запрос к таблице ``Toppings`` для "
#~ "**каждого** объекта ``Pizza`` в ``QuerySet``. Используя "
#~ "``prefetch_related``, количество запросов можно сократить до двух:"

# 76e875e80bfd48e7b2cde3ab9b8111ef
#~ msgid ""
#~ "The additional queries are executed after the QuerySet has begun to be "
#~ "evaluated and the primary query has been executed. Note that the result "
#~ "cache of the primary QuerySet and all specified related objects will then "
#~ "be fully loaded into memory, which is often avoided in other cases - even "
#~ "after a query has been executed in the database, QuerySet normally tries "
#~ "to make uses of chunking between the database to avoid loading all "
#~ "objects into memory before you need them."
#~ msgstr ""
#~ "Дополнительные запросы будут выполнены при вычислении QuerySet и "
#~ "выполнении основного запроса. Заметим, результат выполнения QuerySet "
#~ "будет \"закэширован\" и все связанные объекты будет загружены в память, "
#~ "что обычно избегается в других случаях - даже после того, как запрос в "
#~ "базу данных был выполнен, QuerySet старается не загружать все данные в "
#~ "память пока они вам не понадобятся."
