# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013, 2014, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-16 11:56+0200\n"
"PO-Revision-Date: 2015-12-20 09:40+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 04c114de81524d788c49310caff69d5a
#: ../../ref/forms/validation.txt:3
msgid "Form and field validation"
msgstr "Проверка форм и полей формы"

# ac1b690f74b042c298278dda10323430
#: ../../ref/forms/validation.txt:7
msgid ""
"Form validation happens when the data is cleaned. If you want to customize "
"this process, there are various places to make changes, each one serving a "
"different purpose. Three types of cleaning methods are run during form "
"processing. These are normally executed when you call the ``is_valid()`` "
"method on a form. There are other things that can also trigger cleaning and "
"validation (accessing the ``errors`` attribute or calling ``full_clean()`` "
"directly), but normally they won't be needed."
msgstr ""
"Проверка формы происходит при нормализации её данных. При возникновении "
"необходимости вмешаться в этот процесс, есть много мест, где можно это "
"сделать и которые влияют на разные этапы проверки. Во время обработки формы "
"вызываются три типа методов для нормализации данных. Процесс проверки "
"запускается при вызове метода ``is_valid()`` формы. Существуют ситуации, "
"которые запускают нормализацию и проверку данных (обращение к свойству "
"``errors`` или прямой вызов метода ``full_clean()``), но они возникают "
"достаточно редко."

# 7877226f14874d9cbf55f6796d321cdf
#: ../../ref/forms/validation.txt:15
msgid ""
"In general, any cleaning method can raise ``ValidationError`` if there is a "
"problem with the data it is processing, passing the relevant information to "
"the ``ValidationError`` constructor. :ref:`See below <raising-validation-"
"error>` for the best practice in raising ``ValidationError``. If no "
"``ValidationError`` is raised, the method should return the cleaned "
"(normalized) data as a Python object."
msgstr ""
"В общем случае, любой нормализующий метод может вызвать исключение "
"``ValidationError`` при наличии проблем с данными, передавая соответствующее "
"сообщение об ошибке в конструктор исключения. :ref:`Смотрите ниже <raising-"
"validation-error>` примеры, как правильно вызывать ``ValidationError``. Если "
"проблем не выявлено, то метод должен возвращать нормализованное значение в "
"виде объекта языка Python."

# cacdfe89b6d746ecb576f826a129b211
#: ../../ref/forms/validation.txt:22
msgid ""
"Most validation can be done using `validators`_ - simple helpers that can be "
"reused easily. Validators are simple functions (or callables) that take a "
"single argument and raise ``ValidationError`` on invalid input. Validators "
"are run after the field's ``to_python`` and ``validate`` methods have been "
"called."
msgstr ""
"Большая часть проверок может быть выполнена с помощью `validators`_, которые "
"являются простыми в использовании вспомогательными объектами. Валидатор — "
"это простая функция (или вызываемый объект, callable), которая принимает "
"единственный аргумент и вызывает исключение ``ValidationError`` в случае "
"проблем с полученным значением. Валидаторы запускаются после вызова методов "
"поля: ``to_python`` и ``validate``."

# 04298184d92a4633881ae2f50907ab83
#: ../../ref/forms/validation.txt:27
msgid ""
"Validation of a form is split into several steps, which can be customized or "
"overridden:"
msgstr ""
"Проверка формы состоит из нескольких этапов, каждый из которых может быть "
"настроен или переопределён:"

# bf72593d5dac40fb8e7663b66238a909
#: ../../ref/forms/validation.txt:30
msgid ""
"The ``to_python()`` method on a ``Field`` is the first step in every "
"validation. It coerces the value to a correct datatype and raises "
"``ValidationError`` if that is not possible. This method accepts the raw "
"value from the widget and returns the converted value. For example, a "
"``FloatField`` will turn the data into a Python ``float`` or raise a "
"``ValidationError``."
msgstr ""
"Вызов метода поля ``to_python()`` является первым этапом каждой проверки. Он "
"приводит значение к соответствующему типу данных или вызывает исключение "
"``ValidationError``, если это невозможно. Метод принимает сырое значение от "
"виджета и возвращает нормализованное значение. Например, поле типа "
"``FloatField`` преобразовывает данные в тип ``float`` языка Python или "
"вызывает исключение ``ValidationError``."

# 7911286063994186b6f8e5b1241aebf2
#: ../../ref/forms/validation.txt:37
msgid ""
"The ``validate()`` method on a ``Field`` handles field-specific validation "
"that is not suitable for a validator. It takes a value that has been coerced "
"to a correct datatype and raises ``ValidationError`` on any error. This "
"method does not return anything and shouldn't alter the value. You should "
"override it to handle validation logic that you can't or don't want to put "
"in a validator."
msgstr ""
"Метод ``validate()`` поля выполняет специфическую для поля проверку данных и "
"приводит значение к правильному типу данных, или вызывает исключение "
"``ValidationError`` на любую ошибку. Этот метод не возвращает значение и не "
"должен изменять проверяемые данные. Если вам надо обеспечить логику, которую "
"невозможно или нежелательно выносить в валидатор, то вам следует "
"переопределить этот метод."

# fe6027ea91a847b49bc8b50ced749b74
#: ../../ref/forms/validation.txt:44
msgid ""
"The ``run_validators()`` method on a ``Field`` runs all of the field's "
"validators and aggregates all the errors into a single ``ValidationError``. "
"You shouldn't need to override this method."
msgstr ""
"Метод поля ``run_validators()`` запускает все валидаторы  и аккумулирует все "
"возникающие ошибки в одно исключение ``ValidationError``. Вам не стоит "
"переопределять этот метод."

# f135d4480aca445093d1a22af064a12a
#: ../../ref/forms/validation.txt:48
msgid ""
"The ``clean()`` method on a ``Field`` subclass is responsible for running "
"``to_python()``, ``validate()``, and ``run_validators()`` in the correct "
"order and propagating their errors. If, at any time, any of the methods "
"raise ``ValidationError``, the validation stops and that error is raised. "
"This method returns the clean data, which is then inserted into the "
"``cleaned_data`` dictionary of the form."
msgstr ""
"Метод ``clean()`` поля отвечает за вызов методов ``to_python()``, "
"``validate()`` и ``run_validators()`` в правильном порядке и передачу их "
"ошибок. Как только любой из этих методов вызовет исключение "
"``ValidationError``, процесс проверки прекращается и ошибка передаётся выше. "
"Этот метод возвращает проверенные данные, которые затем помещаются в словарь "
"``cleaned_data`` формы."

# 7ca929ced5d0428a9d4f5211dc0c98bc
#: ../../ref/forms/validation.txt:55
msgid ""
"The ``clean_<fieldname>()`` method is called on a form subclass -- where "
"``<fieldname>`` is replaced with the name of the form field attribute. This "
"method does any cleaning that is specific to that particular attribute, "
"unrelated to the type of field that it is. This method is not passed any "
"parameters. You will need to look up the value of the field in ``self."
"cleaned_data`` and remember that it will be a Python object at this point, "
"not the original string submitted in the form (it will be in "
"``cleaned_data`` because the general field ``clean()`` method, above, has "
"already cleaned the data once)."
msgstr ""
"Для проверки значения поля используется метод ``clean_<fieldname>()``, где "
"``<fieldname>`` заменяется на имя поля. Этот метод выполняет проверку "
"значения. Метод не принимает аргументы. Для получения значения поля "
"обращайтесь к словарю\n"
"``self.cleaned_data`` и помните, что там будет объект языка Python, а не "
"строка, переданная формой (значение находится в ``cleaned_data`` т.к. уже "
"была выполнена проверка методом ``clean()`` поля)."

# 5745b3cc8fb841f8a831ff069fe4e987
#: ../../ref/forms/validation.txt:65
msgid ""
"For example, if you wanted to validate that the contents of a ``CharField`` "
"called ``serialnumber`` was unique, ``clean_serialnumber()`` would be the "
"right place to do this. You don't need a specific field (it's just a "
"``CharField``), but you want a formfield-specific piece of validation and, "
"possibly, cleaning/normalizing the data."
msgstr ""
"Например, если требуется проверить, что содержимое ``CharField`` поля с "
"именем ``serialnumber`` является уникальным, то метод "
"``clean_serialnumber()`` будет правильным местом для такого функционала. Вам "
"не нужно специальное поле (пусть будет ``CharField``), но требуется хитрая "
"проверка данных и, возможно, очистка/нормализация данных."

#: ../../ref/forms/validation.txt:72
msgid ""
"The return value of this method replaces the existing value in "
"``cleaned_data``, so it must be the field's value from ``cleaned_data`` "
"(even if this method didn't change it) or a new cleaned value."
msgstr ""

# c491ab54304a4a75ac6aa00f16e30d8f
#: ../../ref/forms/validation.txt:76
#, fuzzy
msgid ""
"The form subclass's ``clean()`` method can perform validation that requires "
"access to multiple form fields. This is where you might put in checks such "
"as \"if field ``A`` is supplied, field ``B`` must contain a valid email "
"address\". This method can return a completely different dictionary if it "
"wishes, which will be used as the ``cleaned_data``."
msgstr ""
"Метод ``clean()`` потомка формы. Этот метод может выполнять любую проверку, "
"которая нуждается в одновременном доступе к данным нескольких полей. Именно "
"здесь вы можете проверять, что если поле ``A`` заполнено, то поле ``B`` "
"должно содержать правильный адрес электронной почты и так далее. Данные, "
"которые возвращает этот метод, помещаются в свойство ``cleaned_data`` формы."

# 2aec0908834445b6bf87b013f6b276d2
#: ../../ref/forms/validation.txt:82
msgid ""
"Since the field validation methods have been run by the time ``clean()`` is "
"called, you also have access to the form's ``errors`` attribute which "
"contains all the errors raised by cleaning of individual fields."
msgstr ""
"Так как валидация полей выполняется перед вызовом ``clean()``, вы можете "
"получить доступ к атрибуту формы ``errors``, который содержит уже полученные "
"ошибки валидации."

# f0af9ad49bc14b6eb0892d21f55aecad
#: ../../ref/forms/validation.txt:86
msgid ""
"Note that any errors raised by your :meth:`Form.clean()` override will not "
"be associated with any field in particular. They go into a special \"field"
"\" (called ``__all__``), which you can access via the :meth:`~django.forms."
"Form.non_field_errors` method if you need to. If you want to attach errors "
"to a specific field in the form, you need to call :meth:`~django.forms.Form."
"add_error()`."
msgstr ""
"Следует отметить, что любая ошибка, вызванная методом :meth:`Form.clean()` "
"формы, не будет ассоциирована ни с каким полем. Такие ошибки привязываются к "
"«особому» полю (``__all__``), доступ к которому можно получить через метод :"
"meth:`~django.forms.Form.non_field_errors`. Если вам потребуется добавить "
"ошибки к определённому полю формы, используйте :meth:`~django.forms.Form."
"add_error()`."

# dad01054e9ec43bf9188aeadc139062f
#: ../../ref/forms/validation.txt:93
msgid ""
"Also note that there are special considerations when overriding the "
"``clean()`` method of a ``ModelForm`` subclass. (see the :ref:`ModelForm "
"documentation <overriding-modelform-clean-method>` for more information)"
msgstr ""
"Также следует отметить, что существует ряд соглашений, которым необходимо "
"следовать при переопределении метода ``clean()`` в вашем классе "
"``ModelForm``. (Обратитесь к :ref:`документации на ModelForm <overriding-"
"modelform-clean-method>` для получения подробностей.)"

# 2d7bcf40aa684081b3f96da43e19d235
#: ../../ref/forms/validation.txt:98
msgid ""
"These methods are run in the order given above, one field at a time.  That "
"is, for each field in the form (in the order they are declared in the form "
"definition), the ``Field.clean()`` method (or its override) is run, then "
"``clean_<fieldname>()``. Finally, once those two methods are run for every "
"field, the :meth:`Form.clean()` method, or its override, is executed whether "
"or not the previous methods have raised errors."
msgstr ""
"Эти методы вызываются в порядке, указанном выше, по одному полю за раз. Для "
"каждого поля формы (в порядке их определения в классе формы) вызывается "
"сначала метод ``Field.clean()``, затем вызывается метод "
"``clean_<fieldname>()``. После того, как пара этих методов будет вызвана для "
"каждого поля формы, наступает очередь метода :meth:`Form.clean()` формы. Он "
"будет вызыван в любом случае, даже если предыдущие методы вызывали ошибку."

# 580c5538caf143b3a0b26acebba6213e
#: ../../ref/forms/validation.txt:105
msgid "Examples of each of these methods are provided below."
msgstr "Примеры для каждого из этих методов показаны ниже."

# cc6769750d454e0393389789e1b3966f
#: ../../ref/forms/validation.txt:107
msgid ""
"As mentioned, any of these methods can raise a ``ValidationError``. For any "
"field, if the ``Field.clean()`` method raises a ``ValidationError``, any "
"field-specific cleaning method is not called. However, the cleaning methods "
"for all remaining fields are still executed."
msgstr ""
"Как упоминалось ранее, любой из этих методов может вызвать исключение  "
"``ValidationError``. Для любого поля, если его метод ``clean()`` вызвал "
"исключение ``ValidationError``, то следующий метод для этого поля не "
"вызывается. Тем не менее, методы для остальных полей отрабатывают в штатном "
"режиме."

# e3494411f62d4b848fb04b8bc19deea2
#: ../../ref/forms/validation.txt:115
msgid "Raising ``ValidationError``"
msgstr "Вызов ``ValidationError``"

# c2c23d75a6654db38e1f1238b3d12992
#: ../../ref/forms/validation.txt:117
msgid ""
"In order to make error messages flexible and easy to override, consider the "
"following guidelines:"
msgstr "Для удобной работы с ошибками валидации используйте следующие правила:"

# 93bbd4b090ec457599928b7659080e48
#: ../../ref/forms/validation.txt:120
msgid "Provide a descriptive error ``code`` to the constructor::"
msgstr "Передайте при создании код ошибки через аргумент ``code``::"

# 44007a47599c4d3ab5beef6bb3330300
#: ../../ref/forms/validation.txt:128
msgid ""
"Don't coerce variables into the message; use placeholders and the ``params`` "
"argument of the constructor::"
msgstr ""
"Переменные лучше передавать в аргументе ``params``, а в сообщении указать "
"места для подстановки::"

# 0c37a98f2edb4e44a772ac1fb34649e5
#: ../../ref/forms/validation.txt:140
msgid ""
"Use mapping keys instead of positional formatting. This enables putting the "
"variables in any order or omitting them altogether when rewriting the "
"message::"
msgstr ""
"Используйте именованные параметры в сообщении. Это позволит использовать "
"переменные в любом параметре при переопределении сообщения::"

# a4fdbfb4a89046ce944288b437a8d779
#: ../../ref/forms/validation.txt:156
msgid "Wrap the message with ``gettext`` to enable translation::"
msgstr "Оберните сообщения в ``gettext`` для последующего перевода::"

# 1b1adac71d8042a78ddea09fe233b178
#: ../../ref/forms/validation.txt:164
msgid "Putting it all together::"
msgstr "Все вместе::"

# 3e27bab31fb14f4985be9ff41e8ca16e
#: ../../ref/forms/validation.txt:172
msgid ""
"Following these guidelines is particularly necessary if you write reusable "
"forms, form fields, and model fields."
msgstr ""
"Соблюдать правила очень важно при создании переносимых форм, полей форм и "
"моделей."

# f3a715eb09474a0b8a2764e2470eced3
#: ../../ref/forms/validation.txt:175
msgid ""
"While not recommended, if you are at the end of the validation chain (i.e. "
"your form ``clean()`` method) and you know you will *never* need to override "
"your error message you can still opt for the less verbose::"
msgstr ""
"Не рекомендуется, но если вы в конце цепочки валидации(например, метод "
"``clean()`` формы) и никогда не будете переопределять сообщение, можно "
"просто сделать::"

# 84e6c2f90ace4dd9b9d6ae02a992eb8a
#: ../../ref/forms/validation.txt:181
msgid ""
"The :meth:`Form.errors.as_data() <django.forms.Form.errors.as_data()>` and :"
"meth:`Form.errors.as_json() <django.forms.Form.errors.as_json()>` methods "
"greatly benefit from fully featured ``ValidationError``\\s (with a ``code`` "
"name and a ``params`` dictionary)."
msgstr ""
"Методы :meth:`Form.errors.as_data() <django.forms.Form.errors.as_data()>` и :"
"meth:`Form.errors.as_json() <django.forms.Form.errors.as_json()>` используют "
"все возможности ``ValidationError`` (включая ``code`` и ``params``)."

# d6bf8d3cd1124e5f9be030da685b650d
#: ../../ref/forms/validation.txt:187
msgid "Raising multiple errors"
msgstr "Вызов нескольких ошибок"

# 0d9c6e51f0564e22be26f2e3d75bbde9
#: ../../ref/forms/validation.txt:189
msgid ""
"If you detect multiple errors during a cleaning method and wish to signal "
"all of them to the form submitter, it is possible to pass a list of errors "
"to the ``ValidationError`` constructor."
msgstr ""
"При обнаружении нескольких ошибок в процессе нормализации поля и при наличии "
"желания отобразить их одновременно на форме, следует передать их в виде "
"списка в конструктор исключения."

# fa7c6dfc436f4b15b0732e5364247f04
#: ../../ref/forms/validation.txt:193
msgid ""
"As above, it is recommended to pass a list of ``ValidationError`` instances "
"with ``code``\\s and ``params`` but a list of strings will also work::"
msgstr ""
"Рекомендуется использовать список объектов ``ValidationError`` с ``code`` и "
"``params``, но можно использовать просто список строк::"

# 9eeb0e676da741d69ec679b7d9eae1f7
#: ../../ref/forms/validation.txt:209
msgid "Using validation in practice"
msgstr "Использование проверки на практике"

# aac8d8efc6ad410e942a270410f8ffac
#: ../../ref/forms/validation.txt:211
msgid ""
"The previous sections explained how validation works in general for forms. "
"Since it can sometimes be easier to put things into place by seeing each "
"feature in use, here are a series of small examples that use each of the "
"previous features."
msgstr ""
"Выше мы рассмотрели как осуществляется проверка форм в целом. Так как "
"временами бывает проще разобраться с функционалом, просмотрев его в "
"действии, далее показан ряд небольших примеров, которые используют описанные "
"возможности."

# e3494411f62d4b848fb04b8bc19deea2
#: ../../ref/forms/validation.txt:219
msgid "Using validators"
msgstr "Использование валидаторов"

# 946d47fb191c428facd354abd58f4575
#: ../../ref/forms/validation.txt:221
msgid ""
"Django's form (and model) fields support use of simple utility functions and "
"classes known as validators. A validator is merely a callable object or "
"function that takes a value and simply returns nothing if the value is valid "
"or raises a :exc:`~django.core.exceptions.ValidationError` if not. These can "
"be passed to a field's constructor, via the field's ``validators`` argument, "
"or defined on the :class:`~django.forms.Field` class itself with the "
"``default_validators`` attribute."
msgstr ""
"Поля форм (и моделей) Django поддерживают использование простых функций и "
"классов, которые известны как валидаторы. Это просто функция, которая "
"принимает значение и ничего не возвращает, если значение верно, иначе "
"вызывает  :exc:`~django.core.exceptions.ValidationError`. Они могут быть "
"переданы в конструктор поля через аргумент ``validators`` или определены в "
"самом классе поля :class:`~django.forms.Field` с помощью атрибута "
"``default_validators``."

# 4e55c7fa49f94cac97beca8b7d366923
#: ../../ref/forms/validation.txt:229
msgid ""
"Simple validators can be used to validate values inside the field, let's "
"have a look at Django's ``SlugField``::"
msgstr ""
"Простые валидаторы могут использоваться для проверки значений внутри полей. "
"Давайте рассмотрим ``SlugField``::"

# 98b0ab38cbd94fb9b1289ef4a28b87b5
#: ../../ref/forms/validation.txt:238
msgid ""
"As you can see, ``SlugField`` is just a ``CharField`` with a customized "
"validator that validates that submitted text obeys to some character rules. "
"This can also be done on field definition so::"
msgstr ""
"Как можно увидеть ``SlugField`` — это обычное поле ``CharField``, которое "
"имеет валидатор, проверяющий вводимое значение на допустимые символы. Все "
"это можно указать при определении поля::"

# e9518ba34ed24aeea7da467e702f290d
#: ../../ref/forms/validation.txt:244
msgid "is equivalent to::"
msgstr "эквивалентно::"

# 99e56f4dc15841169cd854dc3ff027f8
#: ../../ref/forms/validation.txt:248
msgid ""
"Common cases such as validating against an email or a regular expression can "
"be handled using existing validator classes available in Django. For "
"example, ``validators.validate_slug`` is an instance of a :class:`~django."
"core.validators.RegexValidator` constructed with the first argument being "
"the pattern: ``^[-a-zA-Z0-9_]+$``. See the section on :doc:`writing "
"validators </ref/validators>` to see a list of what is already available and "
"for an example of how to write a validator."
msgstr ""
"Обычные проверки, такие как проверка email или по регулярному выражению, "
"можно выполнить используя существующие валидаторы Django. Например, "
"``validators.validate_slug`` экземпляр :class:`~django.core.validators."
"RegexValidator` с первым аргументом равным ``^[-a-zA-Z0-9_]+$``. Подробности "
"смотрите в разделе о :doc:`создании валидаторов </ref/validators>`."

# 48e48689c74948cfaf388d10f122f9bd
#: ../../ref/forms/validation.txt:257
msgid "Form field default cleaning"
msgstr "Встроенная проверка поля формы"

# c6d6e0cf5d7f41ed9971e303f8b037e9
#: ../../ref/forms/validation.txt:259
msgid ""
"Let's first create a custom form field that validates its input is a string "
"containing comma-separated email addresses. The full class looks like this::"
msgstr ""
"Давайте сначала создадим собственное поле формы, которое проверяет, что "
"переданные ему данные — это строка, содержащая адреса электронной почты, "
"разделенные запятыми. Класс такого поля будет выглядеть следующим образом::"

# 196f4110608a459680329ea10642076e
#: ../../ref/forms/validation.txt:280
msgid ""
"Every form that uses this field will have these methods run before anything "
"else can be done with the field's data. This is cleaning that is specific to "
"this type of field, regardless of how it is subsequently used."
msgstr ""
"Каждая форма, использующая такое поле, будет вызывать эти методы до "
"выполнения всех остальных действий с данными поля. Такая проверка привязана "
"к этому типу поля и не зависит от дальнейшего его использования."

# 8a9acc8446b5414598973cba372301e9
#: ../../ref/forms/validation.txt:284
msgid ""
"Let's create a simple ``ContactForm`` to demonstrate how you'd use this "
"field::"
msgstr ""
"Давайте создадим простую форму ``ContactForm``, чтобы показать как можно "
"использовать это поле::"

# 9efe8c8dd2d348fda999e54c90b9f98e
#: ../../ref/forms/validation.txt:294
msgid ""
"Simply use ``MultiEmailField`` like any other form field. When the "
"``is_valid()`` method is called on the form, the ``MultiEmailField.clean()`` "
"method will be run as part of the cleaning process and it will, in turn, "
"call the custom ``to_python()`` and ``validate()`` methods."
msgstr ""
"Просто используем ``MultiEmailField`` как и любое другое поле. При вызове "
"метода формы ``is_valid()`` происходит вызов метода ``MultiEmailField."
"clean()``, который в свою очередь вызовет собственные методы ``to_python()`` "
"и ``validate()``."

# 94e5e7859710405e9a6481e13a72ac7f
#: ../../ref/forms/validation.txt:300
msgid "Cleaning a specific field attribute"
msgstr "Проверка атрибута определённого поля"

# 0c3a50620e144ba98f9ed3b06b96cc66
#: ../../ref/forms/validation.txt:302
msgid ""
"Continuing on from the previous example, suppose that in our "
"``ContactForm``, we want to make sure that the ``recipients`` field always "
"contains the address ``\"fred@example.com\"``. This is validation that is "
"specific to our form, so we don't want to put it into the general "
"``MultiEmailField`` class. Instead, we write a cleaning method that operates "
"on the ``recipients`` field, like so::"
msgstr ""
"Продолжая работать над нашим примером, предположим, что на форме "
"``ContactForm`` поле электронной почты ``recipients`` всегда должно "
"содержать адрес ``\"fred@example.com\"``. Эта проверка будет особенностью "
"нашей формы, следовательно, нам не надо её помещать в класс "
"``MultiEmailField``. Вместо этого мы напишем метод, который будет проверять "
"поле ``recipients``::"

# 7ea73683891249818a6524d9ce98cdee
#: ../../ref/forms/validation.txt:326
msgid "Cleaning and validating fields that depend on each other"
msgstr "Очистка и проверка полей, которые зависят друг от друга"

# 5a4cc6ba283949699964219f535b253c
#: ../../ref/forms/validation.txt:328
msgid ""
"Suppose we add another requirement to our contact form: if the ``cc_myself`` "
"field is ``True``, the ``subject`` must contain the word ``\"help\"``. We "
"are performing validation on more than one field at a time, so the form's :"
"meth:`~Form.clean()` method is a good spot to do this. Notice that we are "
"talking about the ``clean()`` method on the form here, whereas earlier we "
"were writing a ``clean()`` method on a field. It's important to keep the "
"field and form difference clear when working out where to validate things. "
"Fields are single data points, forms are a collection of fields."
msgstr ""
"Допустим, что мы добавили ещё одно требование для нашей формы: если поле "
"``cc_myself`` равно ``True``, то поле ``subject`` должно содержать слово ``"
"\"help\"``. Раз мы выполняем проверку нескольких полей, то метод формы :meth:"
"`~Form.clean()` будет правильным местом для нашего кода. Обратите внимание, "
"мы сейчас говорим о методе ``clean()`` формы, а раньше говорили о методе "
"``clean()`` поля. Важно понимать разницу между ними при реализации алгоритма "
"проверки данных. Поля содержат один источник данных, а формы — это коллекции "
"полей."

# 8d2d52f32bdd448f9d638eb31e04649a
#: ../../ref/forms/validation.txt:337
msgid ""
"By the time the form's ``clean()`` method is called, all the individual "
"field clean methods will have been run (the previous two sections), so "
"``self.cleaned_data`` will be populated with any data that has survived so "
"far. So you also need to remember to allow for the fact that the fields you "
"are wanting to validate might not have survived the initial individual field "
"checks."
msgstr ""
"К моменту вызова метода формы ``clean()``  все ``clean()`` методы полей уже "
"отработали.  Таким образом, свойство формы ``self.cleaned_data`` будет "
"заполнено данными, прошедшими проверку. Следовательно, надо принять во "
"внимание возможность того, что данные некоторых полей не прошли начальную "
"поверку."

# 0999d493c3384cf086dc10e8ea23d8c5
#: ../../ref/forms/validation.txt:344
msgid ""
"There are two ways to report any errors from this step. Probably the most "
"common method is to display the error at the top of the form. To create such "
"an error, you can raise a ``ValidationError`` from the ``clean()`` method. "
"For example::"
msgstr ""
"Существует два способа сообщить об ошибках на этом этапе. Обычно ошибку "
"отображают сверху формы. Для этого достаточно вызвать исключение "
"``ValidationError`` в методе формы ``clean()``. Например::"

# 2b7112a898ec4633b8096d14ea42ed33
#: ../../ref/forms/validation.txt:368
msgid ""
"In this code, if the validation error is raised, the form will display an "
"error message at the top of the form (normally) describing the problem."
msgstr ""
"В данном коде, при возникновении ошибки во время проверки данных, форма "
"отобразит сообщение об ошибке сверху (обычное поведение), описывая проблему."

#: ../../ref/forms/validation.txt:371
#, fuzzy
msgid ""
"The call to ``super().clean()`` in the example code ensures that any "
"validation logic in parent classes is maintained. If your form inherits "
"another that doesn't return a ``cleaned_data`` dictionary in its ``clean()`` "
"method (doing so is optional), then don't assign ``cleaned_data`` to the "
"result of the ``super()`` call and use ``self.cleaned_data`` instead::"
msgstr ""
"Вызов ``super(ContactForm, self).clean()`` обеспечивает проверку данных в "
"родительском классе. Если ваша форма наследуется от класса, который не "
"возвращает словарь ``cleaned_data`` из метода ``clean()`` (это не "
"обязательно), не записывайте в ``cleaned_data`` результат вызова ``super()`` "
"и используйте вместо этого ``self.cleaned_data``::"

# 6c8bf7860b554c998fe30cfcfdc88874
#: ../../ref/forms/validation.txt:382
msgid ""
"The second approach for reporting validation errors might involve assigning "
"the error message to one of the fields. In this case, let's assign an error "
"message to both the \"subject\" and \"cc_myself\" rows in the form display. "
"Be careful when doing this in practice, since it can lead to confusing form "
"output. We're showing what is possible here and leaving it up to you and "
"your designers to work out what works effectively in your particular "
"situation. Our new code (replacing the previous sample) looks like this::"
msgstr ""
"Второй способ подразумевает назначение ошибки одному из полей. В нашем "
"случае, давайте назначим сообщение об ошибке обоим полям («subject» и "
"«cc_myself») при отображении формы. Использовать этот способ надо аккуратно, "
"так как он может запутать пользователя. Мы лишь показываем возможные "
"варианты, оставляя решение конкретной задачи вам и вашим дизайнерам. Наш "
"новый код (заменяющий предыдущий пример) выглядит так::"

# bc917bb9f4614c879c211978461d4809
#: ../../ref/forms/validation.txt:406
msgid ""
"The second argument of ``add_error()`` can be a simple string, or preferably "
"an instance of ``ValidationError``. See :ref:`raising-validation-error` for "
"more details. Note that ``add_error()`` automatically removes the field from "
"``cleaned_data``."
msgstr ""
"Вторым аргументом ``add_error()`` может быть просто строка, но лучше объект "
"``ValidationError``. Подробности смотрите в :ref:`raising-validation-error`. "
"Обратите внимание, ``add_error()`` автоматически убирает поле из "
"``cleaned_data``."

# 8593ee3099c347bb82a1ac587d42c7a1
#~ msgid ""
#~ "This method should return the cleaned value obtained from "
#~ "``cleaned_data``, regardless of whether it changed anything or not."
#~ msgstr ""
#~ "Этот метод должен возвращать очищенное значение, полученное из "
#~ "``cleaned_data`` независимо, изменилось оно или нет."

# 835544c33a8047dca5b9c411a1a503b0
#~ msgid ""
#~ "In previous versions of Django, ``form.clean()`` was required to return a "
#~ "dictionary of ``cleaned_data``. This method may still return a dictionary "
#~ "of data to be used, but it's no longer required."
#~ msgstr ""
#~ "В предыдущей версии Django ``form.clean()`` должен был возвращать словарь "
#~ "``cleaned_data``. Он все еще может возвращать словарь с проверенными "
#~ "данными, но это не обязательно."

# 553a06c427fe4694811d910072acce02
#~ msgid ""
#~ "Note that the call to ``super(ContactForm, self).clean()`` in the example "
#~ "code ensures that any validation logic in parent classes is maintained."
#~ msgstr ""
#~ "Следует отметить, что вызов ``super(ContactForm, self).clean()`` в "
#~ "приведенном коде обеспечивает выполнение дополнительной проверки "
#~ "средствами базового класса."

# b04913281bf64c99a81214fbba169465
#~ msgid ""
#~ "Sometimes you may want to add an error message to a particular field from "
#~ "the form's :meth:`~Form.clean()` method, in which case you can use :meth:"
#~ "`~django.forms.Form.add_error()`. Note that this won't always be "
#~ "appropriate and the more typical situation is to raise a "
#~ "``ValidationError`` from , which is turned into a form-wide error that is "
#~ "available through the :meth:`Form.non_field_errors() <django.forms.Form."
#~ "non_field_errors>` method."
#~ msgstr ""
#~ "Временами, в методе ``clean()`` формы, может потребоваться добавить "
#~ "сообщение об ошибке к определённому полю в методе :meth:`~Form.clean()`. "
#~ "Используйте для этого :meth:`~django.forms.Form.add_error()`. Это не "
#~ "совсем обычная ситуация, правильнее было бы вызвать исключение "
#~ "``ValidationError`` в методе``clean()`` формы, которое бы превратилось в "
#~ "ошибку самой формы и было бы доступно через метод формы  :meth:`Form."
#~ "non_field_errors() <django.forms.Form.non_field_errors>`."

# 0dba0b7d427046a59ca3057c0c3df5ae
#~ msgid ""
#~ "The ``clean()`` method for the ``Form`` class or subclass is always run. "
#~ "If that method raises a ``ValidationError``, ``cleaned_data`` will be an "
#~ "empty dictionary."
#~ msgstr ""
#~ "Метод ``clean()`` формы вызывается в любом случае. Если этот метод "
#~ "вызывает исключение ``ValidationError``, то атрибут ``cleaned_data`` "
#~ "формы будет содержать пустой словарь."

# f6b441d267c34719a36d900d6ef675d9
#~ msgid ""
#~ "The previous paragraph means that if you are overriding ``Form.clean()``, "
#~ "you should iterate through ``self.cleaned_data.items()``, possibly "
#~ "considering the ``_errors`` dictionary attribute on the form as well. In "
#~ "this way, you will already know which fields have passed their individual "
#~ "validation requirements."
#~ msgstr ""
#~ "Предыдущий параграф говорит , что если вы переопределили у формы метод "
#~ "``clean()``, то вы должны пройтись по ``self.cleaned_data.items()``, "
#~ "возможно проверив словарь в атрибуте ``_errors`` формы. В этом случае вы "
#~ "будете всегда знать, какое именно поле сгенерировало ошибку."

# 7671a61ccaa9442abb1755168487579c
#~ msgid "Form subclasses and modifying field errors"
#~ msgstr "Наследование форм и изменение ошибок полей"

# 8420abdd0c134ddaa82b9defce4e3824
#~ msgid ""
#~ "When you really do need to attach the error to a particular field, you "
#~ "should store (or amend) a key in the ``Form._errors`` attribute. This "
#~ "attribute is an instance of a ``django.forms.util.ErrorDict`` class. "
#~ "Essentially, though, it's just a dictionary. There is a key in the "
#~ "dictionary for each field in the form that has an error. Each value in "
#~ "the dictionary is a ``django.forms.util.ErrorList`` instance, which is a "
#~ "list that knows how to display itself in different ways. So you can treat "
#~ "``_errors`` as a dictionary mapping field names to lists."
#~ msgstr ""
#~ "Когда вам действительно потребуется добавить сообщение об ошибке к "
#~ "определённому полю, то следует добавить или дополнить значение словаря в "
#~ "атрибуте формы ``_errors``. Ключом будет имя поля. Этот атрибут является "
#~ "экземпляром класса ``django.forms.util.ErrorDict``. В любом случае, это "
#~ "просто словарь. Для каждого поля формы, в котором есть ошибка, в этом "
#~ "словаре будет храниться значение. Каждое значение этого словаря является "
#~ "экземпляром класса ``django.forms.util.ErrorList``, т.е. списком, который "
#~ "знает как отображать себя в разных ситуациях. Таким образом, вы можете "
#~ "рассматривать атрибут ``_errors`` как словарь, связывающий имена полей со "
#~ "списками ошибок."

# 300a9b40cbd74306bd38aabaa718c94d
#~ msgid ""
#~ "If you want to add a new error to a particular field, you should check "
#~ "whether the key already exists in ``self._errors`` or not. If not, create "
#~ "a new entry for the given key, holding an empty ``ErrorList`` instance. "
#~ "In either case, you can then append your error message to the list for "
#~ "the field name in question and it will be displayed when the form is "
#~ "displayed."
#~ msgstr ""
#~ "При добавлении ошибки для определённого поля, следует проверить наличие "
#~ "соответствующего ключа в атрибуте формы ``_errors``. Если такого ключа "
#~ "нет,  то создайте для него новую запись, содержащую пустой экземпляр "
#~ "``ErrorList``. В противном случае, вы можете добавить своё сообщение об "
#~ "ошибке в список ошибок поля и оно будет отображено на форме."

# 7238bc8bbc9d4b1eaed9cd393af9faee
#~ msgid ""
#~ "There is an example of modifying ``self._errors`` in the following "
#~ "section."
#~ msgstr "Пример внесения изменений в ``self._errors`` приведён далее."

# c53096b6444146ae8564b50d09ce4eac
#~ msgid ""
#~ "You may be wondering why is this attribute called ``_errors`` and not "
#~ "``errors``. Normal Python practice is to prefix a name with an underscore "
#~ "if it's not for external usage. In this case, you are subclassing the "
#~ "``Form`` class, so you are essentially writing new internals. In effect, "
#~ "you are given permission to access some of the internals of ``Form``."
#~ msgstr ""
#~ "Вас может заинтересовать, почему этот атрибут назван ``_errors``, а не "
#~ "``errors``. По традиции, в Python с символа подчеркивания начинаются "
#~ "имена объектов, которые предназначены для внутреннего использования. В "
#~ "данном случае, наследуясь от класса ``Form``, по существу, вы его "
#~ "реализуете заново. Следовательно, вам предоставляется право доступа к "
#~ "внутренним объектам класса ``Form``."

# a7b90913a8f449b398d689573be3eb87
#~ msgid ""
#~ "Of course, any code outside your form should never access ``_errors`` "
#~ "directly. The data is available to external code through the ``errors`` "
#~ "property, which populates ``_errors`` before returning it)."
#~ msgstr ""
#~ "Конечно, любой код вне вашей формы не должен обращаться к ``_errors`` "
#~ "напрямую. Содержимое этого атрибута доступно через свойство ``errors``, "
#~ "которое заполняет ``_errors`` перед тем как вернуть его."

# 80aa2fac45da469bb657a9ebd3c84652
#~ msgid ""
#~ "Another reason is purely historical: the attribute has been called "
#~ "``_errors`` since the early days of the forms module and changing it now "
#~ "(particularly since ``errors`` is used for the read-only property name) "
#~ "would be inconvenient for a number of reasons. You can use whichever "
#~ "explanation makes you feel more comfortable. The result is the same."
#~ msgstr ""
#~ "Другая причина чисто историческая: атрибут получил имя ``_errors`` с "
#~ "момента появления модуля форм и изменять его сейчас (особенно с момента, "
#~ "как имя ``errors`` начало использоваться свойством, из которого можно "
#~ "только получать данные) было бы неразумно по ряду причин. Вы можете "
#~ "выбрать понравившееся объяснение. Результат будет неизменен."

# 9c6bc23b5a1d4252bd45996291467e05
#~ msgid ""
#~ "As you can see, this approach requires a bit more effort, not "
#~ "withstanding the extra design effort to create a sensible form display. "
#~ "The details are worth noting, however. Firstly, earlier we mentioned that "
#~ "you might need to check if the field name keys already exist in the "
#~ "``_errors`` dictionary. In this case, since we know the fields exist in "
#~ "``self.cleaned_data``, they must have been valid when cleaned as "
#~ "individual fields, so there will be no corresponding entries in "
#~ "``_errors``."
#~ msgstr ""
#~ "Как видно из кода, этот подход требует некоторых усилий, не требуя "
#~ "дополнительного дизайна, для создания удобных форм. Тем не менее, "
#~ "остановимся на деталях. Во-первых, мы отметили ранее, что может "
#~ "потребоваться проверка наличия ключа для поля в свойстве ``_errors`` "
#~ "формы. В нашем случае, поскольку мы знаем, что раз поля присутствуют в "
#~ "``self.cleaned_data``, значит они смогли пройти проверку на уровне полей. "
#~ "Следовательно, для них не будет соответствующих значений в свойстве формы "
#~ "``_errors``."

# 8e2b04590ed74edd90f133cb516849c7
#~ msgid ""
#~ "Secondly, once we have decided that the combined data in the two fields "
#~ "we are considering aren't valid, we must remember to remove them from the "
#~ "``cleaned_data``."
#~ msgstr ""
#~ "Во-вторых, как только мы решили, что связанные данные двух полей не "
#~ "прошли проверку, то следует убрать их значения из свойства "
#~ "``cleaned_data``."

# 493c646956434536a6f1cc2af232dbe3
#~ msgid ""
#~ "Django used to remove the ``cleaned_data`` attribute entirely if there "
#~ "were any errors in the form. Since version 1.5, ``cleaned_data`` is "
#~ "present even if the form doesn't validate, but it contains only field "
#~ "values that did validate."
#~ msgstr ""
#~ "Django удаляла атрибут ``cleaned_data`` полностью, при наличии любой "
#~ "ошибки в форме. Начиная с версии 1.5, ``cleaned_data`` остаётся в форме, "
#~ "даже если последняя не прошла проверку данных, но атрибут содержит только "
#~ "значения тех полей, что смогли пройти проверку."

# 8eb58e1e2e4844038e984d68864a2633
#~ msgid ""
#~ "In fact, Django will currently completely wipe out the ``cleaned_data`` "
#~ "dictionary if there are any errors in the form. However, this behavior "
#~ "may change in the future, so it's not a bad idea to clean up after "
#~ "yourself in the first place."
#~ msgstr ""
#~ "На самом деле, в настоящее время Django полностью очищает свойство "
#~ "``cleaned_data`` при возникновении любой ошибки на форме. Тем не менее, "
#~ "такое поведение может быть изменено в будущем, так что лучше явно делать "
#~ "необходимую очистку."
