# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2014, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-12-08 11:07+0200\n"
"PO-Revision-Date: 2016-03-17 11:52+0200\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 6184e981af5f4369ad53ad53c6fb45d4
#: ../../ref/applications.txt:3
msgid "Applications"
msgstr "Приложения"

# 3d0a497f10ee412da39876c55693358f
#: ../../ref/applications.txt:7
msgid ""
"Django contains a registry of installed applications that stores "
"configuration and provides introspection. It also maintains a list of "
"available :doc:`models </topics/db/models>`."
msgstr ""
"Django содержит реестр установленных приложений, который содержит текущие "
"настройки и предоставляет интроспекцию. Также предоставляет список "
"доступных :doc:`моделей </topics/db/models>`."

# dfd89330fa7d452e81c49f85c715e64b
#: ../../ref/applications.txt:11
msgid ""
"This registry is simply called :attr:`~django.apps.apps` and it's available "
"in :mod:`django.apps`::"
msgstr ""
"Этот реестр называется просто :attr:`~django.apps.apps` и находится в "
"модуле :mod:`django.apps`::"

# 26e4aec6f85849d7a7e6e80a2aa062fd
#: ../../ref/applications.txt:19
msgid "Projects and applications"
msgstr "Проекты и приложения"

#: ../../ref/applications.txt:21
msgid ""
"The term **project** describes a Django web application. The project Python "
"package is defined primarily by a settings module, but it usually contains "
"other things. For example, when you run  ``django-admin startproject "
"mysite`` you'll get a ``mysite`` project directory that contains a "
"``mysite`` Python package with ``settings.py``, ``urls.py``, and ``wsgi."
"py``. The project package is often extended to include things like fixtures, "
"CSS, and templates which aren't tied to a particular application."
msgstr ""

#: ../../ref/applications.txt:29
msgid ""
"A **project's root directory** (the one that contains ``manage.py``) is "
"usually the container for all of a project's applications which aren't "
"installed separately."
msgstr ""

# 42159b1d350a4e95897f8cd71a9fadc8
#: ../../ref/applications.txt:33
#, fuzzy
msgid ""
"The term **application** describes a Python package that provides some set "
"of features. Applications :doc:`may be reused </intro/reusable-apps/>` in "
"various projects."
msgstr ""
"Термин **application** используется для пакета Python, который предоставляет "
"определенный функционал. Приложения могут повторно использоваться в "
"различных проектах."

# 049a1578bc584030b2771cc08c5d9b01
#: ../../ref/applications.txt:37
#, fuzzy
msgid ""
"Applications include some combination of models, views, templates, template "
"tags, static files, URLs, middleware, etc. They're generally wired into "
"projects with the :setting:`INSTALLED_APPS` setting and optionally with "
"other mechanisms such as URLconfs, the :setting:`MIDDLEWARE` setting, or "
"template inheritance."
msgstr ""
"Приложения содержат набор моделей, представлений, шаблонов, шаблонных тегов, "
"статических файлов, URL-ов, мидлваров, и прочее. Они добавляются в проект "
"через настройку :setting:`INSTALLED_APPS`, подключение в URLconfs, "
"настройку :setting:`MIDDLEWARE_CLASSES`, или наследование шаблонов."

# 717b82cd64724e77b9c426b3213fab40
#: ../../ref/applications.txt:43
msgid ""
"It is important to understand that a Django application is just a set of "
"code that interacts with various parts of the framework. There's no such "
"thing as an ``Application`` object. However, there's a few places where "
"Django needs to interact with installed applications, mainly for "
"configuration and also for introspection. That's why the application "
"registry maintains metadata in an :class:`~django.apps.AppConfig` instance "
"for each installed application."
msgstr ""
"Важно помнить, что приложение Django - это просто код, который работает с "
"различными частями фреймверка. Не существует такой вещи, как объект "
"``Application``. Однако, существуют ситуации, когда Django необходимо "
"работать с установленными приложениями, в основном для конфигурации и "
"интроспекции. Для этого реестр приложений содержит метаданные в объекте :"
"class:`~django.apps.AppConfig` для каждого экземпляра приложения."

#: ../../ref/applications.txt:50
msgid ""
"There's no restriction that a project package can't also be considered an "
"application and have models, etc. (which would require adding it to :setting:"
"`INSTALLED_APPS`)."
msgstr ""

# c89ec388166047e599f9204e50d97659
#: ../../ref/applications.txt:57
msgid "Configuring applications"
msgstr "Настройка приложений"

# 1d4f661ed9f84cadb674ea65f1e5b76c
#: ../../ref/applications.txt:59
msgid ""
"To configure an application, subclass :class:`~django.apps.AppConfig` and "
"put the dotted path to that subclass in :setting:`INSTALLED_APPS`."
msgstr ""
"Для настройки приложения создайте класс наследник :class:`~django.apps."
"AppConfig` и укажите путь для его импорта в :setting:`INSTALLED_APPS`."

# b87c9ee35ef545f5ad2ad65d3e6dfd6a
#: ../../ref/applications.txt:62
msgid ""
"When :setting:`INSTALLED_APPS` simply contains the dotted path to an "
"application module, Django checks for a ``default_app_config`` variable in "
"that module."
msgstr ""
"Если :setting:`INSTALLED_APPS` содержит путь просто к модулю приложения, "
"Django проверяет переменную ``default_app_config`` в модуле."

# 51228743eea2451c841c3e6ab85c341e
#: ../../ref/applications.txt:66
msgid ""
"If it's defined, it's the dotted path to the :class:`~django.apps.AppConfig` "
"subclass for that application."
msgstr ""
"Если она определена, она должна содержать путь для импорта класса "
"наследника :class:`~django.apps.AppConfig` для этого приложения."

# 0c770b52c3c24ce4a4e398aedec27c74
#: ../../ref/applications.txt:69
msgid ""
"If there is no ``default_app_config``, Django uses the base :class:`~django."
"apps.AppConfig` class."
msgstr ""
"Если ``default_app_config`` не существует, Django будет использовать базовый "
"класс :class:`~django.apps.AppConfig`."

# 3a0d673329434c0ba9b3dfd80134af12
#: ../../ref/applications.txt:72
msgid ""
"``default_app_config`` allows applications that predate Django 1.7 such as "
"``django.contrib.admin`` to opt-in to :class:`~django.apps.AppConfig` "
"features without requiring users to update their :setting:`INSTALLED_APPS`."
msgstr ""
"``default_app_config`` позволяет использовать :class:`~django.apps."
"AppConfig` для приложений, которые были созданы до Django 1.7, например "
"``django.contrib.admin``, без изменения :setting:`INSTALLED_APPS`."

#: ../../ref/applications.txt:76
msgid ""
"New applications should avoid ``default_app_config``. Instead they should "
"require the dotted path to the appropriate :class:`~django.apps.AppConfig` "
"subclass to be configured explicitly in :setting:`INSTALLED_APPS`."
msgstr ""
"Новые приложения не должны использовать ``default_app_config``. Вместо этого "
"они должны требовать указать путь к классу-наследнику :class:`~django.apps."
"AppConfig` в :setting:`INSTALLED_APPS`."

# 9db3d8a05cb841a9aeff9111569c881e
#: ../../ref/applications.txt:81
msgid "For application authors"
msgstr "Для разработчика приложений"

# 73481a9f0f4e4564bd0ed04416aa588b
#: ../../ref/applications.txt:83
msgid ""
"If you're creating a pluggable app called \"Rock ’n’ roll\", here's how you "
"would provide a proper name for the admin::"
msgstr ""
"Если вы разрабатываете приложение, которое называется \"Rock ’n’ roll\", вот "
"как вы можете указать правильное название для админки::"

# 3a97b6ca624043db9da24c9b2c1e1189
#: ../../ref/applications.txt:94
msgid ""
"You can make your application load this :class:`~django.apps.AppConfig` "
"subclass by default as follows::"
msgstr ""
"Вы можете указать Django использовать этот класс по умолчанию следующим "
"образом::"

# 3a0d673329434c0ba9b3dfd80134af12
#: ../../ref/applications.txt:101
msgid ""
"That will cause ``RockNRollConfig`` to be used when :setting:"
"`INSTALLED_APPS` just contains ``'rock_n_roll'``. This allows you to make "
"use of :class:`~django.apps.AppConfig` features without requiring your users "
"to update their :setting:`INSTALLED_APPS` setting. Besides this use case, "
"it's best to avoid using ``default_app_config`` and instead specify the app "
"config class in :setting:`INSTALLED_APPS` as described next."
msgstr ""
"Теперь ``RockNRollConfig`` будет использоваться, если в :setting:"
"`INSTALLED_APPS` просто указать ``'rock_n_roll'``. Теперь пользователи "
"приложения могут использовать настройки из :class:`~django.apps.AppConfig` "
"без изменения настройки :setting:`INSTALLED_APPS`. В большинстве случаев "
"рекомендуется не использовать ``default_app_config`` и явно указывать класс "
"настроек в :setting:`INSTALLED_APPS`."

# 7d98c5f6c8144a5dbbb277486704356b
#: ../../ref/applications.txt:108
msgid ""
"Of course, you can also tell your users to put ``'rock_n_roll.apps."
"RockNRollConfig'`` in their :setting:`INSTALLED_APPS` setting. You can even "
"provide several different :class:`~django.apps.AppConfig` subclasses with "
"different behaviors and allow your users to choose one via their :setting:"
"`INSTALLED_APPS` setting."
msgstr ""
"Конечно вы можете попросить пользователей использовать ``'rock_n_roll.apps."
"RockNRollConfig'`` в :setting:`INSTALLED_APPS`. Вы даже можете предоставить "
"несколько классов наследников :class:`~django.apps.AppConfig` с различными "
"настройками и позволить пользователям добавить необходимый в :setting:"
"`INSTALLED_APPS`."

# 301a4ac46a8442d48a01addb22759724
#: ../../ref/applications.txt:114
msgid ""
"The recommended convention is to put the configuration class in a submodule "
"of the application called ``apps``. However, this isn't enforced by Django."
msgstr ""
"Принято все классы настроек добавлять в под-модуль ``apps`` приложения. Но "
"Django не заставляет соблюдать это правило."

# 24f11e3f1c284364bea53680d90276bd
#: ../../ref/applications.txt:117
msgid ""
"You must include the :attr:`~django.apps.AppConfig.name` attribute for "
"Django to determine which application this configuration applies to. You can "
"define any attributes documented in the :class:`~django.apps.AppConfig` API "
"reference."
msgstr ""
"Необходимо указывать атрибут :attr:`~django.apps.AppConfig.name`, чтобы "
"Django мог определить к какому приложению относится класс конфигурации. "
"Полный список параметров можно найти в описании API :class:`~django.apps."
"AppConfig`."

# 0caf3c801b204356a8cd9e8e62a2c286
#: ../../ref/applications.txt:124
msgid ""
"If your code imports the application registry in an application's ``__init__."
"py``, the name ``apps`` will clash with the ``apps`` submodule. The best "
"practice is to move that code to a submodule and import it. A workaround is "
"to import the registry under a different name::"
msgstr ""
"Если ваш код импортирует реестр приложений в ``__init__.py`` приложения, "
"название ``apps`` будет пересекаться с под-модулем ``apps``. Можно вынести "
"этот код в под-модуль приложения и импортировать его в ``__init__.py``. "
"Другой вариант - импортировать реестр под другим названием::"

# 20f5921b5af949e6a1f946f4d2271b52
#: ../../ref/applications.txt:132
msgid "For application users"
msgstr "Для пользователей приложений"

# 51db10dd03224d6aa50d3ded32677f8c
#: ../../ref/applications.txt:134
#, fuzzy
msgid ""
"If you're using \"Rock ’n’ roll\" in a project called ``anthology``, but you "
"want it to show up as \"Jazz Manouche\" instead, you can provide your own "
"configuration::"
msgstr ""
"Если вы используете приложение с \"Rock ’n’ roll\" в проекте, который "
"называется ``anthology``, и хотите заменить на \"Gypsy jazz\", вы можете "
"добавить свой класс настроек::"

# 5a697c03020b44f8886faedf9edc5d54
#: ../../ref/applications.txt:152
msgid ""
"Again, defining project-specific configuration classes in a submodule called "
"``apps`` is a convention, not a requirement."
msgstr ""
"Опять же, определять классы настроек в под-модуле ``apps`` - это просто "
"неписанное соглашение, а не правило."

# 3e8c358b7b1242b2ac60127000020973
#: ../../ref/applications.txt:156
msgid "Application configuration"
msgstr "Конфигурация приложения"

# 95c5f5bb807846dc9c28d2e74718db60
#: ../../ref/applications.txt:160
msgid ""
"Application configuration objects store metadata for an application. Some "
"attributes can be configured in :class:`~django.apps.AppConfig` subclasses. "
"Others are set by Django and read-only."
msgstr ""
"Объект конфигурации приложения содержит метаданные о приложении. Некоторые "
"атрибуты можно указать в классе наследнике :class:`~django.apps.AppConfig`. "
"Некоторые определены Django и доступны только для чтения."

# 77bcc150ba7f4ece9834ef0b23a13d29
#: ../../ref/applications.txt:165
msgid "Configurable attributes"
msgstr "Настраиваемые атрибуты"

# b5b6a9705693426d9dee8ced333554b5
#: ../../ref/applications.txt:169
msgid "Full Python path to the application, e.g. ``'django.contrib.admin'``."
msgstr ""
"Полный Python путь для импорта приложения, например ``'django.contrib."
"admin'``."

# 4b1530adc94e43e9a8964489a7ccbd04
#: ../../ref/applications.txt:171
msgid ""
"This attribute defines which application the configuration applies to. It "
"must be set in all :class:`~django.apps.AppConfig` subclasses."
msgstr ""
"Этот атрибут указывает к какому приложению относится класс настроек. Должен "
"указываться во всех классах наследниках :class:`~django.apps.AppConfig`."

# 2587693d6192489da11ff99030a4548c
# a753a8157e1043158a8271042735ce13
#: ../../ref/applications.txt:174 ../../ref/applications.txt:184
msgid "It must be unique across a Django project."
msgstr "Должен быть уникальным для проекта."

# c78628924c74443e88dac4232a6c63a1
#: ../../ref/applications.txt:178
msgid "Short name for the application, e.g. ``'admin'``"
msgstr "Короткое название(метка) приложения, например ``'admin'``"

# 27b61fc3a8d54a8f99869e6ae661f877
#: ../../ref/applications.txt:180
msgid ""
"This attribute allows relabeling an application when two applications have "
"conflicting labels. It defaults to the last component of ``name``. It should "
"be a valid Python identifier."
msgstr ""
"Этот атрибут позволяет поменять метку приложения, если два приложения "
"используют по умолчанию одинаковые метки. По умолчанию метка равна последней "
"части значения ``name``. Метка должна быть правильным идентификатором Python."

# 1bc08e5ab501449eaf5a8431d41b6b0b
#: ../../ref/applications.txt:188
msgid "Human-readable name for the application, e.g. \"Administration\"."
msgstr "Читабельное название приложения, например \"Administration\"."

# b71a553106fe4d868d766edff07a3ac1
#: ../../ref/applications.txt:190
msgid "This attribute defaults to ``label.title()``."
msgstr "По умолчанию равен ``label.title()``."

# ea53f0314a0e4a97a08340be677a617d
#: ../../ref/applications.txt:194
msgid ""
"Filesystem path to the application directory, e.g. ``'/usr/lib/python3.4/"
"dist-packages/django/contrib/admin'``."
msgstr ""
"Путь в файловой системе к каталогу с приложением, например ``'/usr/lib/"
"python3.4/dist-packages/django/contrib/admin'``."

# 6439d92ed2ca49dfb4797dcbdfd9effd
#: ../../ref/applications.txt:197
msgid ""
"In most cases, Django can automatically detect and set this, but you can "
"also provide an explicit override as a class attribute on your :class:"
"`~django.apps.AppConfig` subclass. In a few situations this is required; for "
"instance if the app package is a `namespace package`_ with multiple paths."
msgstr ""
"В большинстве случае Django может автоматически определить и установить это "
"значение, но вы можете переопределить его в классе наследнике :class:"
"`~django.apps.AppConfig`. Это может понадобиться в некоторых случаях, "
"например, если пакет приложения является :ref:`namespace-пакетом <namespace "
"package>` и расположен в нескольких каталогах."

# e81dac903c014139afe2518344847e7d
#: ../../ref/applications.txt:204
msgid "Read-only attributes"
msgstr "Неизменяемые атрибуты"

# a1d9be5c0a7449dda4639360a2399221
#: ../../ref/applications.txt:208
msgid ""
"Root module for the application, e.g. ``<module 'django.contrib.admin' from "
"'django/contrib/admin/__init__.pyc'>``."
msgstr ""
"Корневой модуль приложения, например ``<module 'django.contrib.admin' from "
"'django/contrib/admin/__init__.pyc'>``."

# abf90fd4ca3346c5939575a64d3f7fef
#: ../../ref/applications.txt:213
msgid ""
"Module containing the models, e.g. ``<module 'django.contrib.admin.models' "
"from 'django/contrib/admin/models.pyc'>``."
msgstr ""
"Модуль, который содержит модели, например ``<module 'django.contrib.admin."
"models' from 'django/contrib/admin/models.pyc'>``."

# b291181cf9b84179bc331041ce54cc22
#: ../../ref/applications.txt:216
msgid ""
"It may be ``None`` if the application doesn't contain a ``models`` module. "
"Note that the database related signals such as :data:`~django.db.models."
"signals.pre_migrate` and :data:`~django.db.models.signals.post_migrate` are "
"only emitted for applications that have a ``models`` module."
msgstr ""
"Может быть ``None``, если приложение не содержит модуль ``models``. Обратите "
"внимание, сигналы, связанные с базой данных, такие как :data:`~django.db."
"models.signals.pre_migrate` и :data:`~django.db.models.signals."
"post_migrate`, вызываются только для приложений, которые содержат модуль "
"``models``."

# 317a63a3e02441118c1c71d57a3460b8
#: ../../ref/applications.txt:223
msgid "Methods"
msgstr "Методы"

# 857a7693bc384a68b86672cb00d50dae
#: ../../ref/applications.txt:227
msgid ""
"Returns an iterable of :class:`~django.db.models.Model` classes for this "
"application."
msgstr ""
"Возвращает итератор по классам :class:`~django.db.models.Model` для текущего "
"приложения."

# b3c6725f378b4b8c8edd5d045fe87aa3
#: ../../ref/applications.txt:232
msgid ""
"Returns the :class:`~django.db.models.Model` with the given ``model_name``. "
"Raises :exc:`LookupError` if no such model exists in this application. "
"``model_name`` is case-insensitive."
msgstr ""
"Возвращает :class:`~django.db.models.Model` для переданного ``model_name``. "
"Вызывает :exc:`LookupError`, если модель не существует. ``model_name`` "
"регистро-независимое значение."

# 1fe323cf62c44e248a671b6fccfc44b5
#: ../../ref/applications.txt:238
msgid ""
"Subclasses can override this method to perform initialization tasks such as "
"registering signals. It is called as soon as the registry is fully populated."
msgstr ""
"Класс наследник может переопределить этот метод, чтобы выполнить "
"инициализацию приложения, например зарегистрировать сигналы. Вызывает, когда "
"реестр приложений будет полностью инициализирован и все приложения будут "
"добавлены."

#: ../../ref/applications.txt:242
msgid ""
"Although you can't import models at the module-level where :class:`~django."
"apps.AppConfig` classes are defined, you can import them in ``ready()``, "
"using either an ``import`` statement or :meth:`~AppConfig.get_model`."
msgstr ""

#: ../../ref/applications.txt:247
msgid ""
"If you're registering :mod:`model signals <django.db.models.signals>`, you "
"can refer to the sender by its string label instead of using the model class "
"itself."
msgstr ""

#: ../../ref/applications.txt:251
msgid "Example::"
msgstr ""

# 0572ebf84f8d4e2c9f3050d49a16135b
#: ../../ref/applications.txt:265
msgid ""
"Although you can access model classes as described above, avoid interacting "
"with the database in your :meth:`ready()` implementation. This includes "
"model methods that execute queries (:meth:`~django.db.models.Model.save()`, :"
"meth:`~django.db.models.Model.delete()`, manager methods etc.), and also raw "
"SQL queries via ``django.db.connection``. Your :meth:`ready()` method will "
"run during startup of every management command. For example, even though the "
"test database configuration is separate from the production settings, "
"``manage.py test`` would still execute some queries against your "
"**production** database!"
msgstr ""
"Хотя вы и можете получить доступ к моделям, как в примере выше, избегайте "
"работы с базой данных в методе :meth:`ready()`. Это включает методы, которые "
"выполняют запросы к базе данных (:meth:`~django.db.models.Model.save()`, :"
"meth:`~django.db.models.Model.delete()`, методы менеджера и т.д.) и SQL "
"запросы через ``django.db.connection``. Метод :meth:`ready()` будет "
"вызываться при каждом запуске команды Django. Например, хотя настройка "
"тестовой базы данных отделена от рабочих настроек проекта, ``manage.py "
"test`` выполнила бы запросы на **рабочей** базе данных!"

# 88ac827c1ef741bf80ae509e93c98cc0
#: ../../ref/applications.txt:278
msgid ""
"In the usual initialization process, the ``ready`` method is only called "
"once by Django. But in some corner cases, particularly in tests which are "
"fiddling with installed applications, ``ready`` might be called more than "
"once. In that case, either write idempotent methods, or put a flag on your "
"``AppConfig`` classes to prevent re-running code which should be executed "
"exactly one time."
msgstr ""
"При обычном процессе инициализации метод ``ready`` вызывается Django только "
"один раз. Но в некоторых случаях, в частности при выполнении тестов, "
"``ready`` может вызываться несколько раз. Вам следует писать идемпотентный "
"код(который можно безопасно вызывать несколько раз), или добавить флаг в "
"класс ``AppConfig`` и проверять его, чтобы код выполнялся только один раз."

# c97d9c5ba502478d8dfcc7e7f3293169
#: ../../ref/applications.txt:288
msgid "Namespace packages as apps (Python 3.3+)"
msgstr "Namespace-пакеты приложений (Python 3.3+)"

# 4143b6da920a446f9f905b2ac285201b
#: ../../ref/applications.txt:290
msgid ""
"Python versions 3.3 and later support Python packages without an ``__init__."
"py`` file. These packages are known as \"namespace packages\" and may be "
"spread across multiple directories at different locations on ``sys.path`` "
"(see :pep:`420`)."
msgstr ""
"Python версии 3.3 и выше поддерживает Python пакеты без файла ``__init__."
"py``. Эти пакеты называют \"namespace-пакетами\" и могут находится в "
"нескольких каталогах в ``sys.path`` (смотрите :pep:`420`)."

# 1075e23b9c9b490991f25b821997e743
#: ../../ref/applications.txt:295
msgid ""
"Django applications require a single base filesystem path where Django "
"(depending on configuration) will search for templates, static assets, etc. "
"Thus, namespace packages may only be Django applications if one of the "
"following is true:"
msgstr ""
"Django приложениям необходим один основной путь в файловой системе, где "
"Django (в зависимости от настроек) будет искать шаблоны, статические файлы, "
"и прочее. Таким образом, namespace-пакеты могут быть приложениями Django "
"только при следующих условиях:"

# fd150b061fbc4b35a5e6a81c91e91ea9
#: ../../ref/applications.txt:300
msgid ""
"The namespace package actually has only a single location (i.e. is not "
"spread across more than one directory.)"
msgstr ""
"Namespace-пакет содержит один каталог (то есть не разделен на несколько "
"каталогов)"

# cc394dde190244d0aa1645eca2a3ad6e
#: ../../ref/applications.txt:303
msgid ""
"The :class:`~django.apps.AppConfig` class used to configure the application "
"has a :attr:`~django.apps.AppConfig.path` class attribute, which is the "
"absolute directory path Django will use as the single base path for the "
"application."
msgstr ""
"Используется класс :class:`~django.apps.AppConfig`, указывающий в :attr:"
"`~django.apps.AppConfig.path` один абсолютный путь к каталогу, который "
"Django будет использовать как каталог приложения."

# fe7b5a0918334ddb9396a99299f7e72f
#: ../../ref/applications.txt:308
msgid ""
"If neither of these conditions is met, Django will raise :exc:`~django.core."
"exceptions.ImproperlyConfigured`."
msgstr ""
"Если ни одно из этих условий не соблюдено, Django вызовет исключение :exc:"
"`~django.core.exceptions.ImproperlyConfigured`."

# 1c095ff53dd04e2eafa8477ffb23e51e
#: ../../ref/applications.txt:312
msgid "Application registry"
msgstr "Реестр приложений"

# df39fc1279904b3781696685494d7d62
#: ../../ref/applications.txt:316
msgid ""
"The application registry provides the following public API. Methods that "
"aren't listed below are considered private and may change without notice."
msgstr ""
"Реестр приложений предоставляет следующий публичный API. Методы, которые не "
"описаны здесь, являются приватными и могут изменяться в будущем без "
"предупреждений."

# a60f9a8c3189491e975a252795b2094d
#: ../../ref/applications.txt:321
#, fuzzy
msgid ""
"Boolean attribute that is set to ``True`` after the registry is fully "
"populated and all :meth:`AppConfig.ready` methods are called."
msgstr ""
"Булев атрибут, который устанавливается в ``True``, когда реестр полностью "
"проинициализирован."

# 6e6601037172493eb50aa5b86a5679cd
#: ../../ref/applications.txt:326
msgid "Returns an iterable of :class:`~django.apps.AppConfig` instances."
msgstr "Возвращает итератор по объектам :class:`~django.apps.AppConfig`."

# 6ae56e4d169e457aaff559b61d7ce376
#: ../../ref/applications.txt:330
msgid ""
"Returns an :class:`~django.apps.AppConfig` for the application with the "
"given ``app_label``. Raises :exc:`LookupError` if no such application exists."
msgstr ""
"Возвращает :class:`~django.apps.AppConfig` приложения для ``app_label``. "
"Вызывает :exc:`LookupError`, если приложение не найдено."

# 11c7325177864dd2a54ff1d899bb17af
#: ../../ref/applications.txt:336
msgid ""
"Checks whether an application with the given name exists in the registry. "
"``app_name`` is the full name of the app, e.g. ``'django.contrib.admin'``."
msgstr ""
"Проверяет добавлено ли приложение с таким названием в реестр. ``app_name`` - "
"полное название приложения, например ``'django.contrib.admin'``."

# ffd9fccfc2d6488fa0dafa087f642386
#: ../../ref/applications.txt:341
msgid ""
"Returns the :class:`~django.db.models.Model` with the given ``app_label`` "
"and ``model_name``. As a shortcut, this method also accepts a single "
"argument in the form ``app_label.model_name``. ``model_name`` is case- "
"insensitive."
msgstr ""
"Возвращает :class:`~django.db.models.Model` для ``app_label`` и "
"``model_name``. Для удобства принимает аргумент вида ``app_label."
"model_name``. ``model_name`` - регистро-независимое значение."

# d7e5c54ca3d140e7aeb32e1b9775a225
#: ../../ref/applications.txt:346
msgid ""
"Raises :exc:`LookupError` if no such application or model exists. Raises :"
"exc:`ValueError` when called with a single argument that doesn't contain "
"exactly one dot."
msgstr ""
"Вызывает :exc:`LookupError`, если приложение или модель не найдена. "
"Вызывает :exc:`ValueError`, если передан один аргумент неправильного формата."

# 96b3f8e72c374edfa95c87d4c5087e65
#: ../../ref/applications.txt:351
msgid "Initialization process"
msgstr "Процесс инициализации"

# 6fb32cd827e641feb591b396294b700e
#: ../../ref/applications.txt:354
msgid "How applications are loaded"
msgstr "Как загружаются приложения"

# 3d7e4db343f54d708b72b261da12153f
#: ../../ref/applications.txt:356
msgid ""
"When Django starts, :func:`django.setup()` is responsible for populating the "
"application registry."
msgstr ""
"Функция :func:`django.setup()` отвечает за заполнение реестра приложений при "
"запуске Django."

# 652880d1200d45cd90dc1cd0bb594c5c
#: ../../ref/applications.txt:363
msgid "Configures Django by:"
msgstr "Настраивает Django, выполняя следующие действия:"

# aed601dc0e5b4578860ae8fa2aa82885
#: ../../ref/applications.txt:365
msgid "Loading the settings."
msgstr "Загрузка настроек."

# 891bf6c78d4649bfacf342014c584de7
#: ../../ref/applications.txt:366
msgid "Setting up logging."
msgstr "Настройка логирования."

#: ../../ref/applications.txt:367
msgid ""
"If ``set_prefix`` is True, setting the URL resolver script prefix to :"
"setting:`FORCE_SCRIPT_NAME` if defined, or ``/`` otherwise."
msgstr ""

# d50543d77d134874b82c07a54bcdc899
#: ../../ref/applications.txt:369
msgid "Initializing the application registry."
msgstr "Инициализация реестра приложений."

#: ../../ref/applications.txt:373
msgid "The ability to set the URL resolver script prefix is new."
msgstr ""

# f994069efd194180b4d0fb243aaf404a
#: ../../ref/applications.txt:375
msgid "This function is called automatically:"
msgstr "Эта функция вызывается автоматически:"

# 6ab7650419864cc18e017b162a719193
#: ../../ref/applications.txt:377
msgid "When running an HTTP server via Django's WSGI support."
msgstr "При запуске HTTP сервера с Django через WSGI."

# e87f7f6b22974c9c8bb3f6e62141b3bc
#: ../../ref/applications.txt:378
msgid "When invoking a management command."
msgstr "При выполнении команды Django."

# 5cd924d945a24e66ab6d531e6037f50b
#: ../../ref/applications.txt:380
msgid ""
"It must be called explicitly in other cases, for instance in plain Python "
"scripts."
msgstr ""
"Этот метод необходимо вызывать явно в некоторых случаях, например в Python "
"скрипте."

# 8d23c752a9dd4e65933fa358af208ea2
#: ../../ref/applications.txt:385
msgid ""
"The application registry is initialized in three stages. At each stage, "
"Django processes all applications in the order of :setting:`INSTALLED_APPS`."
msgstr ""
"Реестр приложений инициализируется в три этапа. На каждом этапе Django "
"обрабатывает приложения в порядке, указанном в :setting:`INSTALLED_APPS`."

# 92e70b3d71324e81896bf9c22c72583c
#: ../../ref/applications.txt:388
msgid "First Django imports each item in :setting:`INSTALLED_APPS`."
msgstr ""
"Первым делом Django импортирует каждый элемент :setting:`INSTALLED_APPS`."

# 043c40f58a1d4ae2ab78b7879a39b905
#: ../../ref/applications.txt:390
msgid ""
"If it's an application configuration class, Django imports the root package "
"of the application, defined by its :attr:`~AppConfig.name` attribute. If "
"it's a Python package, Django creates a default application configuration."
msgstr ""
"Если это класс настроек приложения, Django импортирует главный пакет "
"приложения, указанный в атрибуте :attr:`~AppConfig.name`. Если это пакет "
"Python, Django создает настройки по умолчанию для приложения."

# f1f56a9d27df444a95c5a7464d7e95d7
#: ../../ref/applications.txt:394
msgid "*At this stage, your code shouldn't import any models!*"
msgstr "*На этом этапе ваш код не должен импортировать модели!*"

# 89045fd1fc644f988344d7761b7bd297
#: ../../ref/applications.txt:396
msgid ""
"In other words, your applications' root packages and the modules that define "
"your application configuration classes shouldn't import any models, even "
"indirectly."
msgstr ""
"Другими словами, ваш главный пакет и модули, которые содержат классы "
"настроек, не должны импортировать модели, в том числе и неявно."

# 689b2b4b7bff46be90b310c204f5e92c
#: ../../ref/applications.txt:400
msgid ""
"Strictly speaking, Django allows importing models once their application "
"configuration is loaded. However, in order to avoid needless constraints on "
"the order of :setting:`INSTALLED_APPS`, it's strongly recommended not import "
"any models at this stage."
msgstr ""
"По правде говоря, Django позволяет импортировать модели, когда настройки "
"приложения уже загружены. Однако, чтобы избежать проблем и ограничений с "
"порядком приложений в :setting:`INSTALLED_APPS`, мы настоятельно рекомендуем "
"не делать этого на этом этапе."

# 1f0db4228b3e437bbd6c2ef43e281831
#: ../../ref/applications.txt:405
msgid ""
"Once this stage completes, APIs that operate on application configurations "
"such as :meth:`~apps.get_app_config()` become usable."
msgstr ""
"После выполнения этого этапа, можно использовать API, который работает с "
"настройками приложения, например :meth:`~apps.get_app_config()`."

# 4f08f399fbd54c9b9d49e409c6d8d37d
#: ../../ref/applications.txt:408
msgid ""
"Then Django attempts to import the ``models`` submodule of each application, "
"if there is one."
msgstr ""
"Затем Django пытается импортировать модуль ``models`` каждого приложения, "
"если такой существует."

# 7a57d2feb6d44dec8b284584731decd3
#: ../../ref/applications.txt:411
msgid ""
"You must define or import all models in your application's ``models.py`` or "
"``models/__init__.py``. Otherwise, the application registry may not be fully "
"populated at this point, which could cause the ORM to malfunction."
msgstr ""
"Вы должны определить или импортировать все модели в ``models.py`` или "
"``models/__init__.py`` приложения. Иначе, реестр приложений будет не "
"полностью заполнен, что может привести к неправильной работе ORM."

# 351dfe702edf415ab1359106bf006800
#: ../../ref/applications.txt:415
msgid ""
"Once this stage completes, APIs that operate on models such as :meth:`~apps."
"get_model()` become usable."
msgstr ""
"После выполнения этого этапа, можно использовать API, который работает с "
"моделями, например :meth:`~apps.get_model()`."

# 7624167026ca460d974f9cd174e5803e
#: ../../ref/applications.txt:418
msgid ""
"Finally Django runs the :meth:`~AppConfig.ready()` method of each "
"application configuration."
msgstr ""
"В конце Django вызывает метод :meth:`~AppConfig.ready()` для каждого "
"приложения."

# 1c2cfab5043a4d6da88094014f26b49e
#: ../../ref/applications.txt:424
msgid "Troubleshooting"
msgstr "Решение проблем"

# 3c9afbb9fddf4462985e778107903f07
#: ../../ref/applications.txt:426
msgid ""
"Here are some common problems that you may encounter during initialization:"
msgstr ""
"Вот список некоторых проблем, которые могут возникнуть при инициализации:"

# 87e5d70cf5a44049bbb2d01a2849a796
#: ../../ref/applications.txt:428
msgid ""
"``AppRegistryNotReady`` This happens when importing an application "
"configuration or a models module triggers code that depends on the app "
"registry."
msgstr ""
"``AppRegistryNotReady``. Вызывается при импорте настроек приложения или "
"модуля моделей, код которых использует реестр приложений."

# 87773a486c64491e8f7ac9568417578c
#: ../../ref/applications.txt:432
msgid ""
"For example, :func:`~django.utils.translation.ugettext()` uses the app "
"registry to look up translation catalogs in applications. To translate at "
"import time, you need :func:`~django.utils.translation.ugettext_lazy()` "
"instead. (Using :func:`~django.utils.translation.ugettext()` would be a bug, "
"because the translation would happen at import time, rather than at each "
"request depending on the active language.)"
msgstr ""
"Например, :func:`~django.utils.translation.ugettext()` использует реестр "
"приложений для поиска каталогов с файлами локализации. Для локализации на "
"этапе импорта используйте :func:`~django.utils.translation.ugettext_lazy()`. "
"(Использование :func:`~django.utils.translation.ugettext()` приведет к багу, "
"т.к. перевод будет выполнен на момент импорта, а не для каждого запрос с "
"учетом активной локалид.)"

# df0ada8c9e934316ba0dbc670dbd0b88
#: ../../ref/applications.txt:439
msgid ""
"Executing database queries with the ORM at import time in models modules "
"will also trigger this exception. The ORM cannot function properly until all "
"models are available."
msgstr ""
"Выполнение запросов к базе данных с помощью ORM в процессе импорта модуля "
"моделей вызовет исключение. ORM не может работать, пока все модели не будут "
"загружены."

# 04820e65523042ad887bedcc4842d43c
#: ../../ref/applications.txt:443
msgid ""
"Another common culprit is :func:`django.contrib.auth.get_user_model()`. Use "
"the :setting:`AUTH_USER_MODEL` setting to reference the User model at import "
"time."
msgstr ""
"Еще одна причина ошибок - :func:`django.contrib.auth.get_user_model()`. "
"Используйте настройку :setting:`AUTH_USER_MODEL` для указания ссылки на "
"модель пользователя на этапе импорта."

# ec30ede352aa44dc88bb1b571fda5a7a
#: ../../ref/applications.txt:447
msgid ""
"This exception also happens if you forget to call :func:`django.setup()` in "
"a standalone Python script."
msgstr ""
"Эта ошибка также вызывается, если :func:`django.setup()` не был вызван в "
"Python скрипте."

# ca9eddb117074f888d7e963a1e999f7d
#: ../../ref/applications.txt:450
msgid ""
"``ImportError: cannot import name ...`` This happens if the import sequence "
"ends up in a loop."
msgstr ""
"``ImportError: cannot import name ...``. Ошибка вызывается при циклических "
"импортах."

# 60ac6d1e8f654bf9887408e879021abc
#: ../../ref/applications.txt:453
msgid ""
"To eliminate such problems, you should minimize dependencies between your "
"models modules and do as little work as possible at import time. To avoid "
"executing code at import time, you can move it into a function and cache its "
"results. The code will be executed when you first need its results. This "
"concept is known as \"lazy evaluation\"."
msgstr ""
"Для устранения таких проблем необходимо минимизировать зависимости между "
"модулями моделей и в процессе импорта выполнять минимум действий. Чтобы "
"избежать выполнения кода на этапе импорта, вынесите его в функцию, которая "
"умеет кэшировать результат. Затем вызовите функции при необходимости. Такая "
"концепция называется \"ленивое выполнение\"."

# 43df0337bd4f44eba24ddda265c23b13
#: ../../ref/applications.txt:459
msgid ""
"``django.contrib.admin`` automatically performs autodiscovery of ``admin`` "
"modules in installed applications. To prevent it, change your :setting:"
"`INSTALLED_APPS` to contain ``'django.contrib.admin.apps."
"SimpleAdminConfig'`` instead of ``'django.contrib.admin'``."
msgstr ""
"``django.contrib.admin`` автоматически выполняет регистрацию модулей "
"``admin`` установленных приложений. Чтобы отключить это, укажите в :setting:"
"`INSTALLED_APPS` ``'django.contrib.admin.apps.SimpleAdminConfig'`` вместо "
"``'django.contrib.admin'``."

# fe58c65cd28443a4982031254d26d37d
#~ msgid ""
#~ "Django has historically used the term **project** to describe an "
#~ "installation of Django. A project is defined primarily by a settings "
#~ "module."
#~ msgstr ""
#~ "Django исторически использует термин **проект** для установленной версии "
#~ "Django. Проект в первую очередь определяется наличием модуля настроек."

# 162227c8122143e88931a9f35ee4536e
#~ msgid ""
#~ "This terminology is somewhat confusing these days as it became common to "
#~ "use the phrase \"web app\" to describe what equates to a Django project."
#~ msgstr ""
#~ "Сейчас такая терминология вводит в заблуждение т.к. термин \"веб-"
#~ "приложение\" часто используется для описания проекта Django."

# ac9390303ea74dec8b57bada4fa86aee
#~ msgid ""
#~ "You cannot import models in modules that define application configuration "
#~ "classes, but you can use :meth:`get_model` to access a model class by "
#~ "name, like this::"
#~ msgstr ""
#~ "Вы не можете импортировать модели в модуле, который содержит классы "
#~ "настроек, но вы можете использовать метод :meth:`get_model`, чтобы "
#~ "получить модель по названию::"
