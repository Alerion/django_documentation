# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016.
# paranoid <brain2dump@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-03 16:48+0300\n"
"PO-Revision-Date: 2018-05-29 18:26+0300\n"
"Last-Translator: paranoid <brain2dump@gmail.com>\n"
"Language-Team: русский <>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.7\n"

# 44a89a46f3e148ee966538fa70492490
#: ../../topics/http/urls.txt:3
msgid "URL dispatcher"
msgstr "Менеджер URL-ов"

# 17df4924b86442ad89dcf7d0419847af
#: ../../topics/http/urls.txt:5
msgid ""
"A clean, elegant URL scheme is an important detail in a high-quality Web "
"application. Django lets you design URLs however you want, with no framework "
"limitations."
msgstr ""
"Чистая, элегантная схема URL-ов -- это важная часть качественного "
"приложения. Django позволяет проектировать URL-адреса как вы пожелаете, без "
"ограничений \"фреймворка\"."

# 57872ae9e3b04448989f58fbba7a0059
#: ../../topics/http/urls.txt:9
msgid ""
"There's no ``.php`` or ``.cgi`` required, and certainly none of that "
"``0,2097,1-1-1928,00`` nonsense."
msgstr ""
"В  URL-ах не нужны ни ``.php``, ни ``.cgi``, ни всякая ерунда вроде "
"``0,2097,1-1-1928,00``."

# ff73ff2f19c0487d9a216ff2537ef310
#: ../../topics/http/urls.txt:12
msgid ""
"See `Cool URIs don't change`_, by World Wide Web creator Tim Berners-Lee, "
"for excellent arguments on why URLs should be clean and usable."
msgstr ""
"Читайте `Cool URIs don't change <http://www.w3.org/Provider/Style/URI>`_, "
"создателя World Wide Web, Тима Бернерса-Ли, чтобы узнать почему URL-ы должны "
"быть красивыми и практичными."

# 3fb1d863ce6d42f89ebbe0b643b704e0
#: ../../topics/http/urls.txt:18
msgid "Overview"
msgstr "Обзор"

# 94510b9fca3b475b8bb54eee7b08717d
#: ../../topics/http/urls.txt:20
msgid ""
"To design URLs for an app, you create a Python module informally called a "
"**URLconf** (URL configuration). This module is pure Python code and is a "
"mapping between URL path expressions to Python functions (your views)."
msgstr ""
"Для определения URL-ов приложения, создайте модуль Python, неофициально "
"названный **URLconf** (конфигурация URL-ов). Этот модуль содержит код "
"Python, который отображает URL-выражения на функции Python (ваши "
"представления)."

# 2ca36790b64b4d27a3fbcfbc53abf138
#: ../../topics/http/urls.txt:24
msgid ""
"This mapping can be as short or as long as needed. It can reference other "
"mappings. And, because it's pure Python code, it can be constructed "
"dynamically."
msgstr ""
"Эта конфигурация может быть короткой или длинной настолько, насколько это "
"нужно. Она может ссылаться на другие конфигурации. И, так как это код "
"Python, может создаваться динамически."

# c32609686aae48369aa7ed77876086ca
#: ../../topics/http/urls.txt:28
msgid ""
"Django also provides a way to translate URLs according to the active "
"language. See the :ref:`internationalization documentation <url-"
"internationalization>` for more information."
msgstr ""
"Django также предоставляет метод для перевода URL на текущий язык. "
"Обратитесь к :ref:`документации по интернационализации <url-"
"internationalization>` для подробностей."

# 824220d3e1ac4e3d82fcfde6df717952
#: ../../topics/http/urls.txt:35
msgid "How Django processes a request"
msgstr "Как Django обрабатывает запрос"

# 489d8bd0d15844c49998431831e97e90
#: ../../topics/http/urls.txt:37
msgid ""
"When a user requests a page from your Django-powered site, this is the "
"algorithm the system follows to determine which Python code to execute:"
msgstr ""
"При запросе к странице вашего Django-сайта, используется такой алгоритм для "
"определения какой код выполнить:"

# 8ced9086b21a4f25864ed385571abe9c
#: ../../topics/http/urls.txt:40
msgid ""
"Django determines the root URLconf module to use. Ordinarily, this is the "
"value of the :setting:`ROOT_URLCONF` setting, but if the incoming "
"``HttpRequest`` object has a :attr:`~django.http.HttpRequest.urlconf` "
"attribute (set by middleware), its value will be used in place of the :"
"setting:`ROOT_URLCONF` setting."
msgstr ""
"Django определяет какой корневой модуль URLconf использовать. Обычно, это "
"значение настройки :setting:`ROOT_URLCONF`, но, если объект запроса "
"``HttpRequest`` содержит атрибут :attr:`~django.http.HttpRequest.urlconf` "
"(установленный промежуточным слоем), его значение будет использоваться "
"вместо :setting:`ROOT_URLCONF`."

# 048d4ea680974eb0a9ccc9e7b1791e26
#: ../../topics/http/urls.txt:46
msgid ""
"Django loads that Python module and looks for the variable ``urlpatterns``. "
"This should be a Python list of :func:`django.urls.path` and/or :func:"
"`django.urls.re_path` instances."
msgstr ""
"Django загружает модуль конфигурации URL и ищет переменную ``urlpatterns``. "
"Это должен быть список экземпляров :func:`django.urls.path и/или :func:"
"`django.urls.re_path`."

# ad17d75eba8f4abeb8d931e0dcf08f86
#: ../../topics/http/urls.txt:50
msgid ""
"Django runs through each URL pattern, in order, and stops at the first one "
"that matches the requested URL."
msgstr ""
"Django перебирает каждый URL-шаблон по порядку, и останавливается при первом "
"совпадении с запрошенным URL-ом."

# 504bddbb80be449a86e67df32d2510a3
#: ../../topics/http/urls.txt:53
msgid ""
"Once one of the URL patterns matches, Django imports and calls the given "
"view, which is a simple Python function (or a :doc:`class-based view </"
"topics/class-based-views/index>`). The view gets passed the following "
"arguments:"
msgstr ""
"Если один из URL-шаблонов совпадает, Django импортирует и вызывает "
"соответствующее представление, которое представляет из себя обычную функцию "
"Python(или :doc:`представление-класс </topics/class-based-views/index>`). "
"При вызове передаются следующие аргументы:"

# 54a2f9104bb24fb38e211eada7f4eb76
#: ../../topics/http/urls.txt:58
msgid "An instance of :class:`~django.http.HttpRequest`."
msgstr "Экземпляр :class:`~django.http.HttpRequest`."

# fe77584f486449a0a506dc25dc24e89b
#: ../../topics/http/urls.txt:59
msgid ""
"If the matched URL pattern returned no named groups, then the matches from "
"the regular expression are provided as positional arguments."
msgstr ""
"Если совпавший шаблон URL вернул безымянные группы, то совпадения из "
"регулярного выражения передаются как позиционные аргументы."

# 871461a69b0844d2866f7a8cdb631ae8
#: ../../topics/http/urls.txt:61
msgid ""
"The keyword arguments are made up of any named parts matched by the path "
"expression, overridden by any arguments specified in the optional ``kwargs`` "
"argument to :func:`django.urls.path` or :func:`django.urls.re_path`."
msgstr ""
"Именованные аргументы создаются из именованных частей, совпавших в выражении "
"пути. Они могут быть перезаписаны значениями из опционального аргумента "
"``kwargs``, переданного в :func:`django.urls.path` или :func:`django.urls."
"re_path`."

# 49c3d738987d4b73b155913fefcacd4e
#: ../../topics/http/urls.txt:66
msgid ""
"If no URL pattern matches, or if an exception is raised during any point in "
"this process, Django invokes an appropriate error-handling view. See `Error "
"handling`_ below."
msgstr ""
"Если ни один URL-шаблон не совпал, или возникла ошибка на любом из этапов, "
"Django вызывает соответствующий обработчик ошибок. Смотрите `Error "
"handling`_ ниже."

# adf7e75d4544433d812cbce0425fd3c9
#: ../../topics/http/urls.txt:71 ../../topics/http/urls.txt:756
msgid "Example"
msgstr "Например"

# 115122f3828343838f934ed3546d20a3
#: ../../topics/http/urls.txt:73
msgid "Here's a sample URLconf::"
msgstr "Вот пример простого URLconf::"

# de11530a822643d186b5167894f4a50a
#: ../../topics/http/urls.txt:86
msgid "Notes:"
msgstr "Заметим:"

# 306dd9b944c04e6292ea7bb6ef4931ca
#: ../../topics/http/urls.txt:88
msgid "To capture a value from the URL, use angle brackets."
msgstr "Для извлечения значения из URL, используйте угловые скобки."

#: ../../topics/http/urls.txt:90
msgid ""
"Captured values can optionally include a converter type. For example, use "
"``<int:name>`` to capture an integer parameter. If a converter isn't "
"included, any string, excluding a ``/`` character, is matched."
msgstr ""
"Извлеченные значения опционально могут содержать тип конвертера. Например, "
"используйте ``<int:name>`` для извлечения целочисленного параметра. Если "
"конвертер не указан, то любая строка, кроме символа ``/``, будет считаться "
"совпавшей с шаблоном."

# 99f6e002f1b8417d82f05dffb1ba7db7
#: ../../topics/http/urls.txt:94
msgid ""
"There's no need to add a leading slash, because every URL has that. For "
"example, it's ``articles``, not ``/articles``."
msgstr ""
"Не нужно добавлять косую черту в начале, потому что каждый URL уже содержит "
"ее. Например, используйте ``articles``, вместо ``/articles``."

# 5570142fb42b42858f44f59c68288e6f
#: ../../topics/http/urls.txt:97
msgid "Example requests:"
msgstr "Примеры запросов:"

# 9de013fa45cf458abb78de966637712e
#: ../../topics/http/urls.txt:99
msgid ""
"A request to ``/articles/2005/03/`` would match the third entry in the list. "
"Django would call the function ``views.month_archive(request, year=2005, "
"month=3)``."
msgstr ""
"Запрос к ``/articles/2005/03/`` будет соответствовать третьей записи в "
"списке шаблонов. Django вызовет функцию ``views.month_archive(request, "
"year=2005, month=3)``."

# 0ddbce6f554b4546934dd09211163e45
#: ../../topics/http/urls.txt:103
msgid ""
"``/articles/2003/`` would match the first pattern in the list, not the "
"second one, because the patterns are tested in order, and the first one is "
"the first test to pass. Feel free to exploit the ordering to insert special "
"cases like this. Here, Django would call the function ``views."
"special_case_2003(request)``"
msgstr ""
"``/articles/2003/`` соответствует первой записи, не второй, потому что "
"шаблоны проверяются по порядку и берется первый найденный. Не стесняйтесь "
"использовать порядок для обработки различных ситуаций, таких как эта. В "
"данном примере Django вызовет функцию ``views.special_case_2003(request)``."

# 14d3603798ba4393a3420959eb39ffb6
#: ../../topics/http/urls.txt:109
msgid ""
"``/articles/2003`` would not match any of these patterns, because each "
"pattern requires that the URL end with a slash."
msgstr ""
"``/articles/2003`` не соответствует ни одному шаблону, потому что каждый из "
"них требует наличия символа косой черты в конце URL."

# bc2dd4603a304148814f4cc059c38519
#: ../../topics/http/urls.txt:112
msgid ""
"``/articles/2003/03/building-a-django-site/`` would match the final pattern. "
"Django would call the function ``views.article_detail(request, year=2003, "
"month=3, slug=\"building-a-django-site\")``."
msgstr ""
"``/articles/2003/03/03/`` соответствует последнему шаблону. Django вызовет "
"функцию ``views.article_detail(request, year=2003, month=3, slug=\"building-"
"a-django-site\")``."

#: ../../topics/http/urls.txt:117
msgid "Path converters"
msgstr "Конвертеры путей"

#: ../../topics/http/urls.txt:119
msgid "The following path converters are available by default:"
msgstr "По умолчанию доступны следующие конвертеры путей:"

#: ../../topics/http/urls.txt:121
msgid ""
"``str`` - Matches any non-empty string, excluding the path separator, "
"``'/'``. This is the default if a converter isn't included in the expression."
msgstr ""
"``str`` - Соответствует любой не пустой строке, за исключение разделителя "
"пути ``'/'``. Этот конвертер используется по умолчанию, даже если он явно не "
"указан в выражении."

#: ../../topics/http/urls.txt:124
msgid "``int`` - Matches zero or any positive integer. Returns an `int`."
msgstr ""
"``int`` - Соответствует нулю или положительному целому числу. Возвращает тип "
"`int`."

#: ../../topics/http/urls.txt:126
msgid ""
"``slug`` - Matches any slug string consisting of ASCII letters or numbers, "
"plus the hyphen and underscore characters. For example, ``building-your-1st-"
"django-site``."
msgstr ""
"``slug`` - Соответствует любой строке slug, состоящей из букв или цифр "
"ASCII, плюс символы дефиса и подчеркивания. Например, ``building-your-1st-"
"django-site``."

#: ../../topics/http/urls.txt:130
msgid ""
"``uuid`` - Matches a formatted UUID. To prevent multiple URLs from mapping "
"to the same page, dashes must be included and letters must be lowercase. For "
"example, ``075194d3-6885-417e-a8a8-6c931e272f00``. Returns a :class:`~uuid."
"UUID` instance."
msgstr ""
"``uuid`` - Соответствует форматированному UUID. Для предотвращения "
"отображения нескольких URL на одну страницу, должны присутствовать тире и "
"буквы должны быть строчными. Возвращает экземпляр :class:`~uuid.UUID`.\t"

#: ../../topics/http/urls.txt:135
msgid ""
"``path`` - Matches any non-empty string, including the path separator, "
"``'/'``. This allows you to match against a complete URL path rather than "
"just a segment of a URL path as with ``str``."
msgstr ""
"``path`` - Соответствует любой не пустой строке, включая разделитель пути "
"``'/'``. Позволяет получить полный URL-путь, а не только его часть, как в "
"случае со ``str``."

#: ../../topics/http/urls.txt:142
msgid "Registering custom path converters"
msgstr "Регистрация собственных конвертеров пути"

#: ../../topics/http/urls.txt:144
msgid ""
"For more complex matching requirements, you can define your own path "
"converters."
msgstr ""
"Для более сложных требований к обработке URL - вы можете определить свои "
"собственные конвертеры пути."

#: ../../topics/http/urls.txt:146
msgid "A converter is a class that includes the following:"
msgstr "Конвертер это класс, содержащий:"

#: ../../topics/http/urls.txt:148
msgid "A ``regex`` class attribute, as a string."
msgstr "Строковый атрибут класса ``regex``."

#: ../../topics/http/urls.txt:150
msgid ""
"A ``to_python(self, value)`` method, which handles converting the matched "
"string into the type that should be passed to the view function. It should "
"raise ``ValueError`` if it can't convert the given value."
msgstr ""
"Метод ``to_python(self, value)``, преобразующий совпавшую строку в тип, "
"который будет передан в представление. Если преобразование невозможно, "
"должно быть выброшено исключение ``ValueError``."

#: ../../topics/http/urls.txt:154
msgid ""
"A ``to_url(self, value)`` method, which handles converting the Python type "
"into a string to be used in the URL."
msgstr ""
"Метод ``to_url(self, value)``, преобразующий тип Python в строку, для "
"использования при построении URL."

# 0546db3de0ad4f2787bdd62427825eff
#: ../../topics/http/urls.txt:157 ../../topics/http/urls.txt:466
#: ../../topics/http/urls.txt:866
msgid "For example::"
msgstr "Например::"

#: ../../topics/http/urls.txt:168
msgid ""
"Register custom converter classes in your URLconf using :func:`~django.urls."
"register_converter`::"
msgstr ""
"Зарегистрируем собственный класс конвертера в URLconf используя :func:"
"`~django.urls.register_converter`::"

#: ../../topics/http/urls.txt:184
msgid "Using regular expressions"
msgstr "Использование регулярный выражений"

#: ../../topics/http/urls.txt:186
msgid ""
"If the paths and converters syntax isn't sufficient for defining your URL "
"patterns, you can also use regular expressions. To do so, use :func:`~django."
"urls.re_path` instead of :func:`~django.urls.path`."
msgstr ""
"Если синтаксиса путей и конвертеров недостаточно для определения ваших "
"шаблонов URL-адресов, вы также можете использовать регулярные выражения. Для "
"этого используйте :func:`~django.urls.re_path` вместо :func:`~django.urls."
"path`."

# ada1f57789b24c208dddb5045df3aa82
#: ../../topics/http/urls.txt:190
msgid ""
"In Python regular expressions, the syntax for named regular expression "
"groups is ``(?P<name>pattern)``, where ``name`` is the name of the group and "
"``pattern`` is some pattern to match."
msgstr ""
"Для регулярных выражений в Python синтаксис для именованных групп регулярных "
"выражений выглядит таким образом ``(?P<name>pattern)``, где ``name`` это "
"название группы, а ``pattern`` -- шаблон."

# f2beb7363a8d43da8d4fc1d6b0ba2e2b
#: ../../topics/http/urls.txt:194
msgid ""
"Here's the example URLconf from earlier, rewritten using regular "
"expressions::"
msgstr ""
"Это переписанный с использованием регулярный выражений пример URLconf::"

#: ../../topics/http/urls.txt:207
msgid ""
"This accomplishes roughly the same thing as the previous example, except:"
msgstr ""
"Это реализация аналогична предыдущему примеру, но имеющая следующие отличия:"

#: ../../topics/http/urls.txt:209
msgid ""
"The exact URLs that will match are slightly more constrained. For example, "
"the year 10000 will no longer match since the year integers are constrained "
"to be exactly four digits long."
msgstr ""
"Более строгие требования соответствия к URL. Например 10000 год больше не "
"попадает под соответствие, т.к. число года имеет ограничение длины в 4 цифры."

# 1dca15e4d9c54a28a2a544cd56669c02
#: ../../topics/http/urls.txt:213
msgid ""
"Each captured argument is sent to the view as a string, regardless of what "
"sort of match the regular expression makes."
msgstr ""
"Каждый найденный аргумент передается в представление как строка, независимо "
"от того, какой тип совпадения определен в регулярном выражении."

#: ../../topics/http/urls.txt:216
msgid ""
"When switching from using :func:`~django.urls.path` to :func:`~django.urls."
"re_path` or vice versa, it's particularly important to be aware that the "
"type of the view arguments may change, and so you may need to adapt your "
"views."
msgstr ""
"Когда вы переходите от использования :func:`~django.urls.path` к :func:"
"`~django.urls.re_path` и наоборот, нужно помнить, что тип передаваемых в "
"представление аргументов может измениться, и возможно представление придется "
"адаптировать."

#: ../../topics/http/urls.txt:222
msgid "Using unnamed regular expression groups"
msgstr "Использование безымянный групп регулярного выражения"

#: ../../topics/http/urls.txt:224
msgid ""
"As well as the named group syntax, e.g. ``(?P<year>[0-9]{4})``, you can also "
"use the shorter unnamed group, e.g. ``([0-9]{4})``."
msgstr ""
"По аналогии с синтаксисом именованных совпадений, например ``(?P<year>[0-9]"
"{4})``, вы можете использовать более краткую форму без указания имени "
"группы, например ``([0-9]{4})``."

#: ../../topics/http/urls.txt:227
msgid ""
"This usage isn't particularly recommended as it makes it easier to "
"accidentally introduce errors between the intended meaning of a match and "
"the arguments of the view."
msgstr ""
"Но мы рекомендуем не использовать эту форму, т.к. она способствует появлению "
"ошибок из-за несовпадения предполагаемых значений соответствия с аргументами "
"представления."

#: ../../topics/http/urls.txt:231
msgid ""
"In either case, using only one style within a given regex is recommended. "
"When both styles are mixed, any unnamed groups are ignored and only named "
"groups are passed to the view function."
msgstr ""
"В любом случае рекомендуем использовать только один стиль. Если их смешать, "
"безымянные группы будут проигнорированы и в представление будут переданы "
"только именованные."

#: ../../topics/http/urls.txt:236
msgid "Nested arguments"
msgstr "Вложенные аргументы"

#: ../../topics/http/urls.txt:238
msgid ""
"Regular expressions allow nested arguments, and Django will resolve them and "
"pass them to the view. When reversing, Django will try to fill in all outer "
"captured arguments, ignoring any nested captured arguments. Consider the "
"following URL patterns which optionally take a page argument::"
msgstr ""
"Регулярные выражения позволяют использовать вложенные аргументы, и Django "
"может их найти и передать в представление. Во время поиска аргументов Django "
"попытается получить самый внешний аргумент, игнорируя вложенные аргументы. "
"Возьмем следующие шаблоны URL-ов, которые принимает необязательный номер "
"страницы::"

#: ../../topics/http/urls.txt:250
msgid ""
"Both patterns use nested arguments and will resolve: for example, ``blog/"
"page-2/`` will result in a match to ``blog_articles`` with two positional "
"arguments: ``page-2/`` and ``2``. The second pattern for ``comments`` will "
"match ``comments/page-2/`` with keyword argument ``page_number`` set to 2. "
"The outer argument in this case is a non-capturing argument ``(?:...)``."
msgstr ""
"Оба шаблона используют вложенные аргументы и могут обрабатывать URL-ы: "
"например, для ``blog/page-2/`` будет найдено представление ``blog_articles`` "
"и передано ему два позиционных аргумента ``page-2/`` и ``2``. Второй URL-"
"шаблон для ``comments`` в ``comments/page-2/`` найдет именованный аргумент "
"``page_number`` со значеним 2. Внешний аргумент ``(?:...)`` в этом случае не "
"захватывается."

#: ../../topics/http/urls.txt:257
msgid ""
"The ``blog_articles`` view needs the outermost captured argument to be "
"reversed, ``page-2/`` or no arguments in this case, while ``comments`` can "
"be reversed with either no arguments or a value for ``page_number``."
msgstr ""
"При обратной операции (получение URL из шаблона) для представления "
"``blog_articles`` необходимо указать самый внешний аргумент ``page-2/`` или "
"ни одного аргумента, как в данном случае. В то время как для ``comments`` "
"необходимо передать значение через аргумент ``page_number`` или вообще не "
"предавать аргументы."

#: ../../topics/http/urls.txt:261
msgid ""
"Nested captured arguments create a strong coupling between the view "
"arguments and the URL as illustrated by ``blog_articles``: the view receives "
"part of the URL (``page-2/``) instead of only the value the view is "
"interested in. This coupling is even more pronounced when reversing, since "
"to reverse the view we need to pass the piece of URL instead of the page "
"number."
msgstr ""
"Вложенные захватываемые аргументы создают сильную связанность между URL и "
"аргументами представления, как это показано для ``blog_articles``: "
"представление получает часть URL-а (``page-2/``) вместо значение, которое на "
"самом деле необходимо представлению. Эта связанность особенно заметна при "
"создании URL-а т.к. необходимо передать часть URL-а вместо номера страницы."

#: ../../topics/http/urls.txt:267
msgid ""
"As a rule of thumb, only capture the values the view needs to work with and "
"use non-capturing arguments when the regular expression needs an argument "
"but the view ignores it."
msgstr ""
"Как правило, URL-шаблон должен захватывать только необходимые для "
"представления аргументы."

# b871768b0b674192abdff8df2fd80354
#: ../../topics/http/urls.txt:272
msgid "What the URLconf searches against"
msgstr "Что использует URLconf при поиске нужного шаблона URL"

# a106db71a6b54a7e98a06bdae72e30be
#: ../../topics/http/urls.txt:274
msgid ""
"The URLconf searches against the requested URL, as a normal Python string. "
"This does not include GET or POST parameters, or the domain name."
msgstr ""
"URLconf использует запрашиваемый URL как обычную строку Python. Он не "
"учитывает параметры GET, POST и имя домена."

# 127285e2224b41b3b21c38b8e80eb71f
#: ../../topics/http/urls.txt:277
msgid ""
"For example, in a request to ``https://www.example.com/myapp/``, the URLconf "
"will look for ``myapp/``."
msgstr ""
"Например, при запросе к ``https://www.example.com/myapp/``, URLconf возьмет "
"``myapp/``."

# 64a2c332cc0447838ffe0149bc36d178
#: ../../topics/http/urls.txt:280
msgid ""
"In a request to ``https://www.example.com/myapp/?page=3``, the URLconf will "
"look for ``myapp/``."
msgstr ""
"При запросе к ``https://www.example.com/myapp/?page=3`` URLconf так же "
"воспользуется только ``myapp/``."

# c2ae9a9690634379bad9ca6456a1867d
#: ../../topics/http/urls.txt:283
msgid ""
"The URLconf doesn't look at the request method. In other words, all request "
"methods -- ``POST``, ``GET``, ``HEAD``, etc. -- will be routed to the same "
"function for the same URL."
msgstr ""
"URLconf не учитывает тип запроса. Другими словами, все типы запросов -- "
"``POST``, ``GET``, ``HEAD``, и др. -- будут обработаны одним представлением "
"при одинаковом URL."

# d89d48cd2b5f4a258e0e97cbf59bd159
#: ../../topics/http/urls.txt:288
msgid "Specifying defaults for view arguments"
msgstr "Значения по умолчанию для аргументов представления"

# 65b67011e98a4fa78dcf095d1a8994d7
#: ../../topics/http/urls.txt:290
msgid ""
"A convenient trick is to specify default parameters for your views' "
"arguments. Here's an example URLconf and view::"
msgstr ""
"Принято указывать значения по-умолчанию для аргументов представления. Пример "
"URLconf и представления::"

# 5e1ede5dd84045ab96ba9cb286a46030
#: ../../topics/http/urls.txt:308
msgid ""
"In the above example, both URL patterns point to the same view -- ``views."
"page`` -- but the first pattern doesn't capture anything from the URL. If "
"the first pattern matches, the ``page()`` function will use its default "
"argument for ``num``, ``1``. If the second pattern matches, ``page()`` will "
"use whatever ``num`` value was captured."
msgstr ""
"В примере выше, оба URL-шаблона указывают на одно представление -- ``views."
"page`` -- но первый шаблон не принимает аргументы в URL. Если первый шаблон "
"будет выбран, функция ``page()`` будет использовать значение по-умолчанию "
"аргумента ``num`` равное ``\"1\"``. Если будет выбран другой шаблон, "
"``page()`` будет использовать значение ``num`` захваченное в URL."

# 858c260216d04239ae52bacc18b66925
#: ../../topics/http/urls.txt:315
msgid "Performance"
msgstr "Производительность"

# 1eb58843b8454ee6b0288af55205990e
#: ../../topics/http/urls.txt:317
msgid ""
"Each regular expression in a ``urlpatterns`` is compiled the first time it's "
"accessed. This makes the system blazingly fast."
msgstr ""
"Каждое регулярное выражение в ``urlpatterns`` будет скомпилировано при "
"первом использовании. Это делает систему невероятно быстрой."

# 261666c18648414caed8c8256b30dbf3
#: ../../topics/http/urls.txt:321
msgid "Syntax of the ``urlpatterns`` variable"
msgstr "Синтаксис переменной ``urlpatterns``"

#: ../../topics/http/urls.txt:323
msgid ""
"``urlpatterns`` should be a Python list of :func:`~django.urls.path` and/or :"
"func:`~django.urls.re_path` instances."
msgstr ""
"``urlpatterns`` должен быть списком экземпляров :func:`~django.urls.path` и/"
"или :func:`~django.urls.re_path`."

# aa77f0e182df4239a1eae76d7f84e3c1
#: ../../topics/http/urls.txt:327
msgid "Error handling"
msgstr "Обработчики ошибок"

# 6d972bd8b1be4c8e8620aa141356a654
#: ../../topics/http/urls.txt:329
msgid ""
"When Django can't find a match for the requested URL, or when an exception "
"is raised, Django invokes an error-handling view."
msgstr ""
"Если Django не может найти совпадение для запрашиваемого URL, или было "
"вызвано исключение в процессе обработки запроса, Django вызовет "
"соответствующее представление обрабатывающее ошибку."

# 0376bbf36b9b4253b9787bcb99d43212
#: ../../topics/http/urls.txt:332
msgid ""
"The views to use for these cases are specified by four variables. Their "
"default values should suffice for most projects, but further customization "
"is possible by overriding their default values."
msgstr ""
"Эти представления определены в четырёх переменных. Их значения по-умолчанию "
"должны подойти для большинства проектов, но вы можете их поменять при "
"необходимости."

# c75a6dcf875d47e993eaa2455616abd7
#: ../../topics/http/urls.txt:336
msgid ""
"See the documentation on :ref:`customizing error views <customizing-error-"
"views>` for the full details."
msgstr ""
"Подробности в разделе о :ref:`переопределении обработчика ошибок "
"<customizing-error-views>`."

# 5a1dec528982496a9ee9bfa57b78838c
#: ../../topics/http/urls.txt:339
msgid ""
"Such values can be set in your root URLconf. Setting these variables in any "
"other URLconf will have no effect."
msgstr "Эти значения должны быть определены в главном URLconf."

# 169ad2c1bed14d46b0f2f9665d7aa163
#: ../../topics/http/urls.txt:342
msgid ""
"Values must be callables, or strings representing the full Python import "
"path to the view that should be called to handle the error condition at hand."
msgstr ""
"Значение это функции, или полный путь для импорта, которая будет вызвана, "
"если не был найден подходящий URL-шаблон."

# 40b56a6070ec4f548c0a0b30579777cd
#: ../../topics/http/urls.txt:345
msgid "The variables are:"
msgstr "Есть следующие переменные:"

# 6851937bb16d449d84e15fb631ece159
#: ../../topics/http/urls.txt:347
msgid "``handler400`` -- See :data:`django.conf.urls.handler400`."
msgstr "``handler400`` -- Смотрите :data:`django.conf.urls.handler400`."

# de8ed53bc3164b73a0df7b7f7f794659
#: ../../topics/http/urls.txt:348
msgid "``handler403`` -- See :data:`django.conf.urls.handler403`."
msgstr "``handler403`` -- Смотрите :data:`django.conf.urls.handler403`."

# 6851937bb16d449d84e15fb631ece159
#: ../../topics/http/urls.txt:349
msgid "``handler404`` -- See :data:`django.conf.urls.handler404`."
msgstr "``handler404`` -- Смотрите :data:`django.conf.urls.handler404`."

# d77483eafd9040798e41560f624a2fd0
#: ../../topics/http/urls.txt:350
msgid "``handler500`` -- See :data:`django.conf.urls.handler500`."
msgstr "``handler500`` -- Смотрите :data:`django.conf.urls.handler500`."

# 6e8f5a3d7e53427a877351a6cf8687f1
#: ../../topics/http/urls.txt:355
msgid "Including other URLconfs"
msgstr "Комбинирование URLconfs"

# ce543103041c48d1b01e8aad527d3d4e
#: ../../topics/http/urls.txt:357
msgid ""
"At any point, your ``urlpatterns`` can \"include\" other URLconf modules. "
"This essentially \"roots\" a set of URLs below other ones."
msgstr ""
"В любой месте,к вашему ``urlpatterns`` подключить другие модули URLconf."

# d7f670c2106f42caada9e2db2c9d9c89
#: ../../topics/http/urls.txt:360
msgid ""
"For example, here's an excerpt of the URLconf for the `Django website`_ "
"itself. It includes a number of other URLconfs::"
msgstr ""
"Вот пример URLconf для `сайта Django <https://www.djangoproject.com/>`_. Он "
"включает множество других конфигураций URL::"

# 8b43692a7bed41fea08ee8547b80e70e
#: ../../topics/http/urls.txt:372
msgid ""
"Whenever Django encounters :func:`~django.urls.include()`, it chops off "
"whatever part of the URL matched up to that point and sends the remaining "
"string to the included URLconf for further processing."
msgstr ""
"Каждый раз, когда Django встречает:func:`~django.urls.include()`, из URL "
"вырезается уже совпавшая часть, остальное передается во включенный URLconf "
"для дальнейшей обработки."

# 0a937c37f833455ba63d013112a12b86
#: ../../topics/http/urls.txt:376
msgid ""
"Another possibility is to include additional URL patterns by using a list "
"of :func:`~django.urls.path` instances. For example, consider this URLconf::"
msgstr ""
"Другой возможностью будет добавление дополнительных URL-шаблонов с помощью "
"списка экземпляров :func:`~django.urls.path`. Например, рассмотрим такую "
"схему::"

# 25d93fa4e1ab4f4889ab72ac6b6b551d
#: ../../topics/http/urls.txt:396
msgid ""
"In this example, the ``/credit/reports/`` URL will be handled by the "
"``credit_views.report()`` Django view."
msgstr ""
"В этом примере URL ``/credit/reports/`` обработан представлением "
"``credit_views.report()``."

# 3fc7cda1ab4c4c92bd3299c582947cce
#: ../../topics/http/urls.txt:399
msgid ""
"This can be used to remove redundancy from URLconfs where a single pattern "
"prefix is used repeatedly. For example, consider this URLconf::"
msgstr ""
"Такой подход может применяться для уменьшения дублирования кода в настройках "
"URL, когда используется один и тот же шаблонный префикс. Например, возьмём "
"такую конфигурацию URL::"

# 8338d9014df64ab9988060cab919eafb
#: ../../topics/http/urls.txt:412
msgid ""
"We can improve this by stating the common path prefix only once and grouping "
"the suffixes that differ::"
msgstr ""
"Мы можем сделать её проще, указав общий префикс только один раз и "
"сгруппировав различающиеся суффиксы::"

# 92e201aaed794bb1a91e2a1968a52f2d
#: ../../topics/http/urls.txt:430
msgid "Captured parameters"
msgstr "Нахождение аргументов в URL"

# 6753ae947d4147b2a115a676350526cf
#: ../../topics/http/urls.txt:432
msgid ""
"An included URLconf receives any captured parameters from parent URLconfs, "
"so the following example is valid::"
msgstr ""
"Включенный URLconf получает все аргументы найденные родительским URLconfs, "
"поэтому этот пример работает::"

# a5b43b2d81b24fe4b3a5900323f27757
#: ../../topics/http/urls.txt:451
msgid ""
"In the above example, the captured ``\"username\"`` variable is passed to "
"the included URLconf, as expected."
msgstr ""
"В примере выше, найденный аргумент ``\"username\"`` передается во включенный "
"URLconf, как и ожидалось."

# b2b2736313c548cd8c7d76ea42dcc30a
#: ../../topics/http/urls.txt:457
msgid "Passing extra options to view functions"
msgstr "Передача дополнительных аргументов в представление"

# 78cf611a86654220aa9b88c39b766c33
#: ../../topics/http/urls.txt:459
msgid ""
"URLconfs have a hook that lets you pass extra arguments to your view "
"functions, as a Python dictionary."
msgstr ""
"Конфигурация URL-ов позволяет определить дополнительные аргументы для "
"функции представления, используя словарь Python."

# 47f8727f4995461ba83343ba2192c658
#: ../../topics/http/urls.txt:462
msgid ""
"The :func:`~django.urls.path` function can take an optional third argument "
"which should be a dictionary of extra keyword arguments to pass to the view "
"function."
msgstr ""
"Функция :func:`~django.urls.path` может принимать третий необязательный "
"элемент. Этот элемент является словарем, который определяет дополнительные "
"именованные аргументы для функции представления."

# c8a9acd499bf42b1821971de37c0eb5b
#: ../../topics/http/urls.txt:475
msgid ""
"In this example, for a request to ``/blog/2005/``, Django will call ``views."
"year_archive(request, year=2005, foo='bar')``."
msgstr ""
"В этом примере, при запросе к ``/blog/2005/``, Django вызовет ``views."
"year_archive(request, year='2005', foo='bar')``."

# 72964d0c5c084ef3b82843fe8ed45eed
#: ../../topics/http/urls.txt:478
msgid ""
"This technique is used in the :doc:`syndication framework </ref/contrib/"
"syndication>` to pass metadata and options to views."
msgstr ""
"Такой подход используется в :doc:`syndication framework </ref/contrib/"
"syndication>` для передачи параметров и дополнительных данных представление."

# dbd71437189e4eb596c49b2b93054807
#: ../../topics/http/urls.txt:482
msgid "Dealing with conflicts"
msgstr "Конфликты переменных"

# f90d4341a12d4766a0a1fed2b2ecc43c
#: ../../topics/http/urls.txt:484
msgid ""
"It's possible to have a URL pattern which captures named keyword arguments, "
"and also passes arguments with the same names in its dictionary of extra "
"arguments. When this happens, the arguments in the dictionary will be used "
"instead of the arguments captured in the URL."
msgstr ""
"Можно создать шаблон URL, который одновременно захватывает именованные "
"аргументы и при этом передает аргументы с такими же именами в словаре "
"дополнительных аргументов. В таком случае будут использованы аргументы из "
"словаря дополнительных аргументов, вместо значений из URL."

# b10f757cff594fc2bf5fa49c7225bf55
#: ../../topics/http/urls.txt:490
msgid "Passing extra options to ``include()``"
msgstr "Передача дополнительных аргументов в ``include()``"

# 3f4d4226ad30422ab0ecfd6d14f16390
#: ../../topics/http/urls.txt:492
msgid ""
"Similarly, you can pass extra options to :func:`~django.urls.include` and "
"each line in the included URLconf will be passed the extra options."
msgstr ""
"Аналогично вы можете передать дополнительные аргументы в :func:`~django.urls."
"include`. При этом, *каждый* URL-шаблон включенного URLconf будет дополнен "
"этими дополнительными аргументами."

# 42098b4ed83547cfa4cdbb3ca842ad39
#: ../../topics/http/urls.txt:495
msgid "For example, these two URLconf sets are functionally identical:"
msgstr "Например, эти два URLconf работают идентично:"

# b24a132a808043508c3ea87b077bbf68
#: ../../topics/http/urls.txt:497
msgid "Set one::"
msgstr "Первый::"

# adf681d691c346e494bcf1b04755cab8
#: ../../topics/http/urls.txt:515
msgid "Set two::"
msgstr "Второй::"

# 88f079c65c4d446eb77b1d41db891999
#: ../../topics/http/urls.txt:533
msgid ""
"Note that extra options will *always* be passed to *every* line in the "
"included URLconf, regardless of whether the line's view actually accepts "
"those options as valid. For this reason, this technique is only useful if "
"you're certain that every view in the included URLconf accepts the extra "
"options you're passing."
msgstr ""
"Дополнительные аргументы *всегда* передаются *каждому* представлению во "
"включенном URLconf, независимо от того, принимает оно эти аргументы или нет. "
"Поэтому, такой подход полезен только если вы уверенны, что каждое "
"представление принимает передаваемые аргументы."

# 6337fe6f80bc4bb99ab8e72ce69a6e48
#: ../../topics/http/urls.txt:539
msgid "Reverse resolution of URLs"
msgstr "Получение URL из шаблона"

# 36a6256db198410a8c93dc157892ffcc
#: ../../topics/http/urls.txt:541
msgid ""
"A common need when working on a Django project is the possibility to obtain "
"URLs in their final forms either for embedding in generated content (views "
"and assets URLs, URLs shown to the user, etc.) or for handling of the "
"navigation flow on the server side (redirections, etc.)"
msgstr ""
"Обычной задачей является получение URL-а по его определению в шаблоне для "
"отображения пользователю или для редиректа."

# defbbce6d1614d29afd87740463fd791
#: ../../topics/http/urls.txt:546
msgid ""
"It is strongly desirable to avoid hard-coding these URLs (a laborious, non-"
"scalable and error-prone strategy). Equally dangerous is devising ad-hoc "
"mechanisms to generate URLs that are parallel to the design described by the "
"URLconf, which can result in the production of URLs that become stale over "
"time."
msgstr ""
"Очень важно не \"хардкодить\" URL-ы (трудоемкая и плохо поддерживаемая "
"стратегия). Также не следует создавать \"костыли\" для генерации URL-ов, "
"которые не следуют задокументированному дизайну URLconf."

# a59e634e0e8f48369bc87d809fef1721
#: ../../topics/http/urls.txt:551
msgid ""
"In other words, what's needed is a DRY mechanism. Among other advantages it "
"would allow evolution of the URL design without having to go over all the "
"project source code to search and replace outdated URLs."
msgstr ""
"В общем необходимо придерживаться принципа DRY. Немаловажно иметь "
"возможность менять URL-ы в одном месте, а не выполнять поиск и замену по "
"всему проекту."

# 494fd1ff32d04500a45c972b4ae43c8e
#: ../../topics/http/urls.txt:555
msgid ""
"The primary piece of information we have available to get a URL is an "
"identification (e.g. the name) of the view in charge of handling it. Other "
"pieces of information that necessarily must participate in the lookup of the "
"right URL are the types (positional, keyword) and values of the view "
"arguments."
msgstr ""
"Для получения URL-а нам необходим его идентификатор, то есть название URL-"
"шаблона, и позиционные и именованные аргументы."

# c11fb61d089d482bb37c8af6e59b3c03
#: ../../topics/http/urls.txt:560
msgid ""
"Django provides a solution such that the URL mapper is the only repository "
"of the URL design. You feed it with your URLconf and then it can be used in "
"both directions:"
msgstr ""
"В Django для работы с URL-ами используется так называемый \"URL mapper\". "
"Ему передается URLconf, и теперь его можно использовать в обоих направлениях:"

# 0c26a4dea83b4010b06c2543cebd805d
#: ../../topics/http/urls.txt:564
msgid ""
"Starting with a URL requested by the user/browser, it calls the right Django "
"view providing any arguments it might need with their values as extracted "
"from the URL."
msgstr ""
"При получении запрошенного URL вызывает необходимое представление и "
"предоставляет все необходимые аргументы полученные из URL-а."

# e33db5084a0b41a49c16712e2a6591cc
#: ../../topics/http/urls.txt:568
msgid ""
"Starting with the identification of the corresponding Django view plus the "
"values of arguments that would be passed to it, obtain the associated URL."
msgstr ""
"При получении идентификатора представления и передаваемых ему аргументов, "
"возвращает URL."

# 245e16b169a74dc9b15d43a15d033150
#: ../../topics/http/urls.txt:571
msgid ""
"The first one is the usage we've been discussing in the previous sections. "
"The second one is what is known as *reverse resolution of URLs*, *reverse "
"URL matching*, *reverse URL lookup*, or simply *URL reversing*."
msgstr ""
"Первое это то, что мы уже рассмотрели в предыдущем разделе. Второе "
"называется *URL reversing*, в общем получение URL-а по его названию."

# 990f40827e7d46d2b4261a822be79b14
#: ../../topics/http/urls.txt:575
msgid ""
"Django provides tools for performing URL reversing that match the different "
"layers where URLs are needed:"
msgstr ""
"Django предоставляет инструменты для получения URL-ов в различных "
"компонентах фреймворка:"

# 38a637c8a05e468eb0e487219a91c429
#: ../../topics/http/urls.txt:578
msgid "In templates: Using the :ttag:`url` template tag."
msgstr "В шаблонах: Использование шаблонного тега :ttag:`url`."

# a207ad47ec2a4a0f8f222ba97b6c5c76
#: ../../topics/http/urls.txt:580
msgid "In Python code: Using the :func:`~django.urls.reverse` function."
msgstr "В Python коде: Использование функции :func:`~django.urls.reverse`."

# f9ea1b69b77d4633bf6e99746f92bac0
#: ../../topics/http/urls.txt:582
msgid ""
"In higher level code related to handling of URLs of Django model instances: "
"The :meth:`~django.db.models.Model.get_absolute_url` method."
msgstr ""
"На более высоком уровне для привязки URL-ов к моделям - метод :meth:`~django."
"db.models.Model.get_absolute_url`."

# adf7e75d4544433d812cbce0425fd3c9
#: ../../topics/http/urls.txt:586
msgid "Examples"
msgstr "Примеры"

# d3d3d263a578458ebddeb5bcb00d6d13
#: ../../topics/http/urls.txt:588
msgid "Consider again this URLconf entry::"
msgstr "Рассмотрим следующий URLconf::"

# af6e1ada257047abaa2f78bb09d12be4
#: ../../topics/http/urls.txt:600
msgid ""
"According to this design, the URL for the archive corresponding to year "
"*nnnn* is ``/articles/<nnnn>/``."
msgstr ""
"В соответствии с ним архиву *nnnn* года соответствует URL ``/articles/<nnnn>/"
"``."

# 422ceb5ee1a94f8981685c128d49e26d
#: ../../topics/http/urls.txt:603
msgid "You can obtain these in template code by using:"
msgstr "Вы можете получить его в шаблоне следующим образом:"

# c6fc742900214a89af6271e8f727ccc9
#: ../../topics/http/urls.txt:615
msgid "Or in Python code::"
msgstr "В Python коде::"

# ac994ad368e44fba9fbfa34fd0668632
#: ../../topics/http/urls.txt:626
msgid ""
"If, for some reason, it was decided that the URLs where content for yearly "
"article archives are published at should be changed then you would only need "
"to change the entry in the URLconf."
msgstr ""
"Если по каким-либо причинам необходимо будет изменить URL, достаточно будет "
"изменить запись в вашем  URLconf."

# 7ce3047c7f5c46bdaa190ccbf9549864
#: ../../topics/http/urls.txt:630
msgid ""
"In some scenarios where views are of a generic nature, a many-to-one "
"relationship might exist between URLs and views. For these cases the view "
"name isn't a good enough identifier for it when comes the time of reversing "
"URLs. Read the next section to know about the solution Django provides for "
"this."
msgstr ""
"В некоторых случаях URL-ы и представления могут соотноситься как многое-к-"
"одному. В таких случаях название представления не может идентифицировать "
"конкретный URL. Как решить эту проблему читайте в следующем разделе."

# 34cf6780279c4de9ad2c06814f1efd12
#: ../../topics/http/urls.txt:638
msgid "Naming URL patterns"
msgstr "Именованные URL-шаблоны"

# 60bac55c29c34734a8b5dd6241af5f3f
#: ../../topics/http/urls.txt:640
msgid ""
"In order to perform URL reversing, you'll need to use **named URL patterns** "
"as done in the examples above. The string used for the URL name can contain "
"any characters you like. You are not restricted to valid Python names."
msgstr ""
"Для того, чтобы выполнить обратное разрешение URL, вам потребуется "
"использовать **именованные URL шаблоны**, как это показано в примерах выше. "
"Строка, использованная для наименования URL, может содержать любые символы. "
"Вы не ограничены только теми именами, что позволяет Python."

# 14723fa60d674503b153eb1ca381d3af
#: ../../topics/http/urls.txt:644
msgid ""
"When naming URL patterns, choose names that are unlikely to clash with other "
"applications' choice of names. If you call your URL pattern ``comment`` and "
"another application does the same thing, the URL that :func:`~django.urls."
"reverse()` finds depends on whichever pattern is last in your project's "
"``urlpatterns`` list."
msgstr ""
"При выборе названия для URL-шаблона, убедитесь что оно достаточно уникально. "
"Если вы назовете URL-шаблон ``comment``, и в другом приложении поступите так "
"же, функция :func:`~django.urls.reverse()` вернет тот URL, шаблон которого "
"находится последним в списке ``urlpatterns`` вашего проекта."

# 309eff09cb8247ceb2af18bcec659976
#: ../../topics/http/urls.txt:650
msgid ""
"Putting a prefix on your URL names, perhaps derived from the application "
"name (such as ``myapp-comment`` instead of ``comment``), decreases the "
"chance of collision."
msgstr ""
"Добавление префикса к названию URL-шаблона, возможного состоящего из "
"названия приложения, уменьшит шанс конфликта. Мы советуем использовать "
"``myapp-comment`` вместо ``comment``."

#: ../../topics/http/urls.txt:654
msgid ""
"You can deliberately choose the *same URL name* as another application if "
"you want to override a view. For example, a common use case is to override "
"the :class:`~django.contrib.auth.views.LoginView`. Parts of Django and most "
"third-party apps assume that this view has a URL pattern with the name "
"``login``. If you have a custom login view and give its URL the name "
"``login``, :func:`~django.urls.reverse()` will find your custom view as long "
"as it's in ``urlpatterns`` after ``django.contrib.auth.urls`` is included "
"(if that's included at all)."
msgstr ""
"Вы можете преднамеренно выбрать *такое же имя URL*, если хотите "
"переопределить представление. Например, типичным случаем будет "
"переопределение класса :class:`~django.contrib.auth.views.LoginView`. В "
"Django и большинстве сторонних приложений предполагается, что это "
"предсавление имеет URL-шаблон с именем ``login``. Если у вас есть "
"собственное представление для входа в систему и его URL называется "
"``login``, :func:`~django.urls.reverse()` найдет ваше представление, если "
"оно находится в ``urlpatterns`` после ``django.contrib.auth.urls``(при его "
"наличии)."

#: ../../topics/http/urls.txt:663
msgid ""
"You may also use the same name for multiple URL patterns if they differ in "
"their arguments. In addition to the URL name, :func:`~django.urls.reverse()` "
"matches the number of arguments and the names of the keyword arguments."
msgstr ""
"Так же можно использовать одно имя для нескольких шаблонов URL, если они "
"отличаются друг от друга. Кроме имени :func:`~django.urls.reverse()` "
"проверяет соответствие количества аргументов, а так же имен у именованных "
"аргументов."

# 92f63802982e425a83b2ea2cf0e45444
#: ../../topics/http/urls.txt:670
msgid "URL namespaces"
msgstr "Пространства имен в конфигурации URL-ов"

# 4a3f3844f9d54525b4d0210821220045
#: ../../topics/http/urls.txt:673
msgid "Introduction"
msgstr "Описание"

# 0b22b5412b0144199f8f1b52a3c5fd77
#: ../../topics/http/urls.txt:675
msgid ""
"URL namespaces allow you to uniquely reverse :ref:`named URL patterns "
"<naming-url-patterns>` even if different applications use the same URL "
"names. It's a good practice for third-party apps to always use namespaced "
"URLs (as we did in the tutorial). Similarly, it also allows you to reverse "
"URLs if multiple instances of an application are deployed. In other words, "
"since multiple instances of a single application will share named URLs, "
"namespaces provide a way to tell these named URLs apart."
msgstr ""
"Пространства имен позволяют получить URL по :ref:`названию URL-шаблона "
"<naming-url-patterns>` даже, если несколько приложений используют одинаковые "
"названия. Для сторонних приложений использование пространств имен -- хорошая "
"практика (как мы и делаем в руководстве). Аналогично можно получить URL, "
"если несколько экземпляров одного приложения подключены в конфигурации URL-"
"ов."

# f45c9433068a418cabc807b77ba949c6
#: ../../topics/http/urls.txt:683
msgid ""
"Django applications that make proper use of URL namespacing can be deployed "
"more than once for a particular site. For example :mod:`django.contrib."
"admin` has an :class:`~django.contrib.admin.AdminSite` class which allows "
"you to easily :ref:`deploy more than one instance of the admin <multiple-"
"admin-sites>`. In a later example, we'll discuss the idea of deploying the "
"polls application from the tutorial in two different locations so we can "
"serve the same functionality to two different audiences (authors and "
"publishers)."
msgstr ""
"Django приложения, правильно используя пространство имен для URL, могут "
"использоваться в нескольких экземплярах в одном проекте. Например, :mod:"
"`django.contrib.admin` содержит класс :class:`~django.contrib.admin."
"AdminSite`, который легко позволяет :ref:`подключить несколько интерфейсов "
"администратора <multiple-admin-sites>`. Ниже мы опишем как сделать "
"аналогично для нашего приложения опросов, чтобы можно было создать несколько "
"интерфейсов (для авторов и издателей)."

# 8564d4d0edcc4355b741c81fbfee8b44
#: ../../topics/http/urls.txt:691
msgid "A URL namespace comes in two parts, both of which are strings:"
msgstr ""
"Пространство имен состоит из двух частей, каждая из которых это строка:"

# 47cabbd5e4094a26beac814978deef10
#: ../../topics/http/urls.txt:694
msgid "application namespace"
msgstr "application namespace"

# 04864b70a0ad4532a65d972beaabcee9
#: ../../topics/http/urls.txt:696
msgid ""
"This describes the name of the application that is being deployed. Every "
"instance of a single application will have the same application namespace. "
"For example, Django's admin application has the somewhat predictable "
"application namespace of ``'admin'``."
msgstr ""
"Указывает название установленного приложения. Все экземпляры одного "
"приложения будет иметь одно название. Например, название приложения "
"администратора Django -- ``admin``."

# 92f63802982e425a83b2ea2cf0e45444
#: ../../topics/http/urls.txt:700
msgid "instance namespace"
msgstr "instance namespace"

# 343b9502cdac4e0f971dec04a743cd9a
#: ../../topics/http/urls.txt:702
msgid ""
"This identifies a specific instance of an application. Instance namespaces "
"should be unique across your entire project. However, an instance namespace "
"can be the same as the application namespace. This is used to specify a "
"default instance of an application. For example, the default Django admin "
"instance has an instance namespace of ``'admin'``."
msgstr ""
"Идентифицирует конкретный экземпляр приложения. Должно быть уникальным для "
"проекта. Однако, название экземпляра может быть равным названию приложения. "
"Оно используется по-умолчанию при создании приложения. Например, "
"пространство имен приложения администратора Django -- ``admin``."

# 14ef8de1e76a40ddbaa40fc9cbc9d4f1
#: ../../topics/http/urls.txt:708
msgid ""
"Namespaced URLs are specified using the ``':'`` operator. For example, the "
"main index page of the admin application is referenced using ``'admin:"
"index'``. This indicates a namespace of ``'admin'``, and a named URL of "
"``'index'``."
msgstr ""
"Пространство имен определяется с помощью оператора ``':'``. Например, "
"главная страница интерфейса администратора определяется как ``'admin:"
"index'``. Мы видим пространство имен ``'admin'``, и название URL-шаблона "
"``'index'``."

# dd0beb185dda4037a57e82d5dc638d0d
#: ../../topics/http/urls.txt:712
msgid ""
"Namespaces can also be nested. The named URL ``'sports:polls:index'`` would "
"look for a pattern named ``'index'`` in the namespace ``'polls'`` that is "
"itself defined within the top-level namespace ``'sports'``."
msgstr ""
"Пространства имен могут быть вложенными. Название URL-а ``'sports:polls:"
"index'`` означает именованный URL-шаблон с названием ``'index'`` в "
"пространстве имен ``'polls'``, которое было определенно в другом "
"пространстве имен - ``'sports'``."

# 9be6dca660e946dc96bef98ac8b5713d
#: ../../topics/http/urls.txt:719
msgid "Reversing namespaced URLs"
msgstr "Поиск URL-а по шаблону с пространством имен"

# 83542e06d4c0423ab8f1bd4a83ef08eb
#: ../../topics/http/urls.txt:721
msgid ""
"When given a namespaced URL (e.g. ``'polls:index'``) to resolve, Django "
"splits the fully qualified name into parts and then tries the following "
"lookup:"
msgstr ""
"Если необходимо найти URL по названию с пространством имен (например, "
"``'polls:index'``), Django разбивает название на части и следует такому "
"алгоритму:"

# 8961ae51f16347ff8b70c775b996abb6
#: ../../topics/http/urls.txt:724
msgid ""
"First, Django looks for a matching :term:`application namespace` (in this "
"example, ``'polls'``). This will yield a list of instances of that "
"application."
msgstr ""
"Первым делом, Django проверяет :term:`application namespace` (например, "
"``polls``). Django получает список экземпляров приложения."

# 998245c1af554383854ef043ca51ae28
#: ../../topics/http/urls.txt:728
msgid ""
"If there is a current application defined, Django finds and returns the URL "
"resolver for that instance. The current application can be specified with "
"the ``current_app`` argument to the :func:`~django.urls.reverse()` function."
msgstr ""
"Если указан текущий экземпляр приложения, Django найдёт и вернет \"URL "
"resolver\" для этого экземпляра. Текущее приложение можно указать с помощью "
"аргумента ``current_app`` функции :func:`~django.urls.reverse()`."

#: ../../topics/http/urls.txt:733
msgid ""
"The :ttag:`url` template tag uses the namespace of the currently resolved "
"view as the current application in a :class:`~django.template."
"RequestContext`. You can override this default by setting the current "
"application on the :attr:`request.current_app <django.http.HttpRequest."
"current_app>` attribute."
msgstr ""
"Шаблонный тег :ttag:`url` использует пространство имен представления как "
"текущее приложение в :class:`~django.template.RequestContext`. Вы можете "
"переопределить его, указав в атрибуте :attr:`request.current_app <django."
"http.HttpRequest.current_app>`."

# 6c884ad3de5542f8a98cf56e9687b0d7
#: ../../topics/http/urls.txt:739
#, fuzzy
msgid ""
"If there is no current application, Django looks for a default application "
"instance. The default application instance is the instance that has an :term:"
"`instance namespace` matching the :term:`application namespace` (in this "
"example, an instance of ``polls`` called ``'polls'``)."
msgstr ""
"Если текущий экземпляр приложения не найден, Django попытается использовать "
"экземпляр по-умолчанию. Экземпляр по-умолчанию -- это экземпляр, у которого :"
"term:`instance namespace` и :term:`application namespace` совпадают (в нашем "
"примере это экземпляр ``polls`` с названием ``polls``)."

# 86ca11bff43f4a3daabeabc0a7c7e2e5
#: ../../topics/http/urls.txt:744
msgid ""
"If there is no default application instance, Django will pick the last "
"deployed instance of the application, whatever its instance name may be."
msgstr ""
"Если экземпляр по-умолчанию не найден, Django возьмет последний "
"установленный экземпляр приложения, не обращая внимание на его название."

# 2fbf1280565149daa69184349b4daa83
#: ../../topics/http/urls.txt:747
msgid ""
"If the provided namespace doesn't match an :term:`application namespace` in "
"step 1, Django will attempt a direct lookup of the namespace as an :term:"
"`instance namespace`."
msgstr ""
"Если на первом шаге не было найдено приложение по указанному пространству "
"имен, Django попытается найти экземпляр приложения по его названию, "
"используя пространство имен как название экземпляра."

# 91c5534255134861a26e4fa234a8ef6b
#: ../../topics/http/urls.txt:751
msgid ""
"If there are nested namespaces, these steps are repeated for each part of "
"the namespace until only the view name is unresolved. The view name will "
"then be resolved into a URL in the namespace that has been found."
msgstr ""
"Если пространство имен вложенное, этот процесс будет повторен, пока "
"неопределенным не останется только название представления. URL для названия "
"представления будет искаться среди URL-шаблонов определенных в приложении, "
"найденном через пространство имен."

# d2932e82a8ff4612bf131f254d4e1662
#: ../../topics/http/urls.txt:758
msgid ""
"To show this resolution strategy in action, consider an example of two "
"instances of the ``polls`` application from the tutorial: one called "
"``'author-polls'`` and one called ``'publisher-polls'``. Assume we have "
"enhanced that application so that it takes the instance namespace into "
"consideration when creating and displaying polls."
msgstr ""
"Разберем небольшой пример. У нас есть два экземпляра приложения ``polls``: "
"один назван ``'author-polls'``, другой - ``'publisher-polls'``. Предположим, "
"что мы уже изменили код приложения и оно учитывает текущее пространство имен "
"при создании страниц."

# 5f0ee97ba11b438596687a6513dc280e
#: ../../topics/http/urls.txt:788
msgid "Using this setup, the following lookups are possible:"
msgstr ""
"Для таких настроек URL-ов возможны следующие варианты поиска URL-а по "
"названию:"

# c4f1a0672065409a8b32ff890d82afec
# 28c4f462d1ee427c8f23024192015366
#: ../../topics/http/urls.txt:790
msgid ""
"If one of the instances is current - say, if we were rendering the detail "
"page in the instance ``'author-polls'`` - ``'polls:index'`` will resolve to "
"the index page of the ``'author-polls'`` instance; i.e. both of the "
"following will result in ``\"/author-polls/\"``."
msgstr ""
"Если один из экземпляров указан как текущий - например, мы выполняем шаблон "
"в экземпляре ``'author-polls'`` - поиск URL-а по ``'polls:index'`` вернет "
"URL на главную страницу экземпляра приложения ``'author-polls'``. То есть мы "
"получим ``\"/author-polls/\"`` для двух, приведенных ниже, примеров."

# a3667553394f4c88b35dfd277c668847
#: ../../topics/http/urls.txt:795
msgid "In the method of a class-based view::"
msgstr "В методе представления::"

# e1e69aa698fc491981575eb878d3e980
#: ../../topics/http/urls.txt:799
msgid "and in the template:"
msgstr "и в шаблоне:"

# cccee5e92f1c426db57088f0800e0336
#: ../../topics/http/urls.txt:805
msgid ""
"If there is no current instance - say, if we were rendering a page somewhere "
"else on the site - ``'polls:index'`` will resolve to the last registered "
"instance of ``polls``. Since there is no default instance (instance "
"namespace of ``'polls'``), the last instance of ``polls`` that is registered "
"will be used. This would be ``'publisher-polls'`` since it's declared last "
"in the ``urlpatterns``."
msgstr ""
"Если текущий экземпляр приложения не указан - например, мы ищем URL в другом "
"приложении -  поиск по ``'polls:index'`` вернет URL для последнего "
"добавленного экземпляра ``'polls'``. Т.к. у нас не определен экземпляр "
"приложения по умолчанию (с instance namespace равным ``'polls'``), будет "
"использоваться последний добавленный экземпляр ``polls``. Это будет "
"``'publisher-polls'`` т.к. он последний в ``urlpatterns``."

# 4ad351cd6e984156a65909f3aedcb529
#: ../../topics/http/urls.txt:812
msgid ""
"``'author-polls:index'`` will always resolve to the index page of the "
"instance ``'author-polls'`` (and likewise for ``'publisher-polls'``) ."
msgstr ""
"Поиск по ``'author-polls:index'`` всегда вернет ссылку на главную страницу "
"экземпляра приложения ``'author-polls'`` (аналогично и для ``'publisher-"
"polls'``)."

# 025895eadcfa4c719caf3b5e507080be
#: ../../topics/http/urls.txt:815
msgid ""
"If there were also a default instance - i.e., an instance named ``'polls'`` "
"- the only change from above would be in the case where there is no current "
"instance (the second item in the list above). In this case ``'polls:index'`` "
"would resolve to the index page of the default instance instead of the "
"instance declared last in ``urlpatterns``."
msgstr ""
"Если бы у нас был экземпляр приложения по умолчанию -- то есть с instance "
"name ``'polls'`` -- у нас бы поменялся результат только для тех случаев, где "
"не указан текущий экземпляр (второй пункт в списке выше). В этом случае для "
"``'polls:index'`` мы бы получили ссылку на главную страницу экземпляра "
"приложения по умолчанию, а не для последнего в ``urlpatterns``."

# 01957d91166c45828a3d39607c2e00f7
#: ../../topics/http/urls.txt:824
msgid "URL namespaces and included URLconfs"
msgstr "Пространства имен в URL -ах и include"

# 3e8eeb7bb3e4413faf2861a3bc111d25
#: ../../topics/http/urls.txt:826
msgid ""
"Application namespaces of included URLconfs can be specified in two ways."
msgstr "Название приложения в URLconfs можно определить двумя путями."

#: ../../topics/http/urls.txt:828
msgid ""
"Firstly, you can set an ``app_name`` attribute in the included URLconf "
"module, at the same level as the ``urlpatterns`` attribute. You have to pass "
"the actual module, or a string reference to the module, to :func:`~django."
"urls.include`, not the list of ``urlpatterns`` itself."
msgstr ""
"Первый -- вы можете указать атрибут ``app_name`` в модуле URLconf "
"приложения, на том же уровне, что и атрибут ``urlpatterns``. При этом в "
"функцию :func:`~django.urls.include` вам необходимо передать сам модуль или "
"путь к импорту модуля, а не список ``urlpatterns``."

# 1f9f3e7cb8a8476a876fb9f9957d0813
#: ../../topics/http/urls.txt:856
msgid ""
"The URLs defined in ``polls.urls`` will have an application namespace "
"``polls``."
msgstr ""
"URL-ы, определенные в ``polls.urls``, содержат название приложения ``polls``."

# 939460af658044779d58aa573dc8705b
#: ../../topics/http/urls.txt:858
msgid ""
"Secondly, you can include an object that contains embedded namespace data. "
"If you ``include()`` a list of :func:`~django.urls.path` or :func:`~django."
"urls.re_path` instances, the URLs contained in that object will be added to "
"the global namespace. However, you can also ``include()`` a 2-tuple "
"containing::"
msgstr ""
"Второй, вы можете добавить объект, который содержит все необходимые данные. "
"Если добавить через ``include()`` список :func:`~django.urls.path` или :func:"
"`~django.urls.re_path`, он будет добавлен в глобальное пространство имен. "
"Однако, в ``include()`` можно передать 2-элементный кортеж, который "
"содержит::"

# 1f9f3e7cb8a8476a876fb9f9957d0813
#: ../../topics/http/urls.txt:881
msgid ""
"This will include the nominated URL patterns into the given application "
"namespace."
msgstr ""
"Этот код добавляет URL-шаблоны, используя указанное название приложения."

#: ../../topics/http/urls.txt:884
msgid ""
"The instance namespace can be specified using the ``namespace`` argument to :"
"func:`~django.urls.include`. If the instance namespace is not specified, it "
"will default to the included URLconf's application namespace. This means it "
"will also be the default instance for that namespace."
msgstr ""
"Имя конкретного экземпляра приложения можно указать с помощью аргумента "
"``namespace`` для :func:`~django.urls.include`. Если он не указан, будет "
"использовать название приложения."

# 07d2957e806b48c1a1795e26d375d8ba
#~ msgid ""
#~ "The ``'r'`` in front of each regular expression string is optional but "
#~ "recommended. It tells Python that a string is \"raw\" -- that nothing in "
#~ "the string should be escaped. See `Dive Into Python's explanation`_."
#~ msgstr ""
#~ "Символ ``'r'`` перед каждым регулярным выражением не обязателен, но "
#~ "рекомендуется. Он указывает Python что строка \"сырая(raw)\" и ничего в "
#~ "строке не должно быть экранировано. Смотрите `Dive Into Python's "
#~ "explanation <http://www.diveintopython.net/regular_expressions/"
#~ "street_addresses.html#re.matching.2.3>`_."

# 4129a80f378a4b1c940e46888cdeda2a
#~ msgid ""
#~ "``/articles/2005/3/`` would not match any URL patterns, because the third "
#~ "entry in the list requires two digits for the month."
#~ msgstr ""
#~ "``/articles/2005/3/`` не соответствует ни одному URL-шаблону, потому что "
#~ "третья запись требует две цифры в номере месяца."

# e1197d6592724a6c92ce4a74aa6b6153
#~ msgid "Named groups"
#~ msgstr "Именованные группы"

# c7bc17c011da45cea8f9f6bf1107461d
#~ msgid ""
#~ "The above example used simple, *non-named* regular-expression groups (via "
#~ "parenthesis) to capture bits of the URL and pass them as *positional* "
#~ "arguments to a view. In more advanced usage, it's possible to use *named* "
#~ "regular-expression groups to capture URL bits and pass them as *keyword* "
#~ "arguments to a view."
#~ msgstr ""
#~ "Пример выше использует простые, *не именованные* группы совпадений в "
#~ "регулярных выражениях (то, что в скобках), чтобы получить значения из URL "
#~ "и передать в представление как *позиционные* аргументы. Но вы можете "
#~ "использовать *имена* для групп и значения будут передаваться как "
#~ "*именованные* аргументы."

# 71c17e897e514ec5847da40f9f798ebb
#~ msgid ""
#~ "This accomplishes exactly the same thing as the previous example, with "
#~ "one subtle difference: The captured values are passed to view functions "
#~ "as keyword arguments rather than positional arguments. For example:"
#~ msgstr ""
#~ "Он выполняет то же самое, что и предыдущий пример, с одним небольшим "
#~ "отличием: полученные значения передаются в представление как именованные "
#~ "аргументы, а не позиционные. Например:"

# 96355635375e4354873544e2fc43cb39
#~ msgid ""
#~ "A request to ``/articles/2005/03/`` would call the function ``views."
#~ "month_archive(request, year='2005', month='03')``, instead of ``views."
#~ "month_archive(request, '2005', '03')``."
#~ msgstr ""
#~ "Запрос к ``/articles/2005/03/`` вызовет функцию ``views."
#~ "month_archive(request, year='2005', month='03')``, вместо ``views."
#~ "month_archive(request, '2005', '03')``."

# 153391f6b3f141d18687cfa27e85c213
#~ msgid ""
#~ "A request to ``/articles/2003/03/03/`` would call the function ``views."
#~ "article_detail(request, year='2003', month='03', day='03')``."
#~ msgstr ""
#~ "Запрос к ``/articles/2003/03/03/`` вызовет ``views."
#~ "article_detail(request, year='2003', month='03', day='03')``."

# 0e081d65d6e349748164e3f0ea5a040c
#~ msgid ""
#~ "In practice, this means your URLconfs are slightly more explicit and less "
#~ "prone to argument-order bugs -- and you can reorder the arguments in your "
#~ "views' function definitions. Of course, these benefits come at the cost "
#~ "of brevity; some developers find the named-group syntax ugly and too "
#~ "verbose."
#~ msgstr ""
#~ "На практике это означает, что ваша конфигурация URL более понятна и "
#~ "меньше зависит от ошибки в порядке аргументов, также вы можете изменять "
#~ "порядок аргументов в представлении. Конечно, эти преимущества достигаются "
#~ "за счет краткости, некоторые разработчики считают именованные группы "
#~ "уродливыми и слишком многословными."

# a914fa737fae4e1483c011878abb3516
#~ msgid "The matching/grouping algorithm"
#~ msgstr "Алгоритм соответствия/группировки"

# 8a614b967feb45f79582619b2d1c423c
#~ msgid ""
#~ "Here's the algorithm the URLconf parser follows, with respect to named "
#~ "groups vs. non-named groups in a regular expression:"
#~ msgstr ""
#~ "Вот алгоритм, которому следует синтаксический анализатор конфигурации "
#~ "URL, для определения использовать значения именованных или не именованных "
#~ "совпадений:"

# 2a0423ff6c60439099242dd7bc298952
#~ msgid ""
#~ "If there are any named arguments, it will use those, ignoring non-named "
#~ "arguments."
#~ msgstr ""
#~ "Если существует именованный аргумент, он будет использован вместо "
#~ "позиционного аргумента."

# 2a0423ff6c60439099242dd7bc298952
#~ msgid ""
#~ "Otherwise, it will pass all non-named arguments as positional arguments."
#~ msgstr ""
#~ "Иначе все неименованные параметры будут переданы как позиционные "
#~ "аргументы."

# 0dd49926e3444fe9adc9ae06cd74e8a9
#~ msgid ""
#~ "In both cases, any extra keyword arguments that have been given as per "
#~ "`Passing extra options to view functions`_ (below) will also be passed to "
#~ "the view."
#~ msgstr ""
#~ "В любом случае дополнительные именованные аргументы будут переданы как "
#~ "именованные. Смотрите `Passing extra options to view functions`_ ниже."

# 92e201aaed794bb1a91e2a1968a52f2d
#~ msgid "Captured arguments are always strings"
#~ msgstr "Найденные аргументы -- всегда строки"

# 35e185e6d15c44558b68af0ca7670ccd
#, fuzzy
#~ msgid ""
#~ "...the year argument passed to views.year_archive() will be a string,"
#~ msgstr "...аргумент ``year`` для ``views.year_archive()`` будет строкой,"

# 35e185e6d15c44558b68af0ca7670ccd
#~ msgid ""
#~ "not an integer, even though the ``[0-9]{4}`` will only match integer "
#~ "strings."
#~ msgstr ""
#~ "не числом, несмотря на то, что ``[0-9]{4}`` отлавливает только числа."

#~ msgid ""
#~ "Previously, the :ttag:`url` template tag did not use the namespace of the "
#~ "currently resolved view and you had to set the ``current_app`` attribute "
#~ "on the request."
#~ msgstr ""
#~ "Ранее тег :ttag:`url` не использовал пространство имен представления и "
#~ "вам приходилось устанавливать атрибут ``current_app`` запроса."

#~ msgid ""
#~ "In previous versions, you had to specify both the application namespace "
#~ "and the instance namespace in a single place, either by passing them as "
#~ "parameters to :func:`~django.conf.urls.include` or by including a 3-tuple "
#~ "containing ``(<list of url() instances>, <application namespace>, "
#~ "<instance namespace>)``."
#~ msgstr ""
#~ "В предыдущих версиях требовалось указать название приложения и экземпляра "
#~ "приложения, передавая параметрами в :func:`~django.conf.urls.include`, "
#~ "или подключая кортеж из 3-х элементов вида  ``(<list of url() instances>, "
#~ "<application namespace>, <instance namespace>)``."

# 998245c1af554383854ef043ca51ae28
#~ msgid ""
#~ "In previous versions of Django, you had to set the ``current_app`` "
#~ "attribute on any :class:`~django.template.Context` or :class:`~django."
#~ "template.RequestContext` that is used to render a template."
#~ msgstr ""
#~ "В предыдущих версиях Django вам требовалось назначать атрибуту "
#~ "``current_app`` класс :class:`~django.template.Context` или :class:"
#~ "`~django.template.RequestContext`, который использовался при рендеринге "
#~ "шаблона."

# 225786f8ff194241a0870be14b65103b
#~ msgid ""
#~ "The current application can also be specified manually as an argument to "
#~ "the :func:`~django.core.urlresolvers.reverse` function."
#~ msgstr ""
#~ "Текущей экземпляр приложения можно также определить используя аргумент "
#~ "при вызове функции :func:`~django.core.urlresolvers.reverse`."

# b8b5d72d231144fea32a45406f3bab35
#~ msgid ""
#~ "Note that reversing in the template requires the ``current_app`` be added "
#~ "as an attribute to the ``request`` like this::"
#~ msgstr ""
#~ "Обратите внимание, поиск URL-а в шаблоне требует, чтобы мы определили "
#~ "``current_app`` для ``request`` следующим образом::"

# 41bbb924087e465ab7351becb2036397
#~ msgid ""
#~ "Firstly, you can provide the :term:`application <application namespace>` "
#~ "and :term:`instance <instance namespace>` namespaces as arguments to :"
#~ "func:`~django.conf.urls.include()` when you construct your URL patterns. "
#~ "For example,::"
#~ msgstr ""
#~ "Первый, передав названия :term:`приложения <application namespace>` и :"
#~ "term:`экземпляра <instance namespace>` аргументами в :func:`~django.conf."
#~ "urls.include()`. Например::"

# 0fcd3c782822428996639208c2087345
#~ msgid ""
#~ "For example, the Django admin is deployed as instances of :class:`~django."
#~ "contrib.admin.AdminSite`.  ``AdminSite`` objects have a ``urls`` "
#~ "attribute: A 3-tuple that contains all the patterns in the corresponding "
#~ "admin site, plus the application namespace ``'admin'``, and the name of "
#~ "the admin instance. It is this ``urls`` attribute that you ``include()`` "
#~ "into your projects ``urlpatterns`` when you deploy an admin instance."
#~ msgstr ""
#~ "Например, для подключения интерфейса администратора используется "
#~ "экземпляр :class:`~django.contrib.admin.AdminSite`, каждый из которых "
#~ "содержит свойство ``urls``: 3-х элементный кортеж, который содержит все "
#~ "URL-шаблоны, название приложения ``'admin'`` и название экземпляра "
#~ "приложения. Это то свойство, которое вы добавляете, используя "
#~ "``include()``, в  ``urlpatterns`` вашего проекта при установке приложения "
#~ "администратора."

# ca97749b5e2544caa607081aa2567335
#~ msgid ""
#~ "Be sure to pass a tuple to ``include()``. If you simply pass three "
#~ "arguments: ``include(polls_patterns, 'polls', 'author-polls')``, Django "
#~ "won't throw an error but due to the signature of ``include()``, "
#~ "``'polls'`` will be the instance namespace and ``'author-polls'`` will be "
#~ "the application namespace instead of vice versa."
#~ msgstr ""
#~ "Убедитесь, что вы передаете кортеж в ``include()``. Если вы просто "
#~ "передадите три аргумента ``include(polls_patterns, 'polls', 'author-"
#~ "polls')``, Django не вызовет исключения из-за сигнатуры ``include()``, но "
#~ "``'polls'`` будет названием экземпляра, а ``'author-polls'`` -- названием "
#~ "приложения, а не наоборот."

# 7751f0c3f99c456cbef140eb60b2d893
#~ msgid ""
#~ "``urlpatterns`` should be a Python list, in the format returned by the "
#~ "function :func:`django.conf.urls.patterns`. Always use ``patterns()`` to "
#~ "create the ``urlpatterns`` variable."
#~ msgstr ""
#~ "``urlpatterns`` должен быть списком Python, в формате, возвращаемом "
#~ "функцией :func:`django.conf.urls.patterns`. Всегда используйте "
#~ "``patterns()`` для определения переменной ``urlpatterns``."

# 6bda32b094f340e0a6550b2805342c69
#~ msgid "Passing strings instead of callable objects"
#~ msgstr "Передаем строки вместо объектов"

# 66cfee4d0bbe4e2e8878cd4d956b6e63
#~ msgid ""
#~ "It is possible to pass a string containing the path to a view rather than "
#~ "the actual Python function object. This alternative is supported for the "
#~ "time being, though is not recommended and will be removed in a future "
#~ "version of Django."
#~ msgstr ""
#~ "Вместо передачи функций, можно передавать сроку, которая содержим путь "
#~ "для импорта представления. Такой подход не рекомендуется использовать и "
#~ "будет недоступен в будущих версиях Django."

# 1ec909fc44be42fd8c817b55f0a92058
#~ msgid "For example, given this URLconf using Python function objects::"
#~ msgstr "Например, у нас есть такой URLconf, который использует функции::"

# 0547250899224766abb8a6ec5795d16e
#~ msgid ""
#~ "You can accomplish the same thing by passing strings rather than objects::"
#~ msgstr "Вы можете сделать то же самое, передавая строки вместо объектов::"

# f14d8cdd987f43beb994c0e9d96af0a5
#~ msgid ""
#~ "The following example is functionally identical. It's just a bit more "
#~ "compact because it imports the module that contains the views, rather "
#~ "than importing each view individually::"
#~ msgstr ""
#~ "Следующий пример работает аналогично. Он немного короче, потому что мы "
#~ "импортируем модуль содержащий представления, а не каждое представление по "
#~ "отдельности::"

# 21746d7468f34e1b813b9133809fdce8
#~ msgid ""
#~ "Note that :doc:`class based views</topics/class-based-views/index>` must "
#~ "be imported::"
#~ msgstr ""
#~ "Не забываем импортировать :doc:`представления-классы </topics/class-based-"
#~ "views/index>`::"

# 40b56a6070ec4f548c0a0b30579777cd
#~ msgid "The view prefix"
#~ msgstr "Префикс представления"

# 896b967fd4a243489ffbd2b847a57caf
#~ msgid ""
#~ "If you do use strings, it is possible to specify a common prefix in your "
#~ "``patterns()`` call."
#~ msgstr ""
#~ "Вы можете указать общий префикс при вызове ``patterns()``, чтобы "
#~ "сократить дублирование кода."

# ba3218fda74644599bf84d08d03847d1
#~ msgid ""
#~ "Here's an example URLconf based on the :doc:`Django overview </intro/"
#~ "overview>`::"
#~ msgstr ""
#~ "Вот пример URLconf из :doc:`примера работы с Django </intro/overview>`::"

# 24da6c6d5e0f4c0fbc2c57f1d1dfc607
#~ msgid ""
#~ "In this example, each view has a common prefix -- ``'news.views'``. "
#~ "Instead of typing that out for each entry in ``urlpatterns``, you can use "
#~ "the first argument to the ``patterns()`` function to specify a prefix to "
#~ "apply to each view function."
#~ msgstr ""
#~ "В этом пример, каждое представление содержит общий префикс -- ``'news."
#~ "views'``. Вместо того, чтобы писать его для каждой записи "
#~ "``urlpatterns``, вы можете указать его первым аргументом функции "
#~ "``patterns()``."

# c8ef7a5d95cf49ad8c69ddb3c3d1c7dd
#~ msgid "With this in mind, the above example can be written as::"
#~ msgstr "Теперь можно переписать пример выше::"

# c735e8e5c1a643d5b0233ac956d3b6fe
#~ msgid ""
#~ "Note that you don't put a trailing dot (``\".\"``) in the prefix. Django "
#~ "puts that in automatically."
#~ msgstr ""
#~ "Заметим что в конце префикса отсутствует точка (``\".\"``). Django "
#~ "самостоятельно добавит ее."

# dc4b5aa7cdee4d1b976202d3b92d1c15
#~ msgid "Multiple view prefixes"
#~ msgstr "Несколько префиксов представления"

# 642dc5193a70454cadd46a26fc6b5af9
#~ msgid ""
#~ "In practice, you'll probably end up mixing and matching views to the "
#~ "point where the views in your ``urlpatterns`` won't have a common prefix. "
#~ "However, you can still take advantage of the view prefix shortcut to "
#~ "remove duplication. Just add multiple ``patterns()`` objects together, "
#~ "like this:"
#~ msgstr ""
#~ "На практике, скорее всего представления в ``urlpatterns`` не буду "
#~ "содержать общий префикс. Однако, вы все равно можете использовать общий "
#~ "префикс, чтобы сократить дублирование кода. Просто используете несколько "
#~ "результатов вызова ``patterns()`` вместе:"

# 8517e13ed8054f0ab1d21c083a3c55bb
#~ msgid "Old::"
#~ msgstr "Раньше::"

# bd5aae80d4f142509e1581d4cc9ab103
#~ msgid "New::"
#~ msgstr "Теперь::"

# 567b930166e94022b493d2fd072033a9
#~ msgid ""
#~ "It's fairly common to use the same view function in multiple URL patterns "
#~ "in your URLconf. For example, these two URL patterns both point to the "
#~ "``archive`` view::"
#~ msgstr ""
#~ "Обычная практика использовать одно представление для нескольких URL-"
#~ "шаблонов в URLconf. Например, эти два URL-шаблона указывают на "
#~ "представление ``archive``::"

# bd7a27eef8c44d5281f5c5833026be04
#~ msgid ""
#~ "This is completely valid, but it leads to problems when you try to do "
#~ "reverse URL matching (through the :func:`~django.core.urlresolvers."
#~ "reverse` function or the :ttag:`url` template tag). Continuing this "
#~ "example, if you wanted to retrieve the URL for the ``archive`` view, "
#~ "Django's reverse URL matcher would get confused, because *two* URL "
#~ "patterns point at that view."
#~ msgstr ""
#~ "Этот пример работает, но, если вы захотите найти URL (используя  :func:"
#~ "`~django.core.urlresolvers.reverse` или тег шаблона :ttag:`url`), это "
#~ "приведет к проблемам. Если вы захотите получить URL для представления "
#~ "``archive``, Django запутается так как *два* URL-шаблона соответствуют "
#~ "одному представлению."

# 713f8edfed024beb86cb384e08a8f6e8
#~ msgid ""
#~ "To solve this problem, Django supports **named URL patterns**. That is, "
#~ "you can give a name to a URL pattern in order to distinguish it from "
#~ "other patterns using the same view and parameters. Then, you can use this "
#~ "name in reverse URL matching."
#~ msgstr ""
#~ "Для решения этой проблемы, Django предоставляет **именованные URL-"
#~ "шаблоны**. То есть, вы можете дать название для URL-шаблонов, чтобы "
#~ "отличать их и использовать эти названия при поиске нужного вам URL-а."

# 27f7c2bb6a8b4a00a0ed20b1cdb18dbb
#~ msgid "Here's the above example, rewritten to use named URL patterns::"
#~ msgstr "Перепишем пример выше с использованием именованных URL-шаблонов::"

# f13201346f2649ffb85ae2398dfe51b1
#~ msgid ""
#~ "With these names in place (``full-archive`` and ``arch-summary``), you "
#~ "can target each pattern individually by using its name:"
#~ msgstr ""
#~ "Используя эти названия (``full-archive`` и ``arch-summary``), вы можете "
#~ "обратиться к каждому URL-шаблону отдельно:"

# 4229a4eb356043b6b53585a65222b006
#~ msgid ""
#~ "Even though both URL patterns refer to the ``archive`` view here, using "
#~ "the ``name`` parameter to :func:`django.conf.urls.url` allows you to tell "
#~ "them apart in templates."
#~ msgstr ""
#~ "Хоть оба URL-шаблона ссылаются на одно представление ``archive``, "
#~ "использование параметра ``name`` в теге :func:`django.conf.urls.url` "
#~ "позволит вам различить их в шаблоне."

# b3167eb0046e483f8202f5f0a3034a6e
#~ msgid "Passing callable objects instead of strings"
#~ msgstr "Передача функций вместо строк"

# 814ce3d44967497eae0c09117bef9d13
#~ msgid ""
#~ "Some developers find it more natural to pass the actual Python function "
#~ "object rather than a string containing the path to its module. This "
#~ "alternative is supported -- you can pass any callable object as the view."
#~ msgstr ""
#~ "Некоторые разработчики предпочитают передавать функции вместо строк, "
#~ "содержащих путь для импорта. Такой способ также работает -- вы можете "
#~ "передать любой вызываемый объект в качестве представлений."

# 25a54f46992740539051d7e45c2088d2
#~ msgid "The style you use is up to you."
#~ msgstr "Стиль, который вы используете, зависит от вас."

# 31697dbff4674953a63a44bd823beae7
#~ msgid ""
#~ "Note that if you use this technique -- passing objects rather than "
#~ "strings -- the view prefix (as explained in \"The view prefix\" above) "
#~ "will have no effect."
#~ msgstr ""
#~ "Стоит заметить, что при передаче объекта вместо строки, префикс для "
#~ "представлений (описанный выше `The view prefix`_) не будет иметь никакого "
#~ "эффекта."

# 3a6abf87e6cb468086803751ef325dc5
#~ msgid ""
#~ "When you need to deploy multiple instances of a single application, it "
#~ "can be helpful to be able to differentiate between instances. This is "
#~ "especially important when using :ref:`named URL patterns <naming-url-"
#~ "patterns>`, since multiple instances of a single application will share "
#~ "named URLs. Namespaces provide a way to tell these named URLs apart."
#~ msgstr ""
#~ "Если необходимо использовать несколько экземпляров одного приложения, "
#~ "было бы удобно иметь возможность различать их. Это особенно важно при "
#~ "использовании :ref:`именованных шаблонов URL <naming-url-patterns>`, так "
#~ "как несколько экземпляров используют одинаковые названия для URL-ов. "
#~ "Пространства имен позволяют сделать эти названия уникальными."

# 85ce88d04cfd41a9bdad5af3b51d9bf7
#~ msgid ""
#~ "If there was also a default instance - i.e., an instance named "
#~ "``'myapp'`` - the following would happen:"
#~ msgstr ""
#~ "Если бы был определен экземпляр по-умолчанию - то есть, экземпляр с "
#~ "названием ``'myapp'``:"

# 5b055cb3dd4c43d2ada5fd3760104c6c
#~ msgid ""
#~ "If there is no current instance - say, if we were rendering a page "
#~ "somewhere else on the site - ``'myapp:index'`` will resolve to the index "
#~ "page of the default instance."
#~ msgstr ""
#~ "Если текущий экземпляр приложения не указан - например, мы ищем URL в "
#~ "другом приложении - поиск по ``'myapp:index'`` вернет URL на главную "
#~ "страницу экземпляра по-умолчанию."

# 6297298535fa48b8b6fa1e808b853cbc
#~ msgid ""
#~ "``'foo:index'`` will again resolve to the index page of the instance "
#~ "``'foo'``."
#~ msgstr ""
#~ "Поиск по ``'foo:index'`` все также вернет ссылку на главную страницу "
#~ "экземпляра приложения ``'foo'``."

# 875af8403096400ba182a69467ec132f
#~ msgid "Notes on capturing text in URLs"
#~ msgstr "Особенности нахождении аргументов в URL"
