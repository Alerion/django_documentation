# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated, 2013.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-11-17 10:48+0200\n"
"PO-Revision-Date: 2016-04-21 01:31+0600\n"
"Last-Translator: zavx0z <zavx0z@ya.ru>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Poedit 1.6.10\n"

# 5ec0bd06f7af46689f4fa0570b023d69
#: ../../topics/auth/customizing.txt:3
msgid "Customizing authentication in Django"
msgstr "Расширяем модуль аутентификации Django"

# a90f5369338d4281b63e29ba2f38050e
#: ../../topics/auth/customizing.txt:5
msgid ""
"The authentication that comes with Django is good enough for most common "
"cases, but you may have needs not met by the out-of-the-box defaults. To "
"customize authentication to your projects needs involves understanding what "
"points of the provided system are extensible or replaceable. This document "
"provides details about how the auth system can be customized."
msgstr ""
"Система аутентификации, входящая в состав Django, отлично подойдет для "
"решения многих типичных задач, однако Вам может не хватить функциональности "
"предоставляемой \"из коробки\". Для того что бы изменить модуль "
"аутентификации, в первую очередь необходимо разобраться какие части этой "
"системы могут быть расширены или перемещены. В этом документе мы детально "
"рассмотрим систему аутентификации."

# e5e0af4c5e384a28888b0568f4269e41
#: ../../topics/auth/customizing.txt:11
msgid ""
":ref:`Authentication backends <authentication-backends>` provide an "
"extensible system for when a username and password stored with the User "
"model need to be authenticated against a different service than Django's "
"default."
msgstr ""
":ref:`Authentication backends <authentication-backends>` предоставляет "
"расширяемую систему для аутентификации в разных сервисах, помимо "
"стандартного сервиса Django, и хранит пароль и имя пользователя в модели "
"User."

# 5584008e640c4f7ca6d09b3cfa5e13ab
#: ../../topics/auth/customizing.txt:15
msgid ""
"You can give your models :ref:`custom permissions <custom-permissions>` that "
"can be checked through Django's authorization system."
msgstr ""
"Вы можете назначить Вашим моделям собственные :ref:`права доступа <custom-"
"permissions>`, которые могут быть проверены системой аутентификации Django."

# d16de6ae94754ab9b2aecb9738288385
#: ../../topics/auth/customizing.txt:18
msgid ""
"You can :ref:`extend <extending-user>` the default User model, or :ref:"
"`substitute <auth-custom-user>` a completely customized model."
msgstr ""
"Вы можете :ref:`расширить <extending-user>` стандартную модель User, или "
"полностью :ref:`заменить <auth-custom-user>` модель."

# f056ebbb410a48a09ff73ff9e565e40e
#: ../../topics/auth/customizing.txt:24
msgid "Other authentication sources"
msgstr "Альтернативная аутентификация"

# ee9546fdc72546f290d3a086eaa944f6
#: ../../topics/auth/customizing.txt:26
msgid ""
"There may be times you have the need to hook into another authentication "
"source -- that is, another source of usernames and passwords or "
"authentication methods."
msgstr ""
"Бывают случаи когда Вам необходимо реализовать систему аутентификации "
"использующую альтернативные источники имен пользователей, паролей или "
"использующие иные методы аутентификации."

# 17edfc9b916d4fec948452e426ea5e93
#: ../../topics/auth/customizing.txt:30
msgid ""
"For example, your company may already have an LDAP setup that stores a "
"username and password for every employee. It'd be a hassle for both the "
"network administrator and the users themselves if users had separate "
"accounts in LDAP and the Django-based applications."
msgstr ""
"На пример, в Вашей компании используется система LDAP для хранения логинов и "
"паролей для каждого сотрудника.  Иметь разные аккаунты для LDAP и Django "
"приложений не очень удобно как для пользователей так и для администраторов "
"сети."

# 6d93153aa438434a905c56859d8ea67e
#: ../../topics/auth/customizing.txt:35
msgid ""
"So, to handle situations like this, the Django authentication system lets "
"you plug in other authentication sources. You can override Django's default "
"database-based scheme, or you can use the default system in tandem with "
"other systems."
msgstr ""
"В такой ситуации возможно интегрировать систему аутентификации Django с "
"другой системой аутентификации.  Вы можете переписать стандартную схему "
"Django, использующую базу данных в своей основе, или использовать базовую "
"систему совместно с другими системами."

# 17cd403e6cc9420d84af05c96efe1a38
#: ../../topics/auth/customizing.txt:40
msgid ""
"See the :ref:`authentication backend reference <authentication-backends-"
"reference>` for information on the authentication backends included with "
"Django."
msgstr ""
"Детальную информацию о системе аутентификации входящую в стандартную "
"поставку Django Вы можете найти по :ref:`ссылке <authentication-backends-"
"reference>` "

# 8c51fd65446a4d92b3d746b15695078c
#: ../../topics/auth/customizing.txt:45
msgid "Specifying authentication backends"
msgstr "Определение системы аутентификации"

# 28b746db6d1049c4b36103cf2990165e
#: ../../topics/auth/customizing.txt:47
msgid ""
"Behind the scenes, Django maintains a list of \"authentication backends\" "
"that it checks for authentication. When somebody calls :func:`django.contrib."
"auth.authenticate()` -- as described in :ref:`How to log a user in <how-to-"
"log-a-user-in>` -- Django tries authenticating across all of its "
"authentication backends. If the first authentication method fails, Django "
"tries the second one, and so on, until all backends have been attempted."
msgstr ""
"Система аутентификации Django поддерживает одновременное использование "
"разных бекэндов аутентификации или \"authentication backends\". Когда кто то "
"вызывает :func:`django.contrib.auth.authenticate()` -- в соответствии с "
"документом :ref:`Как авторизовать пользователя <how-to-log-a-user-in>` -- "
"Django пробует авторизовать пользователя используя каждый бекэнд "
"аутентификации. Если первый метод не удался, Django пробует использовать "
"второй и т.д. с каждым бекэндом в списке."

#: ../../topics/auth/customizing.txt:54
msgid ""
"The list of authentication backends to use is specified in the :setting:"
"`AUTHENTICATION_BACKENDS` setting. This should be a list of Python path "
"names that point to Python classes that know how to authenticate. These "
"classes can be anywhere on your Python path."
msgstr ""
"Список бекэндов аутентификации хранится в параметре :setting:"
"`AUTHENTICATION_BACKENDS` настроек приложения Django в виде кортежа путей к "
"классам Python'а хранящих методы аутентификации. Эти классы могут "
"располагаться где угодно в Вашей директории интерпретатора Python."

# 83023254ab044d6186a0e4e76b46c021
#: ../../topics/auth/customizing.txt:59
msgid "By default, :setting:`AUTHENTICATION_BACKENDS` is set to::"
msgstr ""
"По умолчанию, :setting:`AUTHENTICATION_BACKENDS`  устанавливается как::"

# 39a3d191a7c5468eb2e1c8ec5c9298af
#: ../../topics/auth/customizing.txt:63
msgid ""
"That's the basic authentication backend that checks the Django users "
"database and queries the built-in permissions. It does not provide "
"protection against brute force attacks via any rate limiting mechanism. You "
"may either implement your own rate limiting mechanism in a custom auth "
"backend, or use the mechanisms provided by most Web servers."
msgstr ""
"Это стандартный бекэнд аутентификации Django который проверяет пользователей "
"в базе данных и запрашивает встроенные права доступа. Этот модуль не "
"поддерживает защиту от перебора паролей путем какого-либо ограничивающего "
"механизма. Вы можете либо реализовать свой собственный механизм ограничения "
"либо использовать механизм предоставляемый многими Веб серверами."

# 376348d9a83743f48ea4e93660321c82
#: ../../topics/auth/customizing.txt:69
msgid ""
"The order of :setting:`AUTHENTICATION_BACKENDS` matters, so if the same "
"username and password is valid in multiple backends, Django will stop "
"processing at the first positive match."
msgstr ""
"Так же имеет значение в каком порядке перечислены бекэнды в :setting:"
"`AUTHENTICATION_BACKENDS`. Если логин и пароль совпадает в нескольких "
"бекэндах аутентификации, то Django остановится на первом из них."

# a668ad5f24c843ddae9f6c218798656b
#: ../../topics/auth/customizing.txt:73
msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception, authentication will immediately fail. Django won't check the "
"backends that follow."
msgstr ""
"Если какой-либо бекэнд вызовет исключение :class:`~django.core.exceptions."
"PermissionDenied` процесс аутентификации немедленно остановится. В этом "
"случае Django не будет проверять авторизацию используя бекэнды следующие "
"далее по списку."

# 6b23cccc193a4ed2a7c73dab43d508fe
#: ../../topics/auth/customizing.txt:79
msgid ""
"Once a user has authenticated, Django stores which backend was used to "
"authenticate the user in the user's session, and re-uses the same backend "
"for the duration of that session whenever access to the currently "
"authenticated user is needed. This effectively means that authentication "
"sources are cached on a per-session basis, so if you change :setting:"
"`AUTHENTICATION_BACKENDS`, you'll need to clear out session data if you need "
"to force users to re-authenticate using different methods. A simple way to "
"do that is simply to execute ``Session.objects.all().delete()``."
msgstr ""
"В случае если пользователь был успешно авторизован, Django сохранит имя "
"этого бекэнда в сессию пользователя и будет использовать тот же бекэнд "
"каждый раз когда это будет необходимо авторизованному пользователю в течении "
"длительности его сессии. Фактически это означает что источник аутентификации "
"кэшируется для каждой сессии отдельно. Поэтому при если Вы измените "
"параметр :setting:`AUTHENTICATION_BACKENDS` Вам будет необходимо очистить "
"данные в сессии и заново авторизовать пользователя. Простой путь сделать это "
"вызвать ``Session.objects.all().delete()``."

# 671ab7feee21419e953be714e89daf61
#: ../../topics/auth/customizing.txt:89
msgid "Writing an authentication backend"
msgstr "Пишем бекэнд аутентификации"

# f9f5d6985b5746af8828d36a164aae10
#: ../../topics/auth/customizing.txt:91
msgid ""
"An authentication backend is a class that implements two required methods: "
"``get_user(user_id)`` and ``authenticate(**credentials)``, as well as a set "
"of optional permission related :ref:`authorization methods "
"<authorization_methods>`."
msgstr ""
"Бекэнд аутентификации - это класс реализующий два обязательных метода: "
"``get_user(user_id)`` и ``authenticate(**credentials)``, а так же набор "
"дополнительных :ref:`методов аутентификации <authorization_methods>` для "
"проверки прав пользователя."

# 0a139829d40c457a822c16cef0b2f8b5
#: ../../topics/auth/customizing.txt:95
msgid ""
"The ``get_user`` method takes a ``user_id`` -- which could be a username, "
"database ID or whatever, but has to be the primary key of your ``User`` "
"object -- and returns a ``User`` object."
msgstr ""
"Метод ``get_user`` принимает в качестве параметра переменную ``user_id``, "
"которая может быть как именем пользователя так и ID базы данных или чем либо "
"еще, но передаваемое значение обязательно должно быть первичным ключом "
"модели ``User``, а так же метод должен возвращать объект ``User``."

# 622e4a3c44214a19a2f43d85f9349d60
#: ../../topics/auth/customizing.txt:99
msgid ""
"The ``authenticate`` method takes credentials as keyword arguments. Most of "
"the time, it'll just look like this::"
msgstr ""
"В качестве аргументов метод ``authenticate`` принимает учетные данные в виде "
"ключевых слов. Часто он будет выглядеть как показано ниже:"

# 636606df6d234b918978016d6c4bd281
#: ../../topics/auth/customizing.txt:107
msgid "But it could also authenticate a token, like so::"
msgstr ""
"Но он так же может принимать в качестве аутентификационных данных токен, как "
"в примере ниже:"

# 90055239e5d5462487d82d78428d964f
#: ../../topics/auth/customizing.txt:114
msgid ""
"Either way, ``authenticate`` should check the credentials it gets, and it "
"should return a ``User`` object that matches those credentials, if the "
"credentials are valid. If they're not valid, it should return ``None``."
msgstr ""
"В любом случае, метод ``authenticate`` должен проверить переданные ему "
"учетные данные и вернуть объект ``User`` соответствующий этим данным, в "
"случае корректности. В другом случае он должен вернуть ``None``."

#: ../../topics/auth/customizing.txt:118
msgid ""
"The Django admin is tightly coupled to the Django :ref:`User object <user-"
"objects>`. The best way to deal with this is to create a Django ``User`` "
"object for each user that exists for your backend (e.g., in your LDAP "
"directory, your external SQL database, etc.) You can either write a script "
"to do this in advance, or your ``authenticate`` method can do it the first "
"time a user logs in."
msgstr ""
"Система администрирования фреймворка тесно связана с объектом :ref:`User "
"<user-objects>` . Лучший способ создания объекта Django ``User`` для каждого "
"пользователя который существует в любом Вашем внутреннем интерфейсе "
"(например: каталог LDAP, внешняя база данных SQL, и т.д.) - это либо "
"написать скрипт, который сделает это заранее, либо создать собственный метод "
"``authenticate`` который создаст объект ``User`` когда пользователь первый "
"раз войдет в систему."

# f6f24bbbf4c24e78b2c8d67bbe199d49
#: ../../topics/auth/customizing.txt:125
msgid ""
"Here's an example backend that authenticates against a username and password "
"variable defined in your ``settings.py`` file and creates a Django ``User`` "
"object the first time a user authenticates::"
msgstr ""
"Здесь Вы можете посмотреть пример аутентификации использующий в качестве "
"логина и пароля переменные определенные в Вашем файле настроек ``settings."
"py``  и возвращает объект Django ``User`` при успешной аутентификации "
"пользователя."

# 6cf7c0d6dc6b4620bbfb6cf265610d77
#: ../../topics/auth/customizing.txt:168
msgid "Handling authorization in custom backends"
msgstr "Управление методами авторизациями"

# 599389d4f1db44febd97a46b19acaec2
#: ../../topics/auth/customizing.txt:170
msgid "Custom auth backends can provide their own permissions."
msgstr ""
"Ваши бекэнды аутентификации могут поддерживать ваши собственные методы "
"проверки прав пользователей."

# a9e9d321d8c94e4a95d7df294fbbdb41
#: ../../topics/auth/customizing.txt:172
msgid ""
"The user model will delegate permission lookup functions (:meth:`~django."
"contrib.auth.models.User.get_group_permissions()`, :meth:`~django.contrib."
"auth.models.User.get_all_permissions()`, :meth:`~django.contrib.auth.models."
"User.has_perm()`, and :meth:`~django.contrib.auth.models.User."
"has_module_perms()`) to any authentication backend that implements these "
"functions."
msgstr ""
"Если пользовательская модель содержит в себе права, поддерживающие проверку "
"функциями :meth:`~django.contrib.auth.models.User.get_group_permissions()`, :"
"meth:`~django.contrib.auth.models.User.get_all_permissions()`, :meth:"
"`~django.contrib.auth.models.User.has_perm()`, и :meth:`~django.contrib.auth."
"models.User.has_module_perms()` то проверка будет передана любому бэкенду, "
"который содержит данные методы."

# 568437b1632044d6ae37c05da09c4ffe
#: ../../topics/auth/customizing.txt:179
msgid ""
"The permissions given to the user will be the superset of all permissions "
"returned by all backends. That is, Django grants a permission to a user that "
"any one backend grants."
msgstr ""
"Все предоставленные права любым бекэндом будут сохранены для пользователя. "
"Другими словами Django сохранит права пользователя предоставленные ему любым "
"бекэндом."

#: ../../topics/auth/customizing.txt:185
msgid ""
"If a backend raises a :class:`~django.core.exceptions.PermissionDenied` "
"exception in :meth:`~django.contrib.auth.models.User.has_perm()` or :meth:"
"`~django.contrib.auth.models.User.has_module_perms()`, the authorization "
"will immediately fail and Django won't check the backends that follow."
msgstr ""
"Если бекэнд вызовет :class:`~django.core.exceptions.PermissionDenied` "
"исключение в методах :meth:`~django.contrib.auth.models.User.has_perm()` "
"или :meth:`~django.contrib.auth.models.User.has_module_perms()`, процесс "
"авторизации будет немедленно остановлен и бекэнды следующие за бекэндом "
"вызвавшим исключения вызваны не будут."

# f985f557564a4d7a81e7f0c2af23a077
#: ../../topics/auth/customizing.txt:191
msgid ""
"The simple backend above could implement permissions for the magic admin "
"fairly simply::"
msgstr ""
"Организовать проверку прав для простого бекэнда из примера выше довольно "
"просто:"

# 654b7b22963a4392b382b0641395d0e9
#: ../../topics/auth/customizing.txt:202
msgid ""
"This gives full permissions to the user granted access in the above example. "
"Notice that in addition to the same arguments given to the associated :class:"
"`django.contrib.auth.models.User` functions, the backend auth functions all "
"take the user object, which may be an anonymous user, as an argument."
msgstr ""
"Этот простой пример показывает как можно дать полный доступ пользователю. "
"Обратите внимание что помимо  передачи стандартных аргументов аналогичных "
"функций :class:`django.contrib.auth.models.User` необходимо передавать "
"объект пользователя в качестве аргумента."

# 30ff60bc4ee143848b4e407dd08529db
#: ../../topics/auth/customizing.txt:207
msgid ""
"A full authorization implementation can be found in the ``ModelBackend`` "
"class in `django/contrib/auth/backends.py`_, which is the default backend "
"and queries the ``auth_permission`` table most of the time. If you wish to "
"provide custom behavior for only part of the backend API, you can take "
"advantage of Python inheritance and subclass ``ModelBackend`` instead of "
"implementing the complete API in a custom backend."
msgstr ""
"Класс ``ModelBackend``  в файле `django/contrib/auth/backends.py`_ является "
"стандартной реализацией бекэнда авторизации и проверки прав доступа. Если Вы "
"хотите изменить отдельные функции стандартного бекэнда Вы можете реализовать "
"это с помощью наследования и субкласса ``ModelBackend`` вместо того что бы "
"переписывать бекэнд полностью."

# 201f8d055ec7430dace2eddd89e5b3d6
#: ../../topics/auth/customizing.txt:219
msgid "Authorization for anonymous users"
msgstr "Авторизация анонимного пользователя"

#: ../../topics/auth/customizing.txt:221
msgid ""
"An anonymous user is one that is not authenticated i.e. they have provided "
"no valid authentication details. However, that does not necessarily mean "
"they are not authorized to do anything. At the most basic level, most "
"websites authorize anonymous users to browse most of the site, and many "
"allow anonymous posting of comments etc."
msgstr ""
"Анонимный пользователь это тот кто не прошел процедуру аутентификации, "
"соответственно мы не имеем о нем какой-либо информации. Однако это не "
"значит, что анонимные пользователи не могут пользоваться Вашим приложением. "
"Многие сайты в сети позволяют анонимам просматривать информацию, некоторые "
"даже разрешают оставлять анонимные комментарии."

# 78278ca440a249619f67a25c0620c2b7
#: ../../topics/auth/customizing.txt:227
msgid ""
"Django's permission framework does not have a place to store permissions for "
"anonymous users. However, the user object passed to an authentication "
"backend may be an :class:`django.contrib.auth.models.AnonymousUser` object, "
"allowing the backend to specify custom authorization behavior for anonymous "
"users. This is especially useful for the authors of re-usable apps, who can "
"delegate all questions of authorization to the auth backend, rather than "
"needing settings, for example, to control anonymous access."
msgstr ""
"Фреймворк Django не хранит информацию об анонимных пользователях. Тем не "
"менее Вы можете определить поведение приложения для анонимных пользователей "
"передав в качестве аргумента объект :class:`django.contrib.auth.models."
"AnonymousUser`. Это будет особенно полезно для разработчиков приложений "
"многоразового использования. Всю работу касательно авторизации пользователей "
"можно возложить на плечи бекэнда, вместо того что бы каждый раз настраивать "
"приложение, например, для контроля доступа анонимных пользователей."

# 33cbb996040b4fc89bfaedb3728baebb
#: ../../topics/auth/customizing.txt:238
msgid "Authorization for inactive users"
msgstr "Авторизация неактивных пользователей"

# baf6645cbc0e4ad5a48e7382f87a34da
#: ../../topics/auth/customizing.txt:240
msgid ""
"An inactive user is a one that is authenticated but has its attribute "
"``is_active`` set to ``False``. However this does not mean they are not "
"authorized to do anything. For example they are allowed to activate their "
"account."
msgstr ""
"Неактивные пользователи так же могут пройти аутентификацию, но атрибут "
"``is_active`` у них установлен в ``False``. Но это не значит что они не "
"могут что-либо сделать в приложении. Например, они могут активировать свой "
"аккаунт."

# 225654e8769c4a5db9b1eeabe67610bc
#: ../../topics/auth/customizing.txt:245
msgid ""
"The support for anonymous users in the permission system allows for a "
"scenario where anonymous users have permissions to do something while "
"inactive authenticated users do not."
msgstr ""
"Поддержка анонимных пользователей в системе прав доступа позволяет "
"реализовать сценарий когда анонимный пользователь может выполнять какие-либо "
"действия в то время как неактивные авторизованные пользователи не могут "
"этого делать."

# a4553b8476ba48df822f255965edf1ad
#: ../../topics/auth/customizing.txt:249
msgid ""
"Do not forget to test for the ``is_active`` attribute of the user in your "
"own backend permission methods."
msgstr ""
"Не забывайте проверять атрибут ``is_active`` в методах проверки прав "
"пользователей Вашего бекэнда."

# c3860481df894ccabd5fe9af2c5a03b6
#: ../../topics/auth/customizing.txt:254
msgid "Handling object permissions"
msgstr "Обработка разрешений для объектов"

# c1438f0240144ef5aa43fbd2179c94fa
#: ../../topics/auth/customizing.txt:256
msgid ""
"Django's permission framework has a foundation for object permissions, "
"though there is no implementation for it in the core. That means that "
"checking for object permissions will always return ``False`` or an empty "
"list (depending on the check performed). An authentication backend will "
"receive the keyword parameters ``obj`` and ``user_obj`` for each object "
"related authorization method and can return the object level permission as "
"appropriate."
msgstr ""
"В Django механизм управления правами подготовлен для работы с правами "
"объектов, хотя и еще не реализован в ядре Фреймворка. Это означает, что "
"проверка прав объекта всегда будет возвращать False или пустой список (в "
"зависимости от вида выполняемой проверки). Бекэнд аутентификации получает "
"именованные параметры ``obj`` и ``user_obj`` для каждого объекта "
"использованного в методе авторизации и соответственно может вернуть "
"информацию о правах этого объекта."

# 9fcd36b508824c408868817f397b43ae
#: ../../topics/auth/customizing.txt:266
msgid "Custom permissions"
msgstr "Создаем пользовательские права доступа"

# 20ecf50e12844bd39fba51decae86b24
#: ../../topics/auth/customizing.txt:268
msgid ""
"To create custom permissions for a given model object, use the "
"``permissions`` :ref:`model Meta attribute <meta-options>`."
msgstr ""
"Что бы создать пользовательские права доступа для Вашей модели необходимо "
"определить их в переменной ``permissions`` :ref:`атрибуте Meta<meta-"
"options>` Вашей модели."

# 7282b04b9cac44598dcf8b2a636b8bf7
#: ../../topics/auth/customizing.txt:271
msgid ""
"This example Task model creates three custom permissions, i.e., actions "
"users can or cannot do with Task instances, specific to your application::"
msgstr ""
"В примере ниже описывается как создать пользовательские права доступа для "
"модели Task, другими словами Вы определяете что пользователь может делать в "
"Вашем приложении, а что нет:"

#: ../../topics/auth/customizing.txt:283
msgid ""
"The only thing this does is create those extra permissions when you run :"
"djadmin:`manage.py migrate <migrate>` (the function that creates permissions "
"is connected to the :data:`~django.db.models.signals.post_migrate` signal). "
"Your code is in charge of checking the value of these permissions when a "
"user is trying to access the functionality provided by the application "
"(viewing tasks, changing the status of tasks, closing tasks.) Continuing the "
"above example, the following checks if a user may view tasks::"
msgstr ""
"Новые пользовательские права будут созданы после вызова :djadmin:`manage.py "
"migrate <migrate>` (функция, которая создает права доступа подключается к :"
"data:`~django.db.models.signals.post_migrate` сигналу). Вашему приложению "
"будет необходимо проверять эти значения каждый раз когда пользователь "
"пытается получить доступ к функциям приложения (просмотр заданий, изменения "
"статуса заданий, закрытие заданий). В продолжении выше описанного примера, "
"так Вы можете проверить права пользователя для просмотра заданий::"

# 7556e3bacc294cce96aa2e70dd1f6542
#: ../../topics/auth/customizing.txt:296
msgid "Extending the existing User model"
msgstr "Расширяем модель User"

# eb2571bbb2324da2a328491c1c86ba74
#: ../../topics/auth/customizing.txt:298
msgid ""
"There are two ways to extend the default :class:`~django.contrib.auth.models."
"User` model without substituting your own model. If the changes you need are "
"purely behavioral, and don't require any change to what is stored in the "
"database, you can create a :ref:`proxy model <proxy-models>` based on :class:"
"`~django.contrib.auth.models.User`. This allows for any of the features "
"offered by proxy models including default ordering, custom managers, or "
"custom model methods."
msgstr ""
"Существует два способа расширения стандартной модели :class:`~django.contrib."
"auth.models.User` без замены модели на вашу собственную. Если Вам нужно "
"изменить только поведение модели без изменения данных Вы можете создать :ref:"
"`proxy модель <proxy-models>` на основе модели :class:`~django.contrib.auth."
"models.User`. С помощью модели proxy Вы можете добавить пользовательские "
"менеджеры или методы сохранив стандартные функции."

# 5c9b8b7a6bd84e7cb5f8337d8758926f
#: ../../topics/auth/customizing.txt:306
msgid ""
"If you wish to store information related to ``User``, you can use a :ref:"
"`one-to-one relationship <ref-onetoone>` to a model containing the fields "
"for additional information. This one-to-one model is often called a profile "
"model, as it might store non-auth related information about a site user. For "
"example you might create an Employee model::"
msgstr ""
"Если Вы хотите хранить дополнительную информацию относящуюся к модели "
"``User`` Вы можете использовать :ref:`связь один к одному <ref-onetoone>` с "
"полями модели хранящей эту информацию. Эту связанную модель часто называют "
"профайл пользователя, так как она хранит информацию не относящуюся к "
"аутентификации пользователей. Например, Вы можете создать модель Employee:"

# d65ecf8f14b349e38e7b34e6eff30c82
#: ../../topics/auth/customizing.txt:318
msgid ""
"Assuming an existing Employee Fred Smith who has both a User and Employee "
"model, you can access the related information using Django's standard "
"related model conventions::"
msgstr ""
"Если предположить что сотрудник Fred Smith имеет записи как в модели User "
"так и в модели Employee, Вы можете получить связанную информацию используя "
"стандартные соглашения Django для использования моделей::"

# 6e93b67b98494c73ae0d884aff2f686c
#: ../../topics/auth/customizing.txt:325
msgid ""
"To add a profile model's fields to the user page in the admin, define an :"
"class:`~django.contrib.admin.InlineModelAdmin` (for this example, we'll use "
"a :class:`~django.contrib.admin.StackedInline`) in your app's ``admin.py`` "
"and add it to a ``UserAdmin`` class which is registered with the :class:"
"`~django.contrib.auth.models.User` class::"
msgstr ""
"Что бы добавить поля из модели профайла в интерфейс администратора нужно "
"определить :class:`~django.contrib.admin.InlineModelAdmin` в файле ``admin."
"py`` Вашего приложения (для этого примера используется :class:`~django."
"contrib.admin.StackedInline` ), добавить его к классу ``UserAdmin`` и заново "
"зарегистрировать вместе с классом  :class:`~django.contrib.auth.models."
"User` ."

# 57bbe0bedf8d48bdb503b39b41c0d606
#: ../../topics/auth/customizing.txt:352
msgid ""
"These profile models are not special in any way - they are just Django "
"models that happen to have a one-to-one link with a User model. As such, "
"they do not get auto created when a user is created, but a :attr:`django.db."
"models.signals.post_save` could be used to create or update related models "
"as appropriate."
msgstr ""
"Модель профайл это обычная модель Django. От других моделей ее отличает "
"только наличие связи один к одному с моделью User. Как правило записи в этой "
"модели не создаются автоматически вместе с созданием пользователя, но Вы "
"можете воспользоваться методом :attr:`django.db.models.signals.post_save` "
"для создания или обновления записей в профайле по мере необходимости."

# d103270b09a94b35b939844a79ed9e1e
#: ../../topics/auth/customizing.txt:358
msgid ""
"Note that using related models results in additional queries or joins to "
"retrieve the related data, and depending on your needs substituting the User "
"model and adding the related fields may be your better option.  However "
"existing links to the default User model within your project's apps may "
"justify the extra database load."
msgstr ""
"Заметим, что использование связанных моделей приводит к увеличению запросов "
"к базе данных и дополнительной нагрузке на нее и, в зависимости от ваших "
"потребностей, замена модели User на вашу собственную модель с нужными Вам "
"полями может быть лучшим выбором."

# 5e1cf218bbc349bd9a3e3b4ab118193f
#: ../../topics/auth/customizing.txt:367
msgid "Substituting a custom User model"
msgstr "Заменяем стандартную модель User"

# 6e5c2887477443cabdeb5947773a6940
#: ../../topics/auth/customizing.txt:369
msgid ""
"Some kinds of projects may have authentication requirements for which "
"Django's built-in :class:`~django.contrib.auth.models.User` model is not "
"always appropriate. For instance, on some sites it makes more sense to use "
"an email address as your identification token instead of a username."
msgstr ""
"Для некоторых проектов возможностей встроенной в Django модели :class:"
"`~django.contrib.auth.models.User` будет недостаточно. Например, Вам "
"необходимо использовать в качестве идентификатора пользователя email адрес "
"вместо имени пользователя."

# 69e185ee6a0f4d61a3fa3014a9941c91
#: ../../topics/auth/customizing.txt:374
msgid ""
"Django allows you to override the default User model by providing a value "
"for the :setting:`AUTH_USER_MODEL` setting that references a custom model::"
msgstr ""
"Вы можете переписать стандартную модель User указав в настройках приложения :"
"setting:`AUTH_USER_MODEL` ссылка на вашу модель::"

# 519e8345beac402c8df46b18e5a54e26
#: ../../topics/auth/customizing.txt:379
msgid ""
"This dotted pair describes the name of the Django app (which must be in "
"your :setting:`INSTALLED_APPS`), and the name of the Django model that you "
"wish to use as your User model."
msgstr ""
"Эта настройка определят что для этого приложения (myapp, которое должно быть "
"прописано в :setting:`INSTALLED_APPS` ) необходимо использовать другую "
"модель (MyUser) вместо стандартной."

# 88cb4d3a0f3446f9b6a772b91f11d0e4
#: ../../topics/auth/customizing.txt:385
msgid ""
"Changing :setting:`AUTH_USER_MODEL` has a big effect on your database "
"structure. It changes the tables that are available, and it will affect the "
"construction of foreign keys and many-to-many relationships. If you intend "
"to set :setting:`AUTH_USER_MODEL`, you should set it before creating any "
"migrations or running ``manage.py migrate`` for the first time."
msgstr ""
"Изменение :setting:`AUTH_USER_MODEL` может сильно отразиться на структуре "
"Вашей базы данных. Так же это изменит доступность таблиц и отразится на "
"конструкции внешних ключей и отношение многие ко многим. Если Вы собираетесь "
"использовать альтернативную модель Вы должны указать ее в :setting:"
"`AUTH_USER_MODEL` до того как выполните какие либо миграции или первого "
"запуска ``manage.py migrate`` ."

# 331b540519f14caba211192e8fd4f3aa
#: ../../topics/auth/customizing.txt:391
msgid ""
"Changing this setting after you have tables created is not supported by :"
"djadmin:`makemigrations` and will result in you having to manually fix your "
"schema, port your data from the old user table, and possibly manually "
"reapply some migrations."
msgstr ""
"Изменение этой настройки после того как Вы уже создали ваши таблицы не "
"отразится в :djadmin:`makemigrations` и Вам нужно будет вручную править "
"схему Вашей БД, переносить данные из старой таблицы пользователей и, "
"возможно, вручную применять некоторые миграции."

# 0f8e67f670b64406b18b98ca2ac52990
#: ../../topics/auth/customizing.txt:398
msgid ""
"Due to limitations of Django's dynamic dependency feature for swappable "
"models, you must ensure that the model referenced by :setting:"
"`AUTH_USER_MODEL` is created in the first migration of its app (usually "
"called ``0001_initial``); otherwise, you will have dependency issues."
msgstr ""
"Из-за ограничений в динамических зависимостях Django Вам необходимо "
"убедиться что заменяемая модель пользователя, указанная в :setting:"
"`AUTH_USER_MODEL` была создана в Вашей первой миграции (обычно она "
"называется 0001_initial). В противном случае у вас будут проблемы с "
"зависимостями."

# 31377eea681b4826994f1224a735094c
#: ../../topics/auth/customizing.txt:403
msgid ""
"In addition, you may run into a CircularDependencyError when running your "
"migrations as Django won't be able to automatically break the dependency "
"loop due to the dynamic dependency. If you see this error, you should break "
"the loop by moving the models depended on by your User model into a second "
"migration (you can try making two normal models that have a ForeignKey to "
"each other and seeing how ``makemigrations`` resolves that circular "
"dependency if you want to see how it's usually done)"
msgstr ""
"Кроме того Вы можете столкнуться с CircularDependencyError когда запустите "
"миграцию, Django не сможет самостоятельно выйти из бесконечного цикла "
"вызванного автоматическими зависимостями. Если Вы видите эту ошибку Вам "
"необходимо определить модель ссылающуюся на старую модель User и исправить "
"это в следующей миграции. Вы можете создать две обычные модели с внешними "
"ключами ссылающимися друг на друга и, запустив ``makemigrations``, увидеть "
"что происходит когда появляются циклические зависимости."

#: ../../topics/auth/customizing.txt:0
msgid "Reusable apps and ``AUTH_USER_MODEL``"
msgstr ""

#: ../../topics/auth/customizing.txt:413
msgid ""
"Reusable apps shouldn't implement a custom user model. A project may use "
"many apps, and two reusable apps that implemented a custom user model "
"couldn't be used together. If you need to store per user information in your "
"app, use a :class:`~django.db.models.ForeignKey` or :class:`~django.db."
"models.OneToOneField` to ``settings.AUTH_USER_MODEL`` as described below."
msgstr ""

# ad8dae4d04194c59a9a0fd8bc3eb97bd
#: ../../topics/auth/customizing.txt:421
msgid "Referencing the User model"
msgstr "Ссылка на модель User"

# 813e9db1f7484e16adee27304e40e0b5
#: ../../topics/auth/customizing.txt:425
msgid ""
"If you reference :class:`~django.contrib.auth.models.User` directly (for "
"example, by referring to it in a foreign key), your code will not work in "
"projects where the :setting:`AUTH_USER_MODEL` setting has been changed to a "
"different User model."
msgstr ""
"Если Вы ссылаетесь на модель :class:`~django.contrib.auth.models.User` "
"напрямую (например используя внешние ключи), Ваш код не будет работать в "
"проектах где стандартная модель заменена на другую в настройке :setting:"
"`AUTH_USER_MODEL`."

# 2c54437ee8a445ff929050ce283ba902
#: ../../topics/auth/customizing.txt:432
msgid ""
"Instead of referring to :class:`~django.contrib.auth.models.User` directly, "
"you should reference the user model using ``django.contrib.auth."
"get_user_model()``. This method will return the currently active User model "
"-- the custom User model if one is specified, or :class:`~django.contrib."
"auth.models.User` otherwise."
msgstr ""
"Вместо того что бы ссылаться на модель :class:`~django.contrib.auth.models."
"User` напрямую, Вы должны делать это используя метод ``django.contrib.auth."
"get_user_model()``. Этот метод возвращает действующею модель -- указанную в "
"настройках приложении или стандартную модель :class:`~django.contrib.auth."
"models.User`, в случае если не изменялась."

# 233be4509bae4067b93692459d7ba477
#: ../../topics/auth/customizing.txt:438
msgid ""
"When you define a foreign key or many-to-many relations to the User model, "
"you should specify the custom model using the :setting:`AUTH_USER_MODEL` "
"setting. For example::"
msgstr ""
"Когда Вы определяете в Вашей модели пользователей внешние ключи или "
"отношения многие ко многим Вы должны указывать параметр :setting:"
"`AUTH_USER_MODEL` . Например::"

#: ../../topics/auth/customizing.txt:451
msgid ""
"When connecting to signals sent by the ``User`` model, you should specify "
"the custom model using the :setting:`AUTH_USER_MODEL` setting. For example::"
msgstr ""
"Когда Вы подключаете отсылку сигналов моделью пользователей Вы должны "
"указать параметр :setting:`AUTH_USER_MODEL`. Например:"

# fd2b020c92a74b14aaebb37b5e66d2d7
#: ../../topics/auth/customizing.txt:462
msgid ""
"Generally speaking, you should reference the User model with the :setting:"
"`AUTH_USER_MODEL` setting in code that is executed at import time. "
"``get_user_model()`` only works once Django has imported all models."
msgstr ""
"Другими словами Вы всегда должны ссылаться на пользовательскую модель "
"используя настройку :setting:`AUTH_USER_MODEL` в Вашем коде которая будет "
"проверяться во время импорта. ``get_user_model()`` работает только один раз, "
"когда Django импортирует модели."

# 3762aaf1d15c47bfa9f0db67b258e8af
#: ../../topics/auth/customizing.txt:469
msgid "Specifying a custom User model"
msgstr "Определение пользовательской модели"

# 45ec0dc8c1314162b7b8b847acd628e1
#: ../../topics/auth/customizing.txt:0
msgid "Model design considerations"
msgstr "Разработка пользовательской модели"

# b07acbf1e9324851b473306d1ecd0536
#: ../../topics/auth/customizing.txt:473
msgid ""
"Think carefully before handling information not directly related to "
"authentication in your custom User Model."
msgstr ""
"Тщательно подумайте прежде чем хранить в пользовательской модели информацию "
"не относящуюся к аутентификации пользователя."

# a5d470a2037f4295ad363e46847be06f
#: ../../topics/auth/customizing.txt:476
msgid ""
"It may be better to store app-specific user information in a model that has "
"a relation with the User model. That allows each app to specify its own user "
"data requirements without risking conflicts with other apps. On the other "
"hand, queries to retrieve this related information will involve a database "
"join, which may have an effect on performance."
msgstr ""
"Может быть лучше хранить дополнительную информацию о пользователях "
"необходимые вашему приложению в другой модели с указанием связи на модель "
"User. Это позволит каждому приложению определять специфичную только для него "
"информацию без риска возникновения конфликтов с другими приложениями. Но с "
"другой стороны такой подход приведет к увеличению запросов к базе данных а "
"следовательно и нагрузки на нее."

# ad7153fa53394a069777c77b1bdc92f1
#: ../../topics/auth/customizing.txt:482
msgid ""
"Django expects your custom User model to meet some minimum requirements."
msgstr ""
"Django ожидает что Ваша модель User будет отвечать некоторым минимальным "
"рекомендациям."

#: ../../topics/auth/customizing.txt:484
msgid ""
"If you use the default authentication backend, then your model must have a "
"single unique field that can be used for identification purposes. This can "
"be a username, an email address, or any other unique attribute. A non-unique "
"username field is allowed if you use a custom authentication backend that "
"can support it."
msgstr ""

# 0a269a9798fd40f4ad8aa830df53d043
#: ../../topics/auth/customizing.txt:490
msgid ""
"Your model must provide a way to address the user in a \"short\" and \"long"
"\" form. The most common interpretation of this would be to use the user's "
"given name as the \"short\" identifier, and the user's full name as the "
"\"long\" identifier. However, there are no constraints on what these two "
"methods return - if you want, they can return exactly the same value."
msgstr ""
"Ваша модель должна поддерживать короткую \"short\" и длинную \"long\" форму "
"обращения к пользователю. В наиболее общей интерпретации этого можно "
"использовать имя пользователя как \"короткий\" идентификатор, а его полное "
"имя как \"длинный\" идентификатор. Однако ни кто не мешает Вам сделать так "
"что бы этих методы возвращали одно и тоже значение."

#: ../../topics/auth/customizing.txt:499
msgid ""
"Older versions of Django required your model to have an integer primary key "
"as well."
msgstr ""

# 904e1b078f6f4220aced801e26509c66
#: ../../topics/auth/customizing.txt:502
msgid ""
"The easiest way to construct a compliant custom User model is to inherit "
"from :class:`~django.contrib.auth.models.AbstractBaseUser`. :class:`~django."
"contrib.auth.models.AbstractBaseUser` provides the core implementation of a "
"``User`` model, including hashed passwords and tokenized password resets. "
"You must then provide some key implementation details:"
msgstr ""
"Простейший способ построить модель совместимую с моделью User это "
"наследовать модель :class:`~django.contrib.auth.models.AbstractBaseUser`. :"
"class:`~django.contrib.auth.models.AbstractBaseUser` обеспечивает базовую "
"реализацию модели User, в том числе хеширование паролей и сброс пароля "
"посредством токенов."

#: ../../topics/auth/customizing.txt:514
msgid ""
"A string describing the name of the field on the User model that is used as "
"the unique identifier. This will usually be a username of some kind, but it "
"can also be an email address, or any other unique identifier. The field "
"*must* be unique (i.e., have ``unique=True`` set in its definition), unless "
"you use a custom authentication backend that can support non-unique "
"usernames."
msgstr ""
"Строка, указывающая имя поля модели User, которая используется в качестве "
"уникального идентификатора. Это, как правило, имя пользователя в некотором "
"виде, но также может и адресом электронной почты, или любой другой "
"уникальный идентификатор. Поле должно быть уникальным (т.е. unique=True), "
"если Вы не используете пользовательский бэкенд аутентификации, который может "
"поддерживать не уникальные имена пользователей."

# fcc69f52a8d041c7a9503d06fb513502
#: ../../topics/auth/customizing.txt:521
msgid ""
"In the following example, the field ``identifier`` is used as the "
"identifying field::"
msgstr ""
"В примере ниже поле ``identifier`` используется в качестве уникального "
"идентификатора::"

#: ../../topics/auth/customizing.txt:531
msgid ""
":attr:`USERNAME_FIELD` now supports :class:`~django.db.models.ForeignKey`"
"\\s. Since there is no way to pass model instances during the :djadmin:"
"`createsuperuser` prompt, expect the user to enter the value of :attr:"
"`~django.db.models.ForeignKey.to_field` value (the :attr:`~django.db.models."
"Field.primary_key` by default) of an existing instance."
msgstr ""
"Атрибут :attr:`USERNAME_FIELD` теперь поддерживает внешние ключи :class:"
"`~django.db.models.ForeignKey`\\s. Так как при создании суперюзера через :"
"djadmin:`createsuperuser` из командной строки не существует способа передать "
"экземпляр соответствующей модели, то ожидается, что пользователь введёт "
"значение для :attr:`~django.db.models.ForeignKey.to_field` (по умолчанию "
"первичный ключ :attr:`~django.db.models.Field.primary_key` ) существующего "
"экземпляра."

#: ../../topics/auth/customizing.txt:540
msgid ""
"A list of the field names that will be prompted for when creating a user via "
"the :djadmin:`createsuperuser` management command. The user will be prompted "
"to supply a value for each of these fields. It must include any field for "
"which :attr:`~django.db.models.Field.blank` is ``False`` or undefined and "
"may include additional fields you want prompted for when a user is created "
"interactively. ``REQUIRED_FIELDS`` has no effect in other parts of Django, "
"like creating a user in the admin."
msgstr ""
"Список имен полей, которые будут запрашиваться при создании пользователя с "
"использованием команды :djadmin:`createsuperuser`. Пользователю будет "
"предложено задать значение для каждого из этих полей. Этот список должен "
"содержать имена всех полей для которых атрибут blank установлен False и поля "
"для которых этот атрибут не определен, а так же любые другие поля какие Вы "
"захотите. Изменение параметра ``REQUIRED_FIELDS`` ни как не отразится на "
"остальных частях Фреймворка Django, таких как создание пользователя через "
"панель администратора."

# 0dc922a0f91545438b8f6170a72f5b1c
#: ../../topics/auth/customizing.txt:549
msgid ""
"For example, here is the partial definition for a ``User`` model that "
"defines two required fields - a date of birth and height::"
msgstr ""
"Пример ниже показывает как можно задать два обязательных поля --дата "
"рождения и рост:"

# 84288d96abf548b096b0c85f6ecf6ffc
#: ../../topics/auth/customizing.txt:561
msgid ""
"``REQUIRED_FIELDS`` must contain all required fields on your ``User`` model, "
"but should *not* contain the ``USERNAME_FIELD`` or ``password`` as these "
"fields will always be prompted for."
msgstr ""
"В атрибуте ``REQUIRED_FIELDS`` Вы можете задать любые обязательные поля "
"Вашей модели ``User`` кроме ``USERNAME_FIELD`` и ``password``. Эти поля "
"являются обязательными по умолчанию."

#: ../../topics/auth/customizing.txt:567
msgid ""
":attr:`REQUIRED_FIELDS` now supports :class:`~django.db.models.ForeignKey`"
"\\s. Since there is no way to pass model instances during the :djadmin:"
"`createsuperuser` prompt, expect the user to enter the value of :attr:"
"`~django.db.models.ForeignKey.to_field` value (the :attr:`~django.db.models."
"Field.primary_key` by default) of an existing instance."
msgstr ""
"Атрибут ``REQUIRED_FIELDS`` теперь поддерживает внешние ключи :class:"
"`~django.db.models.ForeignKey`\\s. Так как при создании суперюзера через :"
"djadmin:`createsuperuser` из командной строки не существует способа передать "
"экземпляр соответствующей модели, то ожидается, что пользователь введёт "
"значение для :attr:`~django.db.models.ForeignKey.to_field` (по умолчанию "
"первичный ключ :attr:`~django.db.models.Field.primary_key` ) существующего "
"экземпляра."

# 89c8b06e27974c5eb46a86cde8661c98
#: ../../topics/auth/customizing.txt:576
msgid ""
"A boolean attribute that indicates whether the user is considered \"active"
"\".  This attribute is provided as an attribute on ``AbstractBaseUser`` "
"defaulting to ``True``. How you choose to implement it will depend on the "
"details of your chosen auth backends. See the documentation of the :attr:"
"`is_active attribute on the built-in user model <django.contrib.auth.models."
"User.is_active>` for details."
msgstr ""
"Логический атрибут, указывающий является ли пользователь \"активным\". По "
"умолчанию класс ``AbstractBaseUser`` устанавливает его в ``True``.  Вы "
"можете изменить это в Вашем бекэнде аутентификации. Для подробностей смотри "
"документ :attr:`атрибут is_active во встроенной модели ``User``<django."
"contrib.auth.models.User.is_active>`"

# e98f6146206c4e358f8360cf978d3fe8
#: ../../topics/auth/customizing.txt:585
msgid ""
"A longer formal identifier for the user. A common interpretation would be "
"the full name of the user, but it can be any string that identifies the user."
msgstr ""
"\"Длинная\" форма формального идентификатора пользователя. В общем случае "
"должна возвращать полное имя пользователя, но может так же возвращать любую "
"строку однозначно идентифицирующую пользователя."

# 7ea944340e414547adb58536aaa890fb
#: ../../topics/auth/customizing.txt:591
msgid ""
"A short, informal identifier for the user. A common interpretation would be "
"the first name of the user, but it can be any string that identifies the "
"user in an informal way. It may also return the same value as :meth:`django."
"contrib.auth.models.User.get_full_name()`."
msgstr ""
"\"Короткая\" форма не формальной идентификации пользователя. В общем случае "
"должна возвращать имя пользователя. Но так же может возвращать любую строку "
"однозначно идентифицирующую пользователя. Может возвращать такое же значение "
"что и :meth:`django.contrib.auth.models.User.get_full_name()`."

#: ../../topics/auth/customizing.txt:0
msgid "Importing ``AbstractBaseUser``"
msgstr ""

#: ../../topics/auth/customizing.txt:600
msgid ""
"``AbstractBaseUser`` and ``BaseUserManager`` are importable from ``django."
"contrib.auth.base_user`` so that they can be imported without including "
"``django.contrib.auth`` in :setting:`INSTALLED_APPS` (this raised a "
"deprecation warning in older versions and is no longer supported in Django "
"1.9)."
msgstr ""

# cd022a86211546c2927f81c447e72198
#: ../../topics/auth/customizing.txt:606
msgid ""
"The following methods are available on any subclass of :class:`~django."
"contrib.auth.models.AbstractBaseUser`:"
msgstr ""
"Следующие методы доступны из любого класса наследующего :class:`~django."
"contrib.auth.models.AbstractBaseUser`:"

# 9f31b17dfce44100bba07471966f941b
#: ../../topics/auth/customizing.txt:613
msgid "Returns the value of the field nominated by ``USERNAME_FIELD``."
msgstr "Возвращает значение из поля указанного в качестве ``USERNAME_FIELD``."

# 707ca33fcf83468a87cdd66794ec1404
#: ../../topics/auth/customizing.txt:617
msgid ""
"Always returns ``False``. This is a way of differentiating from  :class:"
"`~django.contrib.auth.models.AnonymousUser` objects. Generally, you should "
"prefer using :meth:`~django.contrib.auth.models.AbstractBaseUser."
"is_authenticated()` to this method."
msgstr ""
"Всегда возвращает ``False``. Это способ дифференцировать от объектов :class:"
"`~django.contrib.auth.models.AnonymousUser`. Обычно предпочтительнее "
"использовать :meth:`~django.contrib.auth.models.AbstractBaseUser."
"is_authenticated()` метод."

# 9616f410cb424ba9b5845b5beb4e193a
#: ../../topics/auth/customizing.txt:625
msgid ""
"Always returns ``True``. This is a way to tell if the user has been "
"authenticated. This does not imply any permissions, and doesn't check if the "
"user is active - it only indicates that the user has provided a valid "
"username and password."
msgstr ""
"Всегда возвращает ``True``. Это способ определить был ли пользователь "
"идентифицирован. Метод не подразумевает проверку прав доступа или статус "
"активности пользователя. Он только указывает что пользователь ввел "
"правильные имя пользователя и пароль."

# dd445814ddd346378a548adcfcdcb96a
#: ../../topics/auth/customizing.txt:632
msgid ""
"Sets the user's password to the given raw string, taking care of the "
"password hashing. Doesn't save the :class:`~django.contrib.auth.models."
"AbstractBaseUser` object."
msgstr ""
"Меняет пароль пользователя на переданный в параметре предварительно "
"хэшировав его. Объект :class:`~django.contrib.auth.models.AbstractBaseUser` "
"не сохраняется."

# 9fdfe846f54d4fcbb6422a6763c7578d
#: ../../topics/auth/customizing.txt:636
msgid ""
"When the raw_password is ``None``, the password will be set to an unusable "
"password, as if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` were used."
msgstr ""
"Если используется метод :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` и ``raw_password`` равен ``None`` пользователь "
"будет помечен как не использующий пароль."

# f6a25c9b78cf4db88a150df4da042b32
#: ../../topics/auth/customizing.txt:643
msgid ""
"Returns ``True`` if the given raw string is the correct password for the "
"user. (This takes care of the password hashing in making the comparison.)"
msgstr ""
"Возвращает ``True`` если пароль указан верно (вычисляет хэш и сравнивает его "
"с хэшем хранимым в базе данных)."

# be6465ec0b374a3fbe4fd9f6d599b89d
#: ../../topics/auth/customizing.txt:649
msgid ""
"Marks the user as having no password set.  This isn't the same as having a "
"blank string for a password. :meth:`~django.contrib.auth.models."
"AbstractBaseUser.check_password()` for this user will never return ``True``. "
"Doesn't save the :class:`~django.contrib.auth.models.AbstractBaseUser` "
"object."
msgstr ""
"Помечает пользователя как не использующего пароля. Но это не тоже самое что "
"указывать пустую строку в качестве пароля. Если установлено, то метод :meth:"
"`~django.contrib.auth.models.AbstractBaseUser.check_password()` никогда не "
"вернет ``True``. Объект :class:`~django.contrib.auth.models."
"AbstractBaseUser` не сохраняется."

# bd690ab3f8ec4ceeba86225e382ad20c
#: ../../topics/auth/customizing.txt:655
msgid ""
"You may need this if authentication for your application takes place against "
"an existing external source such as an LDAP directory."
msgstr ""
"Вам может это понадобиться если Вы используете внешний источник данных для "
"аутентификации, например, директорию LDAP."

# 796785bbe49f456ca1d0ffb31d1f40f7
#: ../../topics/auth/customizing.txt:660
msgid ""
"Returns ``False`` if :meth:`~django.contrib.auth.models.AbstractBaseUser."
"set_unusable_password()` has been called for this user."
msgstr ""
"Вернет ``False`` если для пользователя был вызван метод :meth:`~django."
"contrib.auth.models.AbstractBaseUser.set_unusable_password()`."

# 0ad167949f0646b4be22f0be2c0fbdf6
#: ../../topics/auth/customizing.txt:666
msgid ""
"Returns an HMAC of the password field. Used for :ref:`session-invalidation-"
"on-password-change`."
msgstr ""
"Вернет HMAC (хэш) пароля. Используется для :ref:`переопределения сессии "
"после смены пароля <session-invalidation-on-password-change>`."

# 60e492c932e643c78ec795bbdd160054
#: ../../topics/auth/customizing.txt:669
msgid ""
"You should also define a custom manager for your ``User`` model. If your "
"``User`` model defines ``username``, ``email``, ``is_staff``, ``is_active``, "
"``is_superuser``, ``last_login``, and ``date_joined`` fields the same as "
"Django's default ``User``, you can just install Django's :class:`~django."
"contrib.auth.models.UserManager`; however, if your ``User`` model defines "
"different fields, you will need to define a custom manager that extends :"
"class:`~django.contrib.auth.models.BaseUserManager` providing two additional "
"methods:"
msgstr ""
"Вам так же необходимо определить собственный менеджер пользователей Вашей "
"модели ``User``. Если Ваша модель ``User`` определяет поля ``username``, "
"``email``, ``is_staff``, ``is_active``, ``is_superuser``, ``last_login`` и "
"``date_joined`` так же как и в стандартной модели ``User`` Вы можете "
"использовать стандартный :class:`~django.contrib.auth.models.UserManager` "
"Django. Однако, если Вы определили другие поля в пользовательской модели, то "
"Вам необходим собственный менеджер пользователей который будет унаследован "
"от :class:`~django.contrib.auth.models.BaseUserManager` и определять два "
"обязательных метода:"

# 6b112742fdb7412fb4240505fcf8c98d
#: ../../topics/auth/customizing.txt:682
msgid ""
"The prototype of ``create_user()`` should accept the username field, plus "
"all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_user`` should be defined as::"
msgstr ""
"Метод ``create_user()`` должен принимать в качестве параметров имя "
"пользователя плюс другие обязательные поля. Например, если Ваша модель "
"пользователей использует ``email`` в качестве логина с обязательным "
"указанием даты рождения то Ваш метод ``create_user`` должен быть определен "
"как::"

# 56fa50d7fcb74245a524d32336c6c03a
#: ../../topics/auth/customizing.txt:693
msgid ""
"The prototype of ``create_superuser()`` should accept the username field, "
"plus all required fields as arguments. For example, if your user model uses "
"``email`` as the username field, and has ``date_of_birth`` as a required "
"field, then ``create_superuser`` should be defined as::"
msgstr ""
"Метод ``create_superuser()`` должен принимать в качестве параметров имя "
"пользователя плюс другие обязательные поля. Например, если Ваша модель "
"пользователей использует ``email`` в качестве логина с обязательным "
"указанием даты рождения то Ваш метод ``create_superuser()`` должен быть "
"определен как::"

# 7a90ab1049e24007b6a5430a6d6739e0
#: ../../topics/auth/customizing.txt:702
msgid ""
"Unlike ``create_user()``, ``create_superuser()`` *must* require the caller "
"to provide a password."
msgstr ""
"В отличие от ``create_user()``,  ``create_superuser()`` должен обязательно "
"требовать пароль."

# 408d28a741634411a1ceb60fd9b43845
#: ../../topics/auth/customizing.txt:705
msgid ""
":class:`~django.contrib.auth.models.BaseUserManager` provides the following "
"utility methods:"
msgstr ""
":class:`~django.contrib.auth.models.BaseUserManager` предоставляет следующие "
"методы:"

# 9ddb89ee8587417b912948701868a93f
#: ../../topics/auth/customizing.txt:712
msgid ""
"A ``classmethod`` that normalizes email addresses by lowercasing the domain "
"portion of the email address."
msgstr ""
"Это ``classmethod`` который используется для нормализации электронного "
"адреса путем преобразования доменного имени в нижний регистр."

# 5ff291a1de9e44af82126869677a612e
#: ../../topics/auth/customizing.txt:717
msgid ""
"Retrieves a user instance using the contents of the field nominated by "
"``USERNAME_FIELD``."
msgstr ""
"Получает экземпляр пользователя, используя содержимое поля, указанного в "
"``USERNAME_FIELD``."

# 5cf3c7191d774f11b0153a9fef5991e9
#: ../../topics/auth/customizing.txt:722
msgid ""
"Returns a random password with the given length and given string of allowed "
"characters. Note that the default value of ``allowed_chars`` doesn't contain "
"letters that can cause user confusion, including:"
msgstr ""
"Возвращает случайно сгенерированный пароль указанной длины и набора "
"символов. Обратите внимание, что стандартная строка ``allowed_chars`` не "
"содержит символов которые могут ввести пользователя в заблуждение, включая:"

# 3731bb5a184945bf9289e55c01fa376e
#: ../../topics/auth/customizing.txt:726
msgid ""
"``i``, ``l``, ``I``, and ``1`` (lowercase letter i, lowercase letter L, "
"uppercase letter i, and the number one)"
msgstr ""
"``i``, ``l``, ``I``, и ``1`` (строчная буква i, строчная буква L,прописная "
"буква i и цифра один)"

# ac08d505c146401faf94c9c183fd0287
#: ../../topics/auth/customizing.txt:728
msgid ""
"``o``, ``O``, and ``0`` (lowercase letter o, uppercase letter o, and zero)"
msgstr "``o``, ``O``, и ``0`` (строчная бука о, прописная буква о и ноль)"

# d0cc327fed794dd0a6a390da253fde7b
#: ../../topics/auth/customizing.txt:732
msgid "Extending Django's default User"
msgstr "Расширяем встроенную модель User"

# 63626680094846cdaf79034b8d341061
#: ../../topics/auth/customizing.txt:734
msgid ""
"If you're entirely happy with Django's :class:`~django.contrib.auth.models."
"User` model and you just want to add some additional profile information, "
"you could simply subclass ``django.contrib.auth.models.AbstractUser`` and "
"add your custom profile fields, although we'd recommend a separate model as "
"described in the \"Model design considerations\" note of :ref:`specifying-"
"custom-user-model`. ``AbstractUser`` provides the full implementation of the "
"default :class:`~django.contrib.auth.models.User` as an :ref:`abstract model "
"<abstract-base-classes>`."
msgstr ""
"Если вас полностью удовлетворяет встроенная модель :class:`~django.contrib."
"auth.models.User` и нужно только добавить хранение дополнительной информации "
"о пользователе, Вы можете просто расширить модель ``django.contrib.auth."
"models.AbstractUser`` и добавить дополнительные поля, хотя мы рекомендуем "
"создать отдельную модель в соответствии с заметкой \"Разработка "
"пользовательской модели\". ``AbstractUser`` полностью реализует стандартную "
"модель :class:`~django.contrib.auth.models.User`."

# 757515f54ea1438cb54dd39ba31948c5
#: ../../topics/auth/customizing.txt:746
msgid "Custom users and the built-in auth forms"
msgstr "Встроенные формы авторизации"

# c41928d682af4ab6a3db65002b84b3a3
#: ../../topics/auth/customizing.txt:748
msgid ""
"As you may expect, built-in Django's :ref:`forms <built-in-auth-forms>` and :"
"ref:`views <built-in-auth-views>` make certain assumptions about the user "
"model that they are working with."
msgstr ""
"Встроенные в Django :ref:`формы <built-in-auth-forms>` и :ref:`представления "
"<built-in-auth-views>` делают определенные предположения о модели ``User`` с "
"которой они работают."

# f827696ea1a341d6a4ee2f59bd1447b0
#: ../../topics/auth/customizing.txt:752
msgid ""
"If your user model doesn't follow the same assumptions, it may be necessary "
"to define a replacement form, and pass that form in as part of the "
"configuration of the auth views."
msgstr ""
"Если Ваша пользовательская модель не следует тем же предположениям, Вам, "
"возможно, придется определить новую форму и передать ее в виде части "
"конфигурации представления авторизации."

# 103f1905f71744f29f7345e2fd240188
#: ../../topics/auth/customizing.txt:756
msgid ":class:`~django.contrib.auth.forms.UserCreationForm`"
msgstr ":class:`~django.contrib.auth.forms.UserCreationForm`"

# 88d432581ca04609966ceeb666b32441
# 35dc6886a26b4badb9eba33e4dc7f59b
#: ../../topics/auth/customizing.txt:758 ../../topics/auth/customizing.txt:763
msgid ""
"Depends on the :class:`~django.contrib.auth.models.User` model. Must be re-"
"written for any custom user model."
msgstr ""
"Зависит от :class:`~django.contrib.auth.models.User` модели. Должен быть "
"переписан для любой новой пользовательской модели."

# 833c2b1ec40b47a3b97c64425dd2d42b
#: ../../topics/auth/customizing.txt:761
msgid ":class:`~django.contrib.auth.forms.UserChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.UserChangeForm`"

# d9edd7a5ac154a3ab6c40aa5a5a7a726
#: ../../topics/auth/customizing.txt:766
msgid ":class:`~django.contrib.auth.forms.AuthenticationForm`"
msgstr ":class:`~django.contrib.auth.forms.AuthenticationForm`"

# 4631bdc4e57e4ec5acb6392d0bee0f29
#: ../../topics/auth/customizing.txt:768
msgid ""
"Works with any subclass of :class:`~django.contrib.auth.models."
"AbstractBaseUser`, and will adapt to use the field defined in "
"``USERNAME_FIELD``."
msgstr ""
"Работает с любым классом унаследованным от :class:`~django.contrib.auth."
"models.AbstractBaseUser` и должна быть адаптирована для использования поля "
"определенного в ``USERNAME_FIELD``."

# 110741093cd7475fbb7235cc53d9a13a
#: ../../topics/auth/customizing.txt:771
msgid ":class:`~django.contrib.auth.forms.PasswordResetForm`"
msgstr ":class:`~django.contrib.auth.forms.PasswordResetForm`"

#: ../../topics/auth/customizing.txt:773
msgid ""
"Assumes that the user model has a field named ``email`` that can be used to "
"identify the user and a boolean field named ``is_active`` to prevent "
"password resets for inactive users."
msgstr ""
"Предполагается что модель пользователя имеет поле с именем ``email``, "
"которое может быть использовано для идентификации пользователя и поле "
"``is_active`` хранящее булево значение для предотвращения сброса пароля для "
"неактивных пользователей."

# 548825e5354c45c9a590c1bfd947b600
#: ../../topics/auth/customizing.txt:777
msgid ":class:`~django.contrib.auth.forms.SetPasswordForm`"
msgstr ":class:`~django.contrib.auth.forms.SetPasswordForm`"

# 3eaab38c13df46e9a15e2816d1926e02
# 11e2349b004c42eb8c125991e3721df2
# 0854b13b0fbd41dfaf88ca178abe38e7
#: ../../topics/auth/customizing.txt:779 ../../topics/auth/customizing.txt:783
#: ../../topics/auth/customizing.txt:787
msgid ""
"Works with any subclass of :class:`~django.contrib.auth.models."
"AbstractBaseUser`"
msgstr ""
"Работает с любым классом унаследованным от :class:`~django.contrib.auth."
"models.AbstractBaseUser`"

# af86245c1215499bb0aa69bc04a63a5e
#: ../../topics/auth/customizing.txt:781
msgid ":class:`~django.contrib.auth.forms.PasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.PasswordChangeForm`"

# c6405c8424404a44a2e37c0862d25d2c
#: ../../topics/auth/customizing.txt:785
msgid ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"
msgstr ":class:`~django.contrib.auth.forms.AdminPasswordChangeForm`"

# 6a219b59f463415aa5709386d82009c0
#: ../../topics/auth/customizing.txt:791
msgid "Custom users and :mod:`django.contrib.admin`"
msgstr "Пользовательская модель и :mod:`django.contrib.admin`"

# 7749b18a757a4e5faeae1f61337f7706
#: ../../topics/auth/customizing.txt:793
msgid ""
"If you want your custom User model to also work with Admin, your User model "
"must define some additional attributes and methods. These methods allow the "
"admin to control access of the User to admin content:"
msgstr ""
"Если Вы хотите что бы Ваша пользовательская модель так же работала с "
"административным интерфейсом она должна определять некоторые обязательные "
"атрибуты и методы. Эти методы позволяют админ модулю контролировать доступ "
"пользователей к админской части приложения:"

# c3fdd99220ad4f2ebed867f916bef1dc
#: ../../topics/auth/customizing.txt:801
msgid ""
"Returns ``True`` if the user is allowed to have access to the admin site."
msgstr "Возвращает ``True`` если пользователю разрешен доступ к админ сайту."

# e75428947c9f4eb7858ad9b7372e900f
#: ../../topics/auth/customizing.txt:805
msgid "Returns ``True`` if the user account is currently active."
msgstr "Возвращает ``True`` если пользователь активен."

# 3c8cb81e149447a1a8c85c488db77e2d
#: ../../topics/auth/customizing.txt:809
msgid ""
"Returns ``True`` if the user has the named permission. If ``obj`` is "
"provided, the permission needs to be checked against a specific object "
"instance."
msgstr ""
"Возвращает ``True`` если пользователь имеет указанное разрешение. Если "
"``obj`` поддерживается, разрешение должно быть проверено в отношении "
"конкретного экземпляра объекта."

# fb63950e7c274194aef7b0b41cc5fbdf
#: ../../topics/auth/customizing.txt:815
msgid ""
"Returns ``True`` if the user has permission to access models in the given "
"app."
msgstr ""
"Возвращает ``True`` если пользователь имеет доступ к модели указанного "
"приложения."

# 39641d068824477c955a59766fae7d48
#: ../../topics/auth/customizing.txt:818
msgid ""
"You will also need to register your custom User model with the admin. If "
"your custom User model extends ``django.contrib.auth.models.AbstractUser``, "
"you can use Django's existing ``django.contrib.auth.admin.UserAdmin`` class. "
"However, if your User model extends :class:`~django.contrib.auth.models."
"AbstractBaseUser`, you'll need to define a custom ``ModelAdmin`` class. It "
"may be possible to subclass the default ``django.contrib.auth.admin."
"UserAdmin``; however, you'll need to override any of the definitions that "
"refer to fields on ``django.contrib.auth.models.AbstractUser`` that aren't "
"on your custom User class."
msgstr ""
"Вам так же надо зарегистрировать вашу пользовательскую модель для админ "
"модуля. Если Ваша модель наследуется от ``django.contrib.auth.models."
"AbstractUser`` , Вы можете использовать ``django.contrib.auth.admin."
"UserAdmin`` класс Django. Однако, если Вы наследуете :class:`~django.contrib."
"auth.models.AbstractBaseUser` класс, Вам необходимо определить "
"пользовательский класс ``ModelAdmin``.  Для этого Вы можете наследовать "
"стандартный класс ``django.contrib.auth.admin.UserAdmin`` и переопределить "
"все ссылки на поля в ``django.contrib.auth.models.AbstractUser`` в "
"соответствии со структурой Вашей модели."

# 380333cb6d5546ffbf5af3acf33a8dd0
#: ../../topics/auth/customizing.txt:830
msgid "Custom users and permissions"
msgstr "Пользовательские права доступа"

# 7f14c8514f5243d0a6597d7275f55aea
#: ../../topics/auth/customizing.txt:832
msgid ""
"To make it easy to include Django's permission framework into your own User "
"class, Django provides :class:`~django.contrib.auth.models."
"PermissionsMixin`. This is an abstract model you can include in the class "
"hierarchy for your User model, giving you all the methods and database "
"fields necessary to support Django's permission model."
msgstr ""
"Что бы упростить подключения системы прав доступа Фреймворка в Вашем "
"пользовательском классе Django имеется класс :class:`~django.contrib.auth."
"models.PermissionsMixin`. Это абстрактная модель, которую Вы можете включить "
"в иерархию классов Вашей пользовательской модели, предоставляющей Вам доступ "
"ко всем методам и полям базы данных, необходимых для работы модуля прав "
"доступа."

# c145e8df4a804d43ab6553e0bd875b0a
#: ../../topics/auth/customizing.txt:838
msgid ""
":class:`~django.contrib.auth.models.PermissionsMixin` provides the following "
"methods and attributes:"
msgstr ""
":class:`~django.contrib.auth.models.PermissionsMixin`  предоставляют "
"следующие методы и атрибуты:"

# 378dc57e66ec48f19ded31f54975ec90
#: ../../topics/auth/customizing.txt:845
msgid ""
"Boolean. Designates that this user has all permissions without explicitly "
"assigning them."
msgstr ""
"Булев тип. Указывает что пользователь имеет все права без их явного "
"назначения."

# 7a11ff8ca06f48938dadba472a7f5bed
#: ../../topics/auth/customizing.txt:850
msgid ""
"Returns a set of permission strings that the user has, through their groups."
msgstr "Возвращает набор прав доступа групп в которых состоит пользователь."

# f00a4e69fefa44a58f42fa1ed91fcd8d
#: ../../topics/auth/customizing.txt:853
msgid ""
"If ``obj`` is passed in, only returns the group permissions for this "
"specific object."
msgstr ""
"Если передается ``obj`` возвращает групповые права доступа только для "
"указанного объекта."

# ef838cf5459643728e57f0f1c8ec6c4b
#: ../../topics/auth/customizing.txt:858
msgid ""
"Returns a set of permission strings that the user has, both through group "
"and user permissions."
msgstr "Возвращает набор как групповых так и индивидуальных прав доступа."

# 8068857ffaa843718c4ee863663caf81
#: ../../topics/auth/customizing.txt:861
msgid ""
"If ``obj`` is passed in, only returns the permissions for this specific "
"object."
msgstr ""
"Если передается ``obj`` возвращает персональные права доступа только для "
"указанного объекта."

# 8162b07c6fc5475e916cd9f6a5b88c10
#: ../../topics/auth/customizing.txt:866
msgid ""
"Returns ``True`` if the user has the specified permission, where ``perm`` is "
"in the format ``\"<app label>.<permission codename>\"`` (see :ref:"
"`permissions <topic-authorization>`). If the user is inactive, this method "
"will always return ``False``."
msgstr ""
"Возвращает ``True`` если пользователь имеет указанные права доступа. "
"``perm`` указывается в формате ``\"<app label>.<permission codename>\"`` "
"(для подробностей смотри документ -- :ref:`права доступа <topic-"
"authorization>`). Если пользователь не активен будет всегда возвращать "
"``False``."

# 06c823c09d514abebf5dcd82cd4e8b66
#: ../../topics/auth/customizing.txt:871
msgid ""
"If ``obj`` is passed in, this method won't check for a permission for the "
"model, but for this specific object."
msgstr ""
"Если передан ``obj``, этот метод проверит права доступа только для "
"указанного объекта."

# 284d1d5141c144858676db417b75d91a
#: ../../topics/auth/customizing.txt:876
msgid ""
"Returns ``True`` if the user has each of the specified permissions, where "
"each perm is in the format ``\"<app label>.<permission codename>\"``. If the "
"user is inactive, this method will always return ``False``."
msgstr ""
"Возвращает ``True`` если пользователь имеет все перечисленные права доступа "
"переданные в формате ``\"<app label>.<permission codename>\"``. Если "
"пользователь не активен метод вернет ``False``."

# 7148e7e6f0354829aa8078ffea398a76
#: ../../topics/auth/customizing.txt:881
msgid ""
"If ``obj`` is passed in, this method won't check for permissions for the "
"model, but for the specific object."
msgstr ""
"Если передан ``obj``, этот метод проверит права доступа только для "
"указанного объекта."

# 7b275d4d9dee4f61b629ea93fc8546a2
#: ../../topics/auth/customizing.txt:886
msgid ""
"Returns ``True`` if the user has any permissions in the given package (the "
"Django app label). If the user is inactive, this method will always return "
"``False``."
msgstr ""
"Вернет ``True`` если пользователь имеет какие либо права доступа для "
"указанного пакета (приложения Django). Вернет ``False`` если пользователь не "
"активен."

# aca86586415e451e80a2590f23380145
#: ../../topics/auth/customizing.txt:0
msgid "ModelBackend"
msgstr "ModelBackend"

# 3e7b6f224737443287a254d7f55379e4
#: ../../topics/auth/customizing.txt:892
msgid ""
"If you don't include the :class:`~django.contrib.auth.models."
"PermissionsMixin`, you must ensure you don't invoke the permissions methods "
"on ``ModelBackend``. ``ModelBackend`` assumes that certain fields are "
"available on your user model. If your User model doesn't provide  those "
"fields, you will receive database errors when you check permissions."
msgstr ""
"Если Вы не включаете класс :class:`~django.contrib.auth.models."
"PermissionsMixin` Вы должны убедиться, что не ссылаетесь на методы проверки "
"прав доступа определенные в ``ModelBackend``. ``ModelBackend`` предполагает, "
"что определенные поля доступны в Вашей модели пользователя. И если Ваша "
"модель пользователей не имеет этих полей Вы будете получать ошибки базы "
"данных когда попытаетесь проверить права доступа."

# 3832bfa0c9ff4fc992b2693fb925e691
#: ../../topics/auth/customizing.txt:900
msgid "Custom users and Proxy models"
msgstr "Пользовательская модель ``User`` и Proxy модели"

# c5cbe64a379a46f4b19508c9ade5f540
#: ../../topics/auth/customizing.txt:902
msgid ""
"One limitation of custom User models is that installing a custom User model "
"will break any proxy model extending :class:`~django.contrib.auth.models."
"User`. Proxy models must be based on a concrete base class; by defining a "
"custom User model, you remove the ability of Django to reliably identify the "
"base class."
msgstr ""
"Одним из ограничений пользовательской модели :class:`~django.contrib.auth."
"models.User` является то, что она сломает любые Proxy модели расширяющие "
"стандартную модель. Proxy модели должны основываться на конкретном базовом "
"классе. Определяя пользовательскую модель ``User`` Вы лишаете Django "
"возможности конкретно определить базовый класс."

# 0813f779256d4cfd80934a69de9b77f4
#: ../../topics/auth/customizing.txt:907
msgid ""
"If your project uses proxy models, you must either modify the proxy to "
"extend the User model that is currently in use in your project, or merge "
"your proxy's behavior into your User subclass."
msgstr ""
"Если в своем проекте Вы используете Proxy модели Вы должны либо "
"модифицировать ее что бы она расширяла модель ``User``, которая используется "
"в Ваше проекте, либо определить функции выполняемые Proxy моделями "
"непосредственно с Вашей пользовательской модели."

# de0a3d172dda41d28c34e949b8b20cbd
#: ../../topics/auth/customizing.txt:912
msgid "Custom users and testing/fixtures"
msgstr "Пользовательская модель ``User`` и тестирование."

# 4868b3f0f37c4b13a62efe6697c16146
#: ../../topics/auth/customizing.txt:914
msgid ""
"If you are writing an application that interacts with the User model, you "
"must take some precautions to ensure that your test suite will run "
"regardless of the User model that is being used by a project. Any test that "
"instantiates an instance of User will fail if the User model has been "
"swapped out. This includes any attempt to create an instance of User with a "
"fixture."
msgstr ""
"Если Вы пишите приложение, которое взаимодействует с пользовательской "
"моделью, Вы должны принять некоторые меры предосторожности, чтобы убедиться, "
"что Ваш набор тестов работает независимо от использующейся в Вашем проекте "
"модели пользователей. А также если Вы создаете экземпляр класса ``User`` "
"используя файлы предварительной настройки."

# 607bdff86afa49c3910b89bafe4f1af3
#: ../../topics/auth/customizing.txt:920
msgid ""
"To ensure that your test suite will pass in any project configuration, "
"``django.contrib.auth.tests.utils`` defines a ``@skipIfCustomUser`` "
"decorator. This decorator will cause a test case to be skipped if any User "
"model other than the default Django user is in use. This decorator can be "
"applied to a single test, or to an entire test class."
msgstr ""
"Что бы убедиться что Ваш набор тестов будет успешно выполняться в любой "
"конфигурации ``django.contrib.auth.tests.utils`` определяет декоратор "
"``@skipIfCustomUser``.  Этот декоратор позволяет пропустить тест если "
"используется модель пользователей отличная от стандартной модели. Может "
"применяться как для одного теста так и для всего тестового класса."

#: ../../topics/auth/customizing.txt:928
msgid ""
"With the test discovery changes in Django 1.6, the tests for ``django."
"contrib`` apps are no longer run as part of the user's project. Therefore, "
"the ``@skipIfCustomUser`` decorator is no longer needed to decorate tests in "
"``django.contrib.auth``."
msgstr ""

# 7acc4cc313884719afe3b83ddf214637
#: ../../topics/auth/customizing.txt:933
msgid ""
"Depending on your application, tests may also be needed to be added to "
"ensure that the application works with *any* user model, not just the "
"default User model. To assist with this, Django provides two substitute user "
"models that can be used in test suites:"
msgstr ""
"В зависимости от Вашего приложения, Вам также может понадобиться добавить "
"тесты для проверки того, что Ваше приложение работает с любой моделью "
"пользователей, а не только со стандартной моделью. Что бы помочь с этим "
"Django предоставляет два заменителя пользовательской модели которые могут "
"быть использованы в Вашем наборе тестов:"

# 26b556c6a5814a98b3c59c93687fb0d5
#: ../../topics/auth/customizing.txt:940
msgid ""
"A custom user model that uses an ``email`` field as the username, and has a "
"basic admin-compliant permissions setup"
msgstr ""
"Модель использующая поле ``email`` в качестве имени пользователя имеющее "
"базовые настройки доступа к административной части."

# 79f493573cab458c91adf8afcc471c04
#: ../../topics/auth/customizing.txt:945
msgid ""
"A custom user model that extends ``django.contrib.auth.models."
"AbstractUser``, adding a ``date_of_birth`` field."
msgstr ""
"Модель расширяющая ``django.contrib.auth.models.AbstractUser`` добавляя поле "
"``date_of_birth``."

# 46bc383a053d4a708534981f7e527794
#: ../../topics/auth/customizing.txt:948
msgid ""
"You can then use the ``@override_settings`` decorator to make that test run "
"with the custom User model. For example, here is a skeleton for a test that "
"would test three possible User models -- the default, plus the two User "
"models provided by ``auth`` app::"
msgstr ""
"Вы можете использовать декоратор ``@override_settings`` что бы  запустить "
"ваши тесты с новой пользовательской моделью. Вот каркас для теста, который "
"будет тестировать три возможные модели пользователей -- стандартную, плюс "
"две модели представленные  в приложении ``auth``::"

# 9501300e6b5f4c02a0ec091bce5a3a61
#: ../../topics/auth/customizing.txt:975
msgid "A full example"
msgstr "Полный пример"

# 9809cb52cfef41fca1d0f6d39aa216cd
#: ../../topics/auth/customizing.txt:977
msgid ""
"Here is an example of an admin-compliant custom user app. This user model "
"uses an email address as the username, and has a required date of birth; it "
"provides no permission checking, beyond a simple ``admin`` flag on the user "
"account. This model would be compatible with all the built-in auth forms and "
"views, except for the User creation forms. This example illustrates how most "
"of the components work together, but is not intended to be copied directly "
"into projects for production use."
msgstr ""
"Здесь Вы можете посмотреть пример админ-совместимого приложения управления "
"пользователями. Пользовательская модель использует в качестве имени "
"пользователя email и еще имеет обязательное поле даты рождения. Так же она "
"не предоставляет никаких пользовательских прав, за исключением простого "
"флага ``admin``. Эта модель будет совместима со всеми встроенными формами и "
"представлениями, за исключением формы создания пользователя. Этот пример "
"иллюстрирует, как большинство компонентов работают вместе, но не "
"предназначен для копирования непосредственно в Ваши проекты для "
"использования на продакшн сервере."

# ce445ce2bbd0488a9b96396155807855
#: ../../topics/auth/customizing.txt:985
msgid ""
"This code would all live in a ``models.py`` file for a custom authentication "
"app::"
msgstr ""
"Этот код будет полностью находится в файле ``models.py`` Вашего приложения "
"аутентификации::"

# b0845fadf5fe4846b695275672fe2287
#: ../../topics/auth/customizing.txt:1068
msgid ""
"Then, to register this custom User model with Django's admin, the following "
"code would be required in the app's ``admin.py`` file::"
msgstr ""
"Затем, что бы зарегистрировать вашу пользовательскую модель для панели "
"администратора Django, нужно добавить следующий код в файл ``admin.py`` "
"Вашего приложения::"

# bc7f337c88634ec8ba7e25c8fb3e48c4
#: ../../topics/auth/customizing.txt:1158
msgid ""
"Finally, specify the custom model as the default user model for your project "
"using the :setting:`AUTH_USER_MODEL` setting in your ``settings.py``::"
msgstr ""
"И, на конец, указать вашу пользовательскую модель в качестве модели по "
"умолчанию в файле ``settings.py`` (:setting:`AUTH_USER_MODEL`)::"
