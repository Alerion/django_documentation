# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-05 11:28+0300\n"
"PO-Revision-Date: 2016-02-03 12:38+0200\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none <>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# c75c8c34785847fea7f9fbdc89248b33
#: ../../topics/db/models.txt:3
msgid "Models"
msgstr "Модели"

# 11137305691b416eb5e9aa1c16ac72b3
#: ../../topics/db/models.txt:7
msgid ""
"A model is the single, definitive source of information about your data. It "
"contains the essential fields and behaviors of the data you're storing. "
"Generally, each model maps to a single database table."
msgstr ""
"Модели отображают информацию о данных, с которыми вы работаете. Они содержат "
"поля и поведение ваших данных. Обычно одна модель представляет одну таблицу "
"в базе данных."

# a872f09c8c734beeaacbbe4d58a8694a
#: ../../topics/db/models.txt:11
msgid "The basics:"
msgstr "Основы:"

# 8e07ef8c3f9c45ea9a3333b021707ca4
#: ../../topics/db/models.txt:13
msgid ""
"Each model is a Python class that subclasses :class:`django.db.models.Model`."
msgstr ""
"Каждая модель это класс унаследованный от :class:`django.db.models.Model`."

# 16525490eea541d7bb28cc797e3ebd1d
#: ../../topics/db/models.txt:16
msgid "Each attribute of the model represents a database field."
msgstr "Атрибут модели представляет поле в базе данных."

# 635925e93aa145e0898ff9bb0c392917
#: ../../topics/db/models.txt:18
msgid ""
"With all of this, Django gives you an automatically-generated database-"
"access API; see :doc:`/topics/db/queries`."
msgstr ""
"Django предоставляет автоматически созданное API для доступа к данным; "
"смотрите :doc:`/topics/db/queries`."

# d6c34f064ebc4f91abc784ab1895902c
#: ../../topics/db/models.txt:23
msgid "Quick example"
msgstr "Примеры"

# 6662ca02f4444f73987a64e3dcd853b4
#: ../../topics/db/models.txt:25
msgid ""
"This example model defines a ``Person``, which has a ``first_name`` and "
"``last_name``::"
msgstr ""
"Вот пример модели, которая определяет гипотетического человека(``Person``), "
"с именем(``first_name``) и фамилией(``last_name``)::"

# 4cee07cc74a5462e98e086333e98e67e
#: ../../topics/db/models.txt:34
msgid ""
"``first_name`` and ``last_name`` are fields_ of the model. Each field is "
"specified as a class attribute, and each attribute maps to a database column."
msgstr ""
"``first_name`` и ``last_name`` поля модели. Каждое поле определено как "
"атрибут класса, и каждый атрибут соответствует полю таблицы в базе данных."

# a84a5d45553242679bd1d8eae161fa09
#: ../../topics/db/models.txt:37
msgid "The above ``Person`` model would create a database table like this:"
msgstr "Модель ``Person`` создаст в базе данных таблицу:"

# 4730bf4d3f6949eabd80bf4c2f3afa05
#: ../../topics/db/models.txt:47
msgid "Some technical notes:"
msgstr "Технические замечания:"

# d8896eb3092340e29f07e1bb11d6f723
#: ../../topics/db/models.txt:49
msgid ""
"The name of the table, ``myapp_person``, is automatically derived from some "
"model metadata but can be overridden. See :ref:`table-names` for more "
"details."
msgstr ""
"Название таблицы, ``myapp_person``, автоматически создано с метаданных "
"модели и может быть переопределено. Подробнее :ref:`table-names`."

# bae5929c89ca49cab4a4868d78c36ba0
#: ../../topics/db/models.txt:53
msgid ""
"An ``id`` field is added automatically, but this behavior can be overridden. "
"See :ref:`automatic-primary-key-fields`."
msgstr ""
"Поле ``id`` добавлено автоматически, но его также можно переопределить. "
"Подробнее :ref:`automatic-primary-key-fields`."

# 8fcbb5f3ed7d400aade29783568860ba
#: ../../topics/db/models.txt:56
msgid ""
"The ``CREATE TABLE`` SQL in this example is formatted using PostgreSQL "
"syntax, but it's worth noting Django uses SQL tailored to the database "
"backend specified in your :doc:`settings file </topics/settings>`."
msgstr ""
"``CREATE TABLE`` SQL в этом примере соответствует синтаксису PostgreSQL, но "
"стоит учесть что Django использует синтаксис SQL соответственно настройкам "
"базы данных в :doc:`файле настроек </topics/settings>`."

# 826c383753254d2e855fda7302398226
#: ../../topics/db/models.txt:61
msgid "Using models"
msgstr "Использование моделей"

# 78f65e394d5f4e6e8d2788f30201fa02
#: ../../topics/db/models.txt:63
msgid ""
"Once you have defined your models, you need to tell Django you're going to "
"*use* those models. Do this by editing your settings file and changing the :"
"setting:`INSTALLED_APPS` setting to add the name of the module that contains "
"your ``models.py``."
msgstr ""
"После определения моделей необходимо указать Django что необходимо их "
"*использовать*. Сделайте это отредактировав файл настроек и изменив :setting:"
"`INSTALLED_APPS`, добавив пакет, который содержит ваш ``models.py``."

# 6a4bb435accb414998b05c2fd48ad849
#: ../../topics/db/models.txt:68
msgid ""
"For example, if the models for your application live in the module ``myapp."
"models`` (the package structure that is created for an application by the :"
"djadmin:`manage.py startapp <startapp>` script), :setting:`INSTALLED_APPS` "
"should read, in part::"
msgstr ""
"Например, если модели вашего приложения находятся в ``myapp.models`` "
"(структура пакетов создана с помощью команды создания приложения :djadmin:"
"`manage.py startapp <startapp>`), :setting:`INSTALLED_APPS` должен "
"содержать::"

# 2131c6232aef4c4296e7f82b79bc6bc7
#: ../../topics/db/models.txt:79
msgid ""
"When you add new apps to :setting:`INSTALLED_APPS`, be sure to run :djadmin:"
"`manage.py migrate <migrate>`, optionally making migrations for them first "
"with :djadmin:`manage.py makemigrations <makemigrations>`."
msgstr ""
"После добавления приложения в :setting:`INSTALLED_APPS`, не забудьте "
"выполнить :djadmin:`manage.py migrate <syncdb>`. Возможно, нужно будет "
"создать сначала миграции, выполнив :djadmin:`manage.py makemigrations "
"<makemigrations>`."

# 2478275f7df740429dbba2499c0470de
#: ../../topics/db/models.txt:84
msgid "Fields"
msgstr "Поля"

# ff05361377ab456caef982c1b03972e5
#: ../../topics/db/models.txt:86
msgid ""
"The most important part of a model -- and the only required part of a model "
"-- is the list of database fields it defines. Fields are specified by class "
"attributes. Be careful not to choose field names that conflict with the :doc:"
"`models API </ref/models/instances>` like ``clean``, ``save``, or ``delete``."
msgstr ""
"Самая важная часть модели -- и единственная обязательная -- это список полей "
"таблицы базы данных которые она представляет. Поля определены атрибутами "
"класса. Нельзя использовать имена конфликтующие с :doc:`API моделей </ref/"
"models/instances>`, такие как ``clean``, ``save`` или ``delete``."

# 4faa5224d3d24be6a6d07e2e96b22c48
#: ../../topics/db/models.txt:92
msgid "Example::"
msgstr "Пример::"

# 0bd2c34f0de94435ae6eb7014fca8384
#: ../../topics/db/models.txt:108
msgid "Field types"
msgstr "Типы полей"

# fd6bde64915045d2bf4d43f752b12fb3
#: ../../topics/db/models.txt:110
msgid ""
"Each field in your model should be an instance of the appropriate :class:"
"`~django.db.models.Field` class. Django uses the field class types to "
"determine a few things:"
msgstr ""
"Каждое поле в вашей модели должно быть экземпляром соответствующего :class:"
"`~django.db.models.Field` класса. Django использует классы полей для "
"определения такой информации:"

#: ../../topics/db/models.txt:114
msgid ""
"The column type, which tells the database what kind of data to store (e.g. "
"``INTEGER``, ``VARCHAR``, ``TEXT``)."
msgstr ""

# bf96df19f4ae44418a9e1f0d1e9003d8
#: ../../topics/db/models.txt:117
msgid ""
"The default HTML :doc:`widget </ref/forms/widgets>` to use when rendering a "
"form field (e.g. ``<input type=\"text\">``, ``<select>``)."
msgstr ""
":doc:`Виджет </ref/forms/widgets>` используемый при создании поля формы "
"(например: ``<input type=\"text\">``, ``<select>``)."

# abeb0ab8d6bc4bfcab6aea7ea1262070
#: ../../topics/db/models.txt:120
msgid ""
"The minimal validation requirements, used in Django's admin and in "
"automatically-generated forms."
msgstr ""
"Минимальные правила проверки данных, используемые в интерфейсе "
"администратора и для автоматического создания формы."

# 7ee114cbbd944107881ab2a306e7dab7
#: ../../topics/db/models.txt:123
msgid ""
"Django ships with dozens of built-in field types; you can find the complete "
"list in the :ref:`model field reference <model-field-types>`. You can easily "
"write your own fields if Django's built-in ones don't do the trick; see :doc:"
"`/howto/custom-model-fields`."
msgstr ""
"В Django есть большое количество полей; полный список можно посмотреть на :"
"ref:`странице списка полей <model-field-types>`. Вы можете легко добавить "
"собственное поле; смотрите :doc:`/howto/custom-model-fields`."

# c5079fe7999245f6a3e69385c6dc08c8
#: ../../topics/db/models.txt:129
msgid "Field options"
msgstr "Настройка полей"

# 175c8193a39b4af9973bc58980570590
#: ../../topics/db/models.txt:131
msgid ""
"Each field takes a certain set of field-specific arguments (documented in "
"the :ref:`model field reference <model-field-types>`). For example, :class:"
"`~django.db.models.CharField` (and its subclasses) require a :attr:`~django."
"db.models.CharField.max_length` argument which specifies the size of the "
"``VARCHAR`` database field used to store the data."
msgstr ""
"Для каждого поля есть набор предопределенных аргументов (описание на :ref:"
"`странице описания полей <model-field-types>`). Например, :class:`~django.db."
"models.CharField` (и унаследованные от него) имеют обязательный аргумент :"
"attr:`~django.db.models.CharField.max_length`, который определяет размер "
"поля ``VARCHAR`` для хранения данных этого поля."

# 3f17fb8c77da4f04ae30c62af0416ccd
#: ../../topics/db/models.txt:137
msgid ""
"There's also a set of common arguments available to all field types. All are "
"optional. They're fully explained in the :ref:`reference <common-model-field-"
"options>`, but here's a quick summary of the most often-used ones:"
msgstr ""
"Также есть список стандартных аргументов для всех полей. Все они не "
"обязательны. Все они описаны в :ref:`разделе про аргументы полей "
"модели<common-model-field-options>`, вот список самых используемых:"

#: ../../topics/db/models.txt:144
msgid "null"
msgstr ""

# e4553425e4b34a2eb395d54d45459430
#: ../../topics/db/models.txt:143
msgid ""
"If ``True``, Django will store empty values as ``NULL`` in the database. "
"Default is ``False``."
msgstr ""
"Если ``True``, Django сохранит пустое значение как ``NULL`` в базе данных. "
"По умолчанию - ``False``."

#: ../../topics/db/models.txt:154
msgid "blank"
msgstr ""

# b820abbcfac74d64992e2ff1110100d5
#: ../../topics/db/models.txt:147
msgid "If ``True``, the field is allowed to be blank. Default is ``False``."
msgstr ""
"Если ``True``, поле не обязательно и может быть пустым. По умолчанию - "
"``False``."

# 26473561bb0840be9f0ce1ce2924e2ef
#: ../../topics/db/models.txt:149
msgid ""
"Note that this is different than :attr:`~Field.null`. :attr:`~Field.null` is "
"purely database-related, whereas :attr:`~Field.blank` is validation-related. "
"If a field has :attr:`blank=True <Field.blank>`, form validation will allow "
"entry of an empty value. If a field has :attr:`blank=False <Field.blank>`, "
"the field will be required."
msgstr ""
"Это не то же что и :attr:`~Field.null`. :attr:`~Field.null` относится к базе "
"данных, :attr:`~Field.blank` - к проверке данных. Если поле содержит :attr:"
"`blank=True <Field.blank>`, форма позволит передать пустое значение. При :"
"attr:`blank=False <Field.blank>` - поле обязательно."

#: ../../topics/db/models.txt:196
msgid "choices"
msgstr ""

# a0c174fedb1d43e9ab369c0b5cb2220c
#: ../../topics/db/models.txt:157
msgid ""
"An iterable (e.g., a list or tuple) of 2-tuples to use as choices for this "
"field. If this is given, the default form widget will be a select box "
"instead of the standard text field and will limit choices to the choices "
"given."
msgstr ""
"Итератор (например, список или кортеж) 2-х элементных кортежей, определяющих "
"варианты значений для поля. При определении, виджет формы использует select "
"вместо стандартного текстового поля и ограничит значение поля указанными "
"значениями."

# 10a6d891752e44fca08e69a80a5855ba
#: ../../topics/db/models.txt:162
msgid "A choices list looks like this::"
msgstr "Список значений выглядит::"

# e0c906b6fbe94fa885dc61dacf01666c
#: ../../topics/db/models.txt:172
#, fuzzy
msgid ""
"The first element in each tuple is the value that will be stored in the "
"database. The second element will be displayed by the default form widget or "
"in a :class:`~django.forms.ModelChoiceField`. Given a model instance, the "
"display value for a choices field can be accessed using the "
"``get_FOO_display()`` method. For example::"
msgstr ""
"Первый элемент в кортеже - значение хранимое в базе данных, второй элемент - "
"отображается виджетом формы, или в ModelChoiceField. Для получения "
"отображаемого значения используется метод ``get_FOO_display`` экземпляра "
"модели. Например::"

#: ../../topics/db/models.txt:201
msgid "default"
msgstr ""

# 484b4e647a074f42b9dd6f0ae7f008f3
#: ../../topics/db/models.txt:199
msgid ""
"The default value for the field. This can be a value or a callable object. "
"If callable it will be called every time a new object is created."
msgstr ""
"Значение по умолчанию для этого поля. Это может быть значение или функция. "
"Если это функция - она будет вызвана при каждом создании объекта."

#: ../../topics/db/models.txt:205
msgid "help_text"
msgstr ""

# 1532782d179643368905bdd9d4aa8349
#: ../../topics/db/models.txt:204
msgid ""
"Extra \"help\" text to be displayed with the form widget. It's useful for "
"documentation even if your field isn't used on a form."
msgstr ""
"Подсказка, отображаемая в поле формы. Это полезно для описания поля, даже "
"если поле не используется в формах."

#: ../../topics/db/models.txt:232
msgid "primary_key"
msgstr ""

# 3648acb2233745cb95a537d0383fa7b7
#: ../../topics/db/models.txt:208
msgid "If ``True``, this field is the primary key for the model."
msgstr "При ``True`` поле будет первичным ключом."

# 6041a11148064dca963c102b99e0800b
#: ../../topics/db/models.txt:210
msgid ""
"If you don't specify :attr:`primary_key=True <Field.primary_key>` for any "
"fields in your model, Django will automatically add an :class:`IntegerField` "
"to hold the primary key, so you don't need to set :attr:`primary_key=True "
"<Field.primary_key>` on any of your fields unless you want to override the "
"default primary-key behavior. For more, see :ref:`automatic-primary-key-"
"fields`."
msgstr ""
"Если :attr:`primary_key=True <Field.primary_key>` не указан ни для одного "
"поля, Django самостоятельно добавит поле типа :class:`IntegerField` для "
"хранения первичного ключа, поэтому вам не обязательно указывать :attr:"
"`primary_key=True <Field.primary_key>` для каждой модели. Подробнее :ref:"
"`automatic-primary-key-fields`."

#: ../../topics/db/models.txt:217
msgid ""
"The primary key field is read-only. If you change the value of the primary "
"key on an existing object and then save it, a new object will be created "
"alongside the old one. For example::"
msgstr ""
"Поле первичного ключа доступно только для чтения. Если вы поменяете значение "
"первичного ключа для существующего объекта, а зачем сохраните его, будет "
"создан новый объект рядом с существующим. Например::"

#: ../../topics/db/models.txt:235
msgid "unique"
msgstr ""

# 5bf916f31c07402e8b091d16d74d85a3
#: ../../topics/db/models.txt:235
msgid "If ``True``, this field must be unique throughout the table."
msgstr "При ``True`` поле будет уникальным."

# 3217ae2ca3c24bf38342ee8311ce2b6d
#: ../../topics/db/models.txt:237
msgid ""
"Again, these are just short descriptions of the most common field options. "
"Full details can be found in the :ref:`common model field option reference "
"<common-model-field-options>`."
msgstr ""
"Это краткое описание самых используемых аргументов. Полный список можно "
"найти на :ref:`странице описания аргументов поля модели <common-model-field-"
"options>`."

# e5a12e69fe5247858e27db8d2d8d3234
#: ../../topics/db/models.txt:244
msgid "Automatic primary key fields"
msgstr "Первичный ключ по умолчанию"

# 6ce244681b5743e5852682324429b405
#: ../../topics/db/models.txt:246
msgid "By default, Django gives each model the following field::"
msgstr "По умолчанию Django для каждой модели добавляет такое поле::"

# 24c366bec6dd4df7a9e49a82bd138c10
#: ../../topics/db/models.txt:250
msgid "This is an auto-incrementing primary key."
msgstr "Это автоинкрементный первичный ключ."

# 89bffbb3539b4d949814a924e5cf202c
#: ../../topics/db/models.txt:252
msgid ""
"If you'd like to specify a custom primary key, just specify :attr:"
"`primary_key=True <Field.primary_key>` on one of your fields. If Django sees "
"you've explicitly set :attr:`Field.primary_key`, it won't add the automatic "
"``id`` column."
msgstr ""
"Для его переопределения просто укажите :attr:`primary_key=True <Field."
"primary_key>` для одного из полей. При этом Django не добавит поле ``id``."

# 0c38bce1f59d4eca90044cb73c40312d
#: ../../topics/db/models.txt:257
msgid ""
"Each model requires exactly one field to have :attr:`primary_key=True <Field."
"primary_key>` (either explicitly declared or automatically added)."
msgstr ""
"Каждая модель должна иметь хотя бы одно поле с :attr:`primary_key=True "
"<Field.primary_key>` (явно указанное или созданное автоматически)."

# c3bf07d27fc94059a253218131ffb88f
#: ../../topics/db/models.txt:263
msgid "Verbose field names"
msgstr "Читабельное имя поля"

# 6664af7dacb24228bca6d9521237f415
#: ../../topics/db/models.txt:265
msgid ""
"Each field type, except for :class:`~django.db.models.ForeignKey`, :class:"
"`~django.db.models.ManyToManyField` and :class:`~django.db.models."
"OneToOneField`, takes an optional first positional argument -- a verbose "
"name. If the verbose name isn't given, Django will automatically create it "
"using the field's attribute name, converting underscores to spaces."
msgstr ""
"Каждое поле, кроме :class:`~django.db.models.ForeignKey`, :class:`~django.db."
"models.ManyToManyField` и :class:`~django.db.models.OneToOneField`, первым "
"аргументом принимает необязательное читабельное название. Если оно не "
"указано, Django самостоятельно создаст его, используя название поля, заменяя "
"подчеркивание на пробел."

# fba4ebde237644238fca77f65c5d708d
#: ../../topics/db/models.txt:272
msgid "In this example, the verbose name is ``\"person's first name\"``::"
msgstr "В этом примере читабельное название - ``\"person's first name\"``::"

# 8767087247fb46f5ad5d0fb5c09c80b1
#: ../../topics/db/models.txt:276
msgid "In this example, the verbose name is ``\"first name\"``::"
msgstr "Здесь - ``\"first name\"``::"

# 852fd8dff13e43d2abf27a8970b4dafa
#: ../../topics/db/models.txt:280
msgid ""
":class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` and :class:`~django.db.models.OneToOneField` require the "
"first argument to be a model class, so use the :attr:`~Field.verbose_name` "
"keyword argument::"
msgstr ""
":class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` и :class:`~django.db.models.OneToOneField` первым "
"аргументом принимает класс модели, поэтому используется keyword аргумент :"
"attr:`~Field.verbose_name`::"

# f49ecf24c7ec4bbfaef3946811a3a1b7
#: ../../topics/db/models.txt:297
msgid ""
"The convention is not to capitalize the first letter of the :attr:`~Field."
"verbose_name`. Django will automatically capitalize the first letter where "
"it needs to."
msgstr ""
"Django не делает первую букву прописной для :attr:`~Field.verbose_name` - "
"только там, где это необходимо."

# eb2fc19ac14c4224b84db6c0017c26e0
#: ../../topics/db/models.txt:302
msgid "Relationships"
msgstr "Связи"

# 7b452d78594f4a8d8331b8919af64061
#: ../../topics/db/models.txt:304
msgid ""
"Clearly, the power of relational databases lies in relating tables to each "
"other. Django offers ways to define the three most common types of database "
"relationships: many-to-one, many-to-many and one-to-one."
msgstr ""
"Основное преимущество реляционных баз данных  - возможность добавлять связи "
"для таблиц. Django предоставляет возможность использовать три самых "
"используемых типа связей: многое-к-одному, многие-ко-многим и один-к-одному."

# 7f22c90e884347f4aad9705eebe81853
#: ../../topics/db/models.txt:309
msgid "Many-to-one relationships"
msgstr "Связь многое-к-одному"

# 79a76880d75f4fc5b8c217ff317ae086
#: ../../topics/db/models.txt:311
msgid ""
"To define a many-to-one relationship, use :class:`django.db.models."
"ForeignKey`. You use it just like any other :class:`~django.db.models.Field` "
"type: by including it as a class attribute of your model."
msgstr ""
"Для определения связи многое-к-одному используется :class:`django.db.models."
"ForeignKey`. Вы используете его так же, как и другие типы :class:`~django.db."
"models.Field`: добавляя как атрибут в модель."

# 22eebec9d2c341a29e7c9ee4ef6a39aa
#: ../../topics/db/models.txt:315
msgid ""
":class:`~django.db.models.ForeignKey` requires a positional argument: the "
"class to which the model is related."
msgstr ""
"Для :class:`~django.db.models.ForeignKey` необходимо указать обязательный "
"позиционный аргумент: класс связанной модели."

# 51696ba0bb244b09ace73f872767cacf
#: ../../topics/db/models.txt:318
msgid ""
"For example, if a ``Car`` model has a ``Manufacturer`` -- that is, a "
"``Manufacturer`` makes multiple cars but each ``Car`` only has one "
"``Manufacturer`` -- use the following definitions::"
msgstr ""
"Например, если модель ``Car`` содержит информацию о ``Manufacturer`` -- это "
"отношение многое-к-одному. ``Manufacturer`` производит много ``Car``, "
"которая связана только с одной ``Manufacturer`` -- используйте следующее "
"определение::"

# 30d97cb86bb745a6b1f5486212d09b17
#: ../../topics/db/models.txt:332
msgid ""
"You can also create :ref:`recursive relationships <recursive-relationships>` "
"(an object with a many-to-one relationship to itself) and :ref:"
"`relationships to models not yet defined <lazy-relationships>`; see :ref:"
"`the model field reference <ref-foreignkey>` for details."
msgstr ""
"Вы можете также создать :ref:`рекурсивную связь<recursive-relationships>` "
"(объект со связью многое-к-одному на себя) и :ref:`связь с моделью, которая "
"еще не определена <lazy-relationships>`; смотрите :ref:`справку по полям "
"модели<ref-foreignkey>` для подробностей."

# ccabcc7335b846c0a37788cd4575065f
#: ../../topics/db/models.txt:337
msgid ""
"It's suggested, but not required, that the name of a :class:`~django.db."
"models.ForeignKey` field (``manufacturer`` in the example above) be the name "
"of the model, lowercase. You can, of course, call the field whatever you "
"want. For example::"
msgstr ""
"Желательно, но не обязательно,  чтобы название :class:`~django.db.models."
"ForeignKey` поля (``manufacturer`` в примере выше) было названием модели в "
"нижнем регистре. Конечно же вы можете назвать поле, как вам угодно.  "
"Например::"

# 436ced8e6d4f4ca8b0d345c1f174d85a
#: ../../topics/db/models.txt:351
msgid ""
":class:`~django.db.models.ForeignKey` fields accept a number of extra "
"arguments which are explained in :ref:`the model field reference <foreign-"
"key-arguments>`. These options help define how the relationship should work; "
"all are optional."
msgstr ""
":class:`~django.db.models.ForeignKey` принимает дополнительные аргументы, "
"смотрите :ref:`справку по полям модели<foreign-key-arguments>`. Эти "
"аргументы определяют, как работает связь, все они не обязательны."

# 3dc08bd753c842739240df6c2e6cd839
#: ../../topics/db/models.txt:356
msgid ""
"For details on accessing backwards-related objects, see the :ref:`Following "
"relationships backward example <backwards-related-objects>`."
msgstr ""
"Пример работы с обратно-связанными объектами смотрите в :ref:`в "
"соответствующем разделе<backwards-related-objects>`."

# da62d903554a41a486671705b99b716c
#: ../../topics/db/models.txt:359
msgid ""
"For sample code, see the :doc:`Many-to-one relationship model example </"
"topics/db/examples/many_to_one>`."
msgstr ""
"Примеры кода можно найти  в :doc:`соответствующем разделе </topics/db/"
"examples/many_to_one>`."

# 3bbdd50c7d824f3aac7fe8f69c43dff7
#: ../../topics/db/models.txt:364
msgid "Many-to-many relationships"
msgstr "Связь много-ко-многому"

# c33c12bceba04710b6a348fd0f2e0d3f
#: ../../topics/db/models.txt:366
msgid ""
"To define a many-to-many relationship, use :class:`~django.db.models."
"ManyToManyField`. You use it just like any other :class:`~django.db.models."
"Field` type: by including it as a class attribute of your model."
msgstr ""
"Для определения связи многие-ко-многим, используйте :class:`~django.db."
"models.ManyToManyField`. Используется так же, как и остальные типы :class:"
"`~django.db.models.Field`: добавлением как атрибут класса."

# ed1aa7371b3b49168b370b427cf24ceb
#: ../../topics/db/models.txt:371
msgid ""
":class:`~django.db.models.ManyToManyField` requires a positional argument: "
"the class to which the model is related."
msgstr ""
"Для :class:`~django.db.models.ManyToManyField` необходимо указать "
"обязательный позиционный аргумент: класс связанной модели."

# 5a395bc8082240dba9f79620afd784c3
#: ../../topics/db/models.txt:374
msgid ""
"For example, if a ``Pizza`` has multiple ``Topping`` objects -- that is, a "
"``Topping`` can be on multiple pizzas and each ``Pizza`` has multiple "
"toppings -- here's how you'd represent that::"
msgstr ""
"Например, если пицца(``Pizza``) содержит много добавок(``Topping``) -- то "
"есть добавки(``Topping``) могут быть в различных сортах пиццы(``Pizza``) -- "
"вот как вы можете представить это::"

# 036159cb54464ea4b48c4af40863dafb
#: ../../topics/db/models.txt:388
#, fuzzy
msgid ""
"As with :class:`~django.db.models.ForeignKey`, you can also create :ref:"
"`recursive relationships <recursive-relationships>` (an object with a many-"
"to-many relationship to itself) and :ref:`relationships to models not yet "
"defined <lazy-relationships>`."
msgstr ""
"Так же, как и с :class:`~django.db.models.ForeignKey`, вы можете создать :"
"ref:`рекурсивную связь <recursive-relationships>` (объект со связью многие-"
"ко-многим на себя) и :ref:`связь с моделью, которая еще неопределенна <lazy-"
"relationships>`; смотрите :ref:`справку по полям модели <ref-manytomany>`."

# 4d14bbbbec5d4f3aaec5ddd2bddce115
#: ../../topics/db/models.txt:393
msgid ""
"It's suggested, but not required, that the name of a :class:`~django.db."
"models.ManyToManyField` (``toppings`` in the example above) be a plural "
"describing the set of related model objects."
msgstr ""
"Желательно, но не обязательно, чтобы название поля :class:`~django.db.models."
"ManyToManyField` (``toppings`` в нашем примере) было множественным "
"называнием связанных объектов."

# fa92e32d6d5e4e72ba7e8e070c6c9098
#: ../../topics/db/models.txt:397
msgid ""
"It doesn't matter which model has the :class:`~django.db.models."
"ManyToManyField`, but you should only put it in one of the models -- not "
"both."
msgstr ""
"Не имеет значения какая модель содержит поле :class:`~django.db.models."
"ManyToManyField`, но вы должны добавить его только для одной модели."

# b6bf3b24895945c1bb0cc254f966d3e1
#: ../../topics/db/models.txt:401
msgid ""
"Generally, :class:`~django.db.models.ManyToManyField` instances should go in "
"the object that's going to be edited on a form. In the above example, "
"``toppings`` is in ``Pizza`` (rather than ``Topping`` having a ``pizzas`` :"
"class:`~django.db.models.ManyToManyField` ) because it's more natural to "
"think about a pizza having toppings than a topping being on multiple pizzas. "
"The way it's set up above, the ``Pizza`` form would let users select the "
"toppings."
msgstr ""
"Обычно, :class:`~django.db.models.ManyToManyField` необходимо добавить в "
"модель, которая будет редактироваться в форме. В примере выше, ``toppings`` "
"добавлено в ``Pizza`` (вместо того, чтобы добавить поле ``pizzas`` типа :"
"class:`~django.db.models.ManyToManyField` в модель ``Topping``), потому что "
"обычно думают о пицце с ингредиентами, а не об ингредиентах в различных "
"пиццах. В примере выше, форма для ``Pizza`` позволит пользователям "
"редактировать ингредиенты для пиццы."

# 18b6df1db5d84e12b1751996f5fcf6de
#: ../../topics/db/models.txt:410
msgid ""
"See the :doc:`Many-to-many relationship model example </topics/db/examples/"
"many_to_many>` for a full example."
msgstr ""
"Примеры использования связи многие-ко-многим можно найти в :doc:"
"`соответствующем разделе </topics/db/examples/many_to_many>`"

# bd1b3262e4dc4be7b69ee6fcc4b19540
#: ../../topics/db/models.txt:413
msgid ""
":class:`~django.db.models.ManyToManyField` fields also accept a number of "
"extra arguments which are explained in :ref:`the model field reference "
"<manytomany-arguments>`. These options help define how the relationship "
"should work; all are optional."
msgstr ""
"Поле :class:`~django.db.models.ManyToManyField` принимает список "
"дополнительных аргументов, подробнее в разделе :ref:`справки о полях "
"модели<manytomany-arguments>`. Эти настройки помогают определить как "
"работает связь, все они не обязательны."

# 8de521f22beb4545890d0721105e7a8a
#: ../../topics/db/models.txt:421
msgid "Extra fields on many-to-many relationships"
msgstr "Дополнительные поля для связи многие-ко-многим"

# 881cc28492c44294806fcc95a6abeaab
#: ../../topics/db/models.txt:423
msgid ""
"When you're only dealing with simple many-to-many relationships such as "
"mixing and matching pizzas and toppings, a standard :class:`~django.db."
"models.ManyToManyField` is all you need. However, sometimes you may need to "
"associate data with the relationship between two models."
msgstr ""
"В примере про пиццу нам нужно было всего лишь указать ингредиенты для пиццы, "
"и поля :class:`~django.db.models.ManyToManyField` было достаточно для этого. "
"Но иногда необходимо хранить дополнительную информацию о связи."

# 7b67bd5349904b0a8d3fa6aece30db66
#: ../../topics/db/models.txt:428
msgid ""
"For example, consider the case of an application tracking the musical groups "
"which musicians belong to. There is a many-to-many relationship between a "
"person and the groups of which they are a member, so you could use a :class:"
"`~django.db.models.ManyToManyField` to represent this relationship. However, "
"there is a lot of detail about the membership that you might want to "
"collect, such as the date at which the person joined the group."
msgstr ""
"Например, разберем приложение о музыкальных группах и музыкантах. Для "
"хранения связи между музыкантами и группами мы можем использовать поле :"
"class:`~django.db.models.ManyToManyField`. Но нам также необходимо хранить "
"дополнительную информацию, например, когда музыкант вступил в группу."

# 1104641cea6c4988a0fbecfc16213634
#: ../../topics/db/models.txt:435
msgid ""
"For these situations, Django allows you to specify the model that will be "
"used to govern the many-to-many relationship. You can then put extra fields "
"on the intermediate model. The intermediate model is associated with the :"
"class:`~django.db.models.ManyToManyField` using the :attr:`through "
"<ManyToManyField.through>` argument to point to the model that will act as "
"an intermediary. For our musician example, the code would look something "
"like this::"
msgstr ""
"Для таких случаев Django позволяет определить модель для хранения связи "
"многие-ко-многим и дополнительной информации. Теперь вы можете добавить "
"дополнительные поля в эту модель. Эту промежуточную модель можно указать в "
"поле :class:`~django.db.models.ManyToManyField` используя аргумент :attr:"
"`through <ManyToManyField.through>`, который указывает на промежуточную "
"модель. Для нашего примера код будет приблизительно таким::"

# 62262b63a1db4820b7072b2826d56b87
#: ../../topics/db/models.txt:464
msgid ""
"When you set up the intermediary model, you explicitly specify foreign keys "
"to the models that are involved in the many-to-many relationship. This "
"explicit declaration defines how the two models are related."
msgstr ""
"В промежуточной модели необходимо добавить внешние ключи на модели, "
"связанные отношением многие-ко-многим. Эти ключи указывают как связаны "
"модели."

# b471d98666dd47d78ceb759e381f6afb
#: ../../topics/db/models.txt:468
msgid "There are a few restrictions on the intermediate model:"
msgstr "Есть несколько ограничений для промежуточной модели:"

# 435858e1b33f44828bb0f90c079ffd13
#: ../../topics/db/models.txt:470
msgid ""
"Your intermediate model must contain one - and *only* one - foreign key to "
"the source model (this would be ``Group`` in our example), or you must "
"explicitly specify the foreign keys Django should use for the relationship "
"using :attr:`ManyToManyField.through_fields <ManyToManyField."
"through_fields>`. If you have more than one foreign key and "
"``through_fields`` is not specified, a validation error will be raised. A "
"similar restriction applies to the foreign key to the target model (this "
"would be ``Person`` in our example)."
msgstr ""
"Промежуточная модель должна содержать *только* одну связь с исходной моделью "
"(в нашем примере -- это ``Group``), или вы должны явно указать Django какую "
"связь использовать через параметр :attr:`ManyToManyField.through_fields "
"<ManyToManyField.through_fields>`. Если промежуточная модель содержит "
"несколько связей с исходной модель и ``through_fields`` не указан, будет "
"вызвана ошибка валидации. Аналогичные правила выполняются и для связанной "
"модели (в нашем примере -- ``Person``)."

# 1476c27c9acf4e96a33798b7b3f1f781
#: ../../topics/db/models.txt:479
msgid ""
"For a model which has a many-to-many relationship to itself through an "
"intermediary model, two foreign keys to the same model are permitted, but "
"they will be treated as the two (different) sides of the many-to-many "
"relationship. If there are *more* than two foreign keys though, you must "
"also specify ``through_fields`` as above, or a validation error will be "
"raised."
msgstr ""
"Исключение - промежуточная модель для рекурсивной связи. В таком случае у "
"промежуточной модели будет два внешних ключа на одну модель, но в таком "
"случае они будут восприниматься как две различных стороны связи многие-ко-"
"многим. Если промежуточная модель содержит *больше* двух связей, необходимо "
"указать ``through_fields``, иначе получите ошибку валидации."

# 2081c71652b940e7afcca5ee17b322c8
#: ../../topics/db/models.txt:486
msgid ""
"When defining a many-to-many relationship from a model to itself, using an "
"intermediary model, you *must* use :attr:`symmetrical=False <ManyToManyField."
"symmetrical>` (see :ref:`the model field reference <manytomany-arguments>`)."
msgstr ""
"При рекурсивной связи, используя промежуточную модель вы *должны* "
"использовать аргумент :attr:`symmetrical=False <ManyToManyField."
"symmetrical>` (смотрите :ref:`справку о полях модели <manytomany-"
"arguments>`)."

# 01725049cc294503b91f8a3313edbf8d
#: ../../topics/db/models.txt:491
msgid ""
"Now that you have set up your :class:`~django.db.models.ManyToManyField` to "
"use your intermediary model (``Membership``, in this case), you're ready to "
"start creating some many-to-many relationships. You do this by creating "
"instances of the intermediate model::"
msgstr ""
"После добавления в поле :class:`~django.db.models.ManyToManyField` "
"промежуточной модели (``Membership``, в нашем случае), вы можете создать "
"несколько связей, создавая экземпляр промежуточной модели::"

# 1bfd10564e43493bad6cc575b400c114
#: ../../topics/db/models.txt:513
#, fuzzy
msgid ""
"Unlike normal many-to-many fields, you *can't* use ``add()``, ``create()``, "
"or ``set()`` to create relationships::"
msgstr ""
"В отличии от обычного поля много-ко-многому, вы *не можете* использовать "
"``add``, ``create``, или присвоение(например, ``beatles.members = [...]``) "
"для создания отношения между моделями::"

# 14456bd614ae45cc835151ef144abb83
#: ../../topics/db/models.txt:521
msgid ""
"Why? You can't just create a relationship between a ``Person`` and a "
"``Group`` - you need to specify all the detail for the relationship required "
"by the ``Membership`` model. The simple ``add``, ``create`` and assignment "
"calls don't provide a way to specify this extra detail. As a result, they "
"are disabled for many-to-many relationships that use an intermediate model. "
"The only way to create this type of relationship is to create instances of "
"the intermediate model."
msgstr ""
"Почему? Вы не можете просто создать связь между ``Person`` и ``Group`` - "
"необходимо указать все необходимые подробности для модели ``Membership``. "
"``add``, ``create`` и присвоение не позволяют указать значения для "
"дополнительных полей, поэтому вы не можете их использовать. Единственный "
"способ - создать экземпляр промежуточной модели."

# f773ee4f86ae46039459463bfaf59dca
#: ../../topics/db/models.txt:529
#, fuzzy
msgid ""
"The :meth:`~django.db.models.fields.related.RelatedManager.remove` method is "
"disabled for similar reasons. For example, if the custom through table "
"defined by the intermediate model does not enforce uniqueness on the "
"``(model1, model2)`` pair, a ``remove()`` call would not provide enough "
"information as to which intermediate model instance should be deleted::"
msgstr ""
"Метод :meth:`~django.db.models.fields.related.RelatedManager.remove` не "
"работает по той же причине. Но вы можете использовать :meth:`~django.db."
"models.fields.related.RelatedManager.clear` для удаления всех связей::"

# f773ee4f86ae46039459463bfaf59dca
#: ../../topics/db/models.txt:543
#, fuzzy
msgid ""
"However, the :meth:`~django.db.models.fields.related.RelatedManager.clear` "
"method can be used to remove all many-to-many relationships for an instance::"
msgstr ""
"Метод :meth:`~django.db.models.fields.related.RelatedManager.remove` не "
"работает по той же причине. Но вы можете использовать :meth:`~django.db."
"models.fields.related.RelatedManager.clear` для удаления всех связей::"

# 2aabe69e896849ac96093b93925d55b1
#: ../../topics/db/models.txt:552
msgid ""
"Once you have established the many-to-many relationships by creating "
"instances of your intermediate model, you can issue queries. Just as with "
"normal many-to-many relationships, you can query using the attributes of the "
"many-to-many-related model::"
msgstr ""
"Добавив несколько связей, создав промежуточную модель, вы захотите выполнить "
"несколько запросов для получения данных. Так же, как и для обычной связи, вы "
"можете получить связанные объекты, используя атрибуты связанных моделей::"

# b60fb9138bc8493c98801261c1a6e503
#: ../../topics/db/models.txt:561
msgid ""
"As you are using an intermediate model, you can also query on its "
"attributes::"
msgstr "Вы можете использовать поле промежуточной модели в запросах::"

# 427a2e35e2034d1e900aad9a7cf3907c
#: ../../topics/db/models.txt:569
msgid ""
"If you need to access a membership's information you may do so by directly "
"querying the ``Membership`` model::"
msgstr "Вы можете получить данные непосредственно из модели ``Membership``::"

# a795841f93634cad9ed43d08a00e8ab2
#: ../../topics/db/models.txt:578
msgid ""
"Another way to access the same information is by querying the :ref:`many-to-"
"many reverse relationship<m2m-reverse-relationships>` from a ``Person`` "
"object::"
msgstr ""
"Другой способ - используя :ref:`обратную связь<m2m-reverse-relationships>` "
"объекта модели ``Person``::"

# 05a03c58509c4fa1a12646acb0676bf6
#: ../../topics/db/models.txt:589
msgid "One-to-one relationships"
msgstr "Связь один-к-одному"

# eeafd424cf734c0ba46cf48407b516c6
#: ../../topics/db/models.txt:591
msgid ""
"To define a one-to-one relationship, use :class:`~django.db.models."
"OneToOneField`. You use it just like any other ``Field`` type: by including "
"it as a class attribute of your model."
msgstr ""
"Для определения связи один-к-одному используется :class:`~django.db.models."
"OneToOneField`. Вы используете его так же, как и другие типы :class:`~django."
"db.models.Field`: добавляя как атрибут в модель."

# 13c42a2e475d4e8ebf25de1c7432016e
#: ../../topics/db/models.txt:595
msgid ""
"This is most useful on the primary key of an object when that object "
"\"extends\" another object in some way."
msgstr ""
"Чаще всего связь одни-к-одному используется для первичного ключа для модели, "
"которая \"расширяет\" другую модель."

# c0f2f9040446444284c156f03017df1a
#: ../../topics/db/models.txt:598
msgid ""
":class:`~django.db.models.OneToOneField` requires a positional argument: the "
"class to which the model is related."
msgstr ""
"Для :class:`~django.db.models.OneToOneField` необходимо указать обязательный "
"позиционный аргумент: класс связанной модели."

# 76cc78f3a15f4fd8bcb3f3b7c4621e78
#: ../../topics/db/models.txt:601
msgid ""
"For example, if you were building a database of \"places\", you would build "
"pretty standard stuff such as address, phone number, etc. in the database. "
"Then, if you wanted to build a database of restaurants on top of the places, "
"instead of repeating yourself and replicating those fields in the "
"``Restaurant`` model, you could make ``Restaurant`` have a :class:`~django."
"db.models.OneToOneField` to ``Place`` (because a restaurant \"is a\" place; "
"in fact, to handle this you'd typically use :ref:`inheritance <model-"
"inheritance>`, which involves an implicit one-to-one relation)."
msgstr ""
"Например, вам необходима база данных \"строений\", обычным дело будет "
"добавить адрес, номер телефона и др. в базу данных. После, если вы захотите "
"дополнить базу данных строений ресторанами, вместо того, чтобы повторять "
"поля в модели ``Restaurant``, вы можете добавить в модель ``Restaurant`` "
"поле :class:`~django.db.models.OneToOneField` связанное с ``Place`` (т.к. "
"ресторан \"это\" строение; вы можете использовать :ref:`наследование моделей "
"<model-inheritance>`, которое на самом деле работает через связь один-к-"
"одному)."

# 138b125c709b4faca7e7ee77a70a49d2
#: ../../topics/db/models.txt:611
#, fuzzy
msgid ""
"As with :class:`~django.db.models.ForeignKey`, a :ref:`recursive "
"relationship <recursive-relationships>` can be defined and :ref:`references "
"to as-yet undefined models <lazy-relationships>` can be made."
msgstr ""
"Так же как и для :class:`~django.db.models.ForeignKey`, вы можете "
"использовать :ref:`рекурсивную связь <recursive-relationships>` и :ref:"
"`связь на себя <lazy-relationships>`; смотрите :ref:`раздел о полях "
"модели<ref-onetoone>`."

# aae53d0b31084bcd986ee9dbd5caa01a
#: ../../topics/db/models.txt:617
msgid ""
"See the :doc:`One-to-one relationship model example </topics/db/examples/"
"one_to_one>` for a full example."
msgstr ""
"Примеры можно найти в :doc:`этом разделе </topics/db/examples/one_to_one>`."

# 6fd7fa8fa67044c7baf84e5a0a7e37a5
#: ../../topics/db/models.txt:620
#, fuzzy
msgid ""
":class:`~django.db.models.OneToOneField` fields also accept an optional :"
"attr:`~django.db.models.OneToOneField.parent_link` argument."
msgstr ""
":class:`~django.db.models.OneToOneField` также принимает один не "
"обязательный аргумент ``parent_link`` описанный в :ref:`спецификации поля "
"<ref-onetoone>`."

# 7d4d187042824b49ab745dfed9a3ef91
#: ../../topics/db/models.txt:623
msgid ""
":class:`~django.db.models.OneToOneField` classes used to automatically "
"become the primary key on a model. This is no longer true (although you can "
"manually pass in the :attr:`~django.db.models.Field.primary_key` argument if "
"you like). Thus, it's now possible to have multiple fields of type :class:"
"`~django.db.models.OneToOneField` on a single model."
msgstr ""
"Раньше :class:`~django.db.models.OneToOneField` автоматически использовались "
"как первичный ключ. Теперь это не так (но вы можете сами указать это "
"используя аргумент :attr:`~django.db.models.Field.primary_key`). Таким "
"образом вы можете иметь несколько связей :class:`~django.db.models."
"OneToOneField` к одной модели."

# 681baad9d12b42888bab919eabd7ca0d
#: ../../topics/db/models.txt:630
msgid "Models across files"
msgstr "Связь моделей из разных модулей"

# 79ba3b54878a47728c21af58a1e01937
#: ../../topics/db/models.txt:632
msgid ""
"It's perfectly OK to relate a model to one from another app. To do this, "
"import the related model at the top of the file where your model is defined. "
"Then, just refer to the other model class wherever needed. For example::"
msgstr ""
"Нормальная практика использовать связи для моделей из разных приложений. Для "
"этого, импортируйте связанную модель перед определением главной модели и "
"используйте как аргумент для поля. Например::"

# 764f877100a24ad48b840a4a93d7fd0a
#: ../../topics/db/models.txt:649
msgid "Field name restrictions"
msgstr "Ограничения при выборе названия поля"

# 8cc4348dc8784a1c91d7b5ae97a5fceb
#: ../../topics/db/models.txt:651
msgid "Django places only two restrictions on model field names:"
msgstr "В Django  существует только два ограничения:"

# aaade55d5f354f9c84a3cfd4bd7465df
#: ../../topics/db/models.txt:653
msgid ""
"A field name cannot be a Python reserved word, because that would result in "
"a Python syntax error. For example::"
msgstr ""
"Название поля не может быть слово зарезервированное Python, т.к. это "
"приведет к синтаксической ошибке. Например::"

# 685bdf35b8c548b48245e5c864f05d70
#: ../../topics/db/models.txt:659
msgid ""
"A field name cannot contain more than one underscore in a row, due to the "
"way Django's query lookup syntax works. For example::"
msgstr ""
"Название поля не может содержать несколько нижних подчеркиваний(_) подряд, т."
"к. такой подход Django использует для формирования запросов. Например::"

# 063723c60f4c476baa6cc284e835cfe2
#: ../../topics/db/models.txt:665
msgid ""
"These limitations can be worked around, though, because your field name "
"doesn't necessarily have to match your database column name. See the :attr:"
"`~Field.db_column` option."
msgstr ""
"Эти ограничения не сложно соблюдать т.к. название поля не обязано быть таким "
"же, как и название колонки в базе данных. Смотрите аргумент :attr:`~Field."
"db_column`."

# 063bd2328bf845cba2bf8daa8358dde7
#: ../../topics/db/models.txt:669
msgid ""
"SQL reserved words, such as ``join``, ``where`` or ``select``, *are* allowed "
"as model field names, because Django escapes all database table names and "
"column names in every underlying SQL query. It uses the quoting syntax of "
"your particular database engine."
msgstr ""
"Зарезервированные SQL слова, такие как ``join``, ``where`` или ``select``, "
"*можно* использовать как название поля, потому что Django экранирует "
"название таблиц и полей для каждого SQL запроса. Используются \"кавычки"
"\"(quoting syntax) базы данных, которую вы используете."

# 7959db8cc3c44bcf92bbf467f1e29e79
#: ../../topics/db/models.txt:675
msgid "Custom field types"
msgstr "Собственные типы полей"

# 22220a441b0346c8bcd7ff01a5267134
#: ../../topics/db/models.txt:677
msgid ""
"If one of the existing model fields cannot be used to fit your purposes, or "
"if you wish to take advantage of some less common database column types, you "
"can create your own field class. Full coverage of creating your own fields "
"is provided in :doc:`/howto/custom-model-fields`."
msgstr ""
"Если ни одно существующее поле не удовлетворяет вашим потребностям, или вам "
"необходимо использовать какие-либо особенности поля, присущие определенной "
"базе данных - вы можете создать собственный тип поля. Подробнее вы можете "
"прочитать в :doc:`/howto/custom-model-fields`."

# d850d8a34b6e4c588f995d4a4362050e
#: ../../topics/db/models.txt:685
#, fuzzy
msgid "``Meta`` options"
msgstr "Мета-настройки"

# 34d4641a8f094c999be871cdb639fbc9
#: ../../topics/db/models.txt:687
msgid "Give your model metadata by using an inner ``class Meta``, like so::"
msgstr ""
"Дополнительные настройки для модели можно определить через ``class Meta``, "
"например::"

# faf9ebbe142540338782c6ea0d9827b1
#: ../../topics/db/models.txt:698
msgid ""
"Model metadata is \"anything that's not a field\", such as ordering options "
"(:attr:`~Options.ordering`), database table name (:attr:`~Options."
"db_table`), or human-readable singular and plural names (:attr:`~Options."
"verbose_name` and :attr:`~Options.verbose_name_plural`). None are required, "
"and adding ``class Meta`` to a model is completely optional."
msgstr ""
"Сюда включено \"все что не является полем\", например, настройка сортировки "
"по-умолчанию (:attr:`~Options.ordering`), название таблицы базы данных (:"
"attr:`~Options.db_table`), или human-readable название в единственной и "
"множественной форме(:attr:`~Options.verbose_name` и :attr:`~Options."
"verbose_name_plural`). Все они не обязательны и  добавлять ``class Meta`` "
"тоже не обязательно."

# f49fb48c1ce346b0b2a347fd900cf580
#: ../../topics/db/models.txt:704
msgid ""
"A complete list of all possible ``Meta`` options can be found in the :doc:"
"`model option reference </ref/models/options>`."
msgstr ""
"Полный список опций для ``Meta`` можно найти в :doc:`разделе о настройках "
"модели </ref/models/options>`."

# 681baad9d12b42888bab919eabd7ca0d
#: ../../topics/db/models.txt:710
msgid "Model attributes"
msgstr "Атрибуты модели"

# aee664e8fa7e434085593dc480fb388f
#: ../../topics/db/models.txt:719
#, fuzzy
msgid "objects"
msgstr "``objects``"

# 4c1091a8511840c38db5a11a98f0c9e1
#: ../../topics/db/models.txt:713
msgid ""
"The most important attribute of a model is the :class:`~django.db.models."
"Manager`. It's the interface through which database query operations are "
"provided to Django models and is used to :ref:`retrieve the instances "
"<retrieving-objects>` from the database. If no custom ``Manager`` is "
"defined, the default name is :attr:`~django.db.models.Model.objects`. "
"Managers are only accessible via model classes, not the model instances."
msgstr ""
"Самый важный атрибут модели -- :class:`~django.db.models.Manager`. Это "
"интерфейс, через который Django выполняет запросы к базе данных и :ref:"
"`получает объекты <retrieving-objects>`. Если собственный ``Manager`` не "
"указан, название по умолчанию будет :attr:`~django.db.models.Model.objects`. "
"Менеджеры доступны только через класс модели, они не доступны в экземплярах "
"модели."

# fa822af1e2764fc3a663e0cb71e6749f
#: ../../topics/db/models.txt:724
msgid "Model methods"
msgstr "Методы модели"

# 08563dae2c0241a5b38cce4c02decffd
#: ../../topics/db/models.txt:726
msgid ""
"Define custom methods on a model to add custom \"row-level\" functionality "
"to your objects. Whereas :class:`~django.db.models.Manager` methods are "
"intended to do \"table-wide\" things, model methods should act on a "
"particular model instance."
msgstr ""
"Для добавления функционала работы с экземпляром модели(\"row-level\" "
"functionality), необходимо просто добавить метод в модель. В то время, как "
"методы :class:`~django.db.models.Manager` работают с таблицей, методы модели "
"работают с конкретной записью в таблице."

# 45db4ef9bc074e53b225b21b9a1f5e97
#: ../../topics/db/models.txt:730
msgid ""
"This is a valuable technique for keeping business logic in one place -- the "
"model."
msgstr ""
"Это хороший подход для хранения бизнес логики работы с данными в одном месте "
"-- модели."

# a26149fff6844b05955d8a61d935ac9b
#: ../../topics/db/models.txt:733
msgid "For example, this model has a few custom methods::"
msgstr "Например, эта модель содержит два дополнительных метода::"

# a1b3a0a7e9d541e1add1239f358c1938
#: ../../topics/db/models.txt:757
msgid "The last method in this example is a :term:`property`."
msgstr "Последний метод в примере - свойство(:term:`property`)."

# d0e9c227556e4bb5a4f98ea8d82111f3
#: ../../topics/db/models.txt:759
msgid ""
"The :doc:`model instance reference </ref/models/instances>` has a complete "
"list of :ref:`methods automatically given to each model <model-instance-"
"methods>`. You can override most of these -- see `overriding predefined "
"model methods`_, below -- but there are a couple that you'll almost always "
"want to define:"
msgstr ""
":doc:`Раздел о моделях </ref/models/instances>` содержит полный список :ref:"
"`методов, автоматически добавляемых в модель<model-instance-methods>`. Вы "
"можете переопределить большинство из них -- смотрите :ref:`overriding-model-"
"methods`, -- но есть методы, которые вы чаще всего определите для каждой "
"модели:"

# a1852719712d42bf9217ce869b8c4423
#: ../../topics/db/models.txt:772
#, fuzzy
msgid "__str__() (Python 3)"
msgstr ":meth:`~Model.__str__` (Python 3)"

# e9196a373f544e6c80ad9fce97ee5815
#: ../../topics/db/models.txt:765
msgid ""
"A Python \"magic method\" that returns a unicode \"representation\" of any "
"object. This is what Python and Django will use whenever a model instance "
"needs to be coerced and displayed as a plain string. Most notably, this "
"happens when you display an object in an interactive console or in the admin."
msgstr ""
"\"Волшебный метод\" Python, который возвращает unicode \"представление\" "
"объекта. Это то, что Python и Django используют для отображения объекта как "
"строки, обычно в консоли, интерфейсе администратора или шаблоне."

# cba433c5445c47f9a8b2b1efb3171926
#: ../../topics/db/models.txt:771
msgid ""
"You'll always want to define this method; the default isn't very helpful at "
"all."
msgstr ""
"Желательно определить этот метод, т.к. значение по умолчанию не слишком "
"привлекательно."

# a1852719712d42bf9217ce869b8c4423
#: ../../topics/db/models.txt:775
#, fuzzy
msgid "__unicode__() (Python 2)"
msgstr "``__unicode__()`` (Python 2)"

# 71a7f67daae646fa9b446f55f7339378
#: ../../topics/db/models.txt:775
msgid "Python 2 equivalent of ``__str__()``."
msgstr "Python 2 аналог ``__str__()``."

# eac3ccffeaf9495b9795afbbbe64d947
#: ../../topics/db/models.txt:783
#, fuzzy
msgid "get_absolute_url()"
msgstr ":meth:`~Model.get_absolute_url`"

# 139ba73fd754467a82bbb8428892dbab
#: ../../topics/db/models.txt:778
msgid ""
"This tells Django how to calculate the URL for an object. Django uses this "
"in its admin interface, and any time it needs to figure out a URL for an "
"object."
msgstr ""
"Этот метод указывает Django, какой URL использовать для объекта. Django "
"использует его в интерфейсе администратора и каждый раз, когда необходимо "
"получить URL для объекта."

# f175cb7402ab461bace00afdd5b270d8
#: ../../topics/db/models.txt:782
msgid ""
"Any object that has a URL that uniquely identifies it should define this "
"method."
msgstr "Каждый объект, который имеет уникальный URL должен иметь этот метод."

# 3dd5a207bfbf437396c8604a1fe69802
#: ../../topics/db/models.txt:788
msgid "Overriding predefined model methods"
msgstr "Переопределение методов модели"

# 6d0794484edf4c9189acdefb810db510
#: ../../topics/db/models.txt:790
msgid ""
"There's another set of :ref:`model methods <model-instance-methods>` that "
"encapsulate a bunch of database behavior that you'll want to customize. In "
"particular you'll often want to change the way :meth:`~Model.save` and :meth:"
"`~Model.delete` work."
msgstr ""
"Существуют другие :ref:`методы модели <model-instance-methods>`, которые "
"инкапсулируют работу с базой данных. Чаще всего вы захотите переопределить "
"метод :meth:`~Model.save` и :meth:`~Model.delete`."

# 551d2de781bd4398921ff92f6fd255c2
#: ../../topics/db/models.txt:795
msgid ""
"You're free to override these methods (and any other model method) to alter "
"behavior."
msgstr "Вы можете переопределить эти методы и любые другие методы модели."

# c557fde6a64646968696f2ceb861538c
#: ../../topics/db/models.txt:798
msgid ""
"A classic use-case for overriding the built-in methods is if you want "
"something to happen whenever you save an object. For example (see :meth:"
"`~Model.save` for documentation of the parameters it accepts)::"
msgstr ""
"Распространенная задача, это выполнить какое-либо действие после сохранения "
"объекта. Например (принимаемые параметры смотрите :meth:`~Model.save`)::"

# 63719ba064b64de4bddbf512e9d641e9
#: ../../topics/db/models.txt:813
msgid "You can also prevent saving::"
msgstr "Вы также можете отменить сохранение::"

# eb29513fcdcf442495aafc8fb5652c63
#: ../../topics/db/models.txt:827
msgid ""
"It's important to remember to call the superclass method -- that's that "
"``super(Blog, self).save(*args, **kwargs)`` business -- to ensure that the "
"object still gets saved into the database. If you forget to call the "
"superclass method, the default behavior won't happen and the database won't "
"get touched."
msgstr ""
"Не забывайте вызывать родительский метод -- ``super(Blog, self).save(*args, "
"**kwargs)`` -- чтобы объект корректно сохранился в базе данных. Если этого "
"не сделать, данные не будут сохранены в базе данных."

# 9ebe267dbb764cff9f0f33b2057bc2d6
#: ../../topics/db/models.txt:833
msgid ""
"It's also important that you pass through the arguments that can be passed "
"to the model method -- that's what the ``*args, **kwargs`` bit does. Django "
"will, from time to time, extend the capabilities of built-in model methods, "
"adding new arguments. If you use ``*args, **kwargs`` in your method "
"definitions, you are guaranteed that your code will automatically support "
"those arguments when they are added."
msgstr ""
"Также не забывайте о аргументах, которые принимают встроенные методы -- вам "
"поможет ``*args`` и ``**kwargs``. Django иногда использует дополнительные "
"аргументы для методов. Используя ``*args, **kwargs``, можно быть уверенным, "
"что все аргументы будут приняты."

# 63a55c4a7bc94090878d7b7a78d3eb8b
#: ../../topics/db/models.txt:840
msgid "Overridden model methods are not called on bulk operations"
msgstr ""
"Переопределенные методы модели не вызываются при множественных "
"операциях(bulk)"

# d10ca11283834eaabf10de7c7c8bdf81
#: ../../topics/db/models.txt:842
msgid ""
"Note that the :meth:`~Model.delete()` method for an object is not "
"necessarily called when :ref:`deleting objects in bulk using a QuerySet "
"<topics-db-queries-delete>` or as a result of a :attr:`cascading delete "
"<django.db.models.ForeignKey.on_delete>`. To ensure customized delete logic "
"gets executed, you can use :data:`~django.db.models.signals.pre_delete` and/"
"or :data:`~django.db.models.signals.post_delete` signals."
msgstr ""
"Учтите, метод :meth:`~Model.delete()` не обязательно вызывается при :ref:"
"`массовом удалении объектов через QuerySet<topics-db-queries-delete>`, или "
"как результат :attr:`каскадного удаления <django.db.models.ForeignKey."
"on_delete>`. Для гарантированного выполнения действий после удаления объекта "
"используйте сигналы :data:`~django.db.models.signals.pre_delete` и/или :data:"
"`~django.db.models.signals.post_delete`."

# 8a5aa20983df4612807fbbc1867f5c0d
#: ../../topics/db/models.txt:850
msgid ""
"Unfortunately, there isn't a workaround when :meth:`creating<django.db."
"models.query.QuerySet.bulk_create>` or :meth:`updating<django.db.models."
"query.QuerySet.update>` objects in bulk, since none of :meth:`~Model."
"save()`, :data:`~django.db.models.signals.pre_save`, and :data:`~django.db."
"models.signals.post_save` are called."
msgstr ""
"К сожалению, вы не сможете изменить логику сохранения объектов при "
"использовании :meth:`creating<django.db.models.query.QuerySet.bulk_create>` "
"или :meth:`updating<django.db.models.query.QuerySet.update>`, так как :meth:"
"`~Model.save()`, :data:`~django.db.models.signals.pre_save` и :data:`~django."
"db.models.signals.post_save` не будут выполнены."

# 4b5c4b51c1b04b4f9046c09aa3002bf5
#: ../../topics/db/models.txt:858
msgid "Executing custom SQL"
msgstr "Выполнение SQL запросов"

# 744146f5d4c943798a8e763fff6b89ab
#: ../../topics/db/models.txt:860
msgid ""
"Another common pattern is writing custom SQL statements in model methods and "
"module-level methods. For more details on using raw SQL, see the "
"documentation on :doc:`using raw SQL</topics/db/sql>`."
msgstr ""
"Запросы на чистом SQL лучше выполнять в методе модели. Подробнее о SQL-"
"запросах можно прочитать в :doc:`разделе о запросах на чистом SQL</topics/db/"
"sql>`."

# 240cdeffffdc4b5a8b0878e4d5c68813
#: ../../topics/db/models.txt:867
msgid "Model inheritance"
msgstr "Наследование моделей"

# 7082901f00d346eebb4143803089353a
#: ../../topics/db/models.txt:869
msgid ""
"Model inheritance in Django works almost identically to the way normal class "
"inheritance works in Python, but the basics at the beginning of the page "
"should still be followed. That means the base class should subclass :class:"
"`django.db.models.Model`."
msgstr ""
"Наследование моделей в Django работает почти так же, как и наследование "
"классов в Python, но следует соблюдать правила, описанные выше. Это "
"означает, что базовый класс должен наследоваться от :class:`django.db.models."
"Model`."

# 5d0f522f2dad47f1a79fff497061d9cf
#: ../../topics/db/models.txt:874
msgid ""
"The only decision you have to make is whether you want the parent models to "
"be models in their own right (with their own database tables), or if the "
"parents are just holders of common information that will only be visible "
"through the child models."
msgstr ""
"Единственное, что вам нужно определить, это должна ли родительская модель "
"быть независимой моделью (с собственной таблицей в базе данных), или же "
"родительская модель просто контейнер для хранения информации, доступной "
"только через дочерние модели."

# 622d456b641c456f93db612633dc82e6
#: ../../topics/db/models.txt:879
msgid "There are three styles of inheritance that are possible in Django."
msgstr "Существует три вида наследования моделей в Django."

# 387406a3478b426ba32b62fbab5dcd7c
#: ../../topics/db/models.txt:881
msgid ""
"Often, you will just want to use the parent class to hold information that "
"you don't want to have to type out for each child model. This class isn't "
"going to ever be used in isolation, so :ref:`abstract-base-classes` are what "
"you're after."
msgstr ""
"Чаще всего вы будете использовать родительскую модель для хранения общих "
"полей, чтобы не добавлять их в каждую дочернюю модель. Если вы не "
"собираетесь использовать его как независимую модель -- :ref:`abstract-base-"
"classes` то, что вам нужно."

# edd79a2639a242fc913ee01e878dd3fe
#: ../../topics/db/models.txt:885
msgid ""
"If you're subclassing an existing model (perhaps something from another "
"application entirely) and want each model to have its own database table, :"
"ref:`multi-table-inheritance` is the way to go."
msgstr ""
"Если родительская модель независимая(возможно, из другого приложения) и "
"должна храниться в отдельной таблице, :ref:`multi-table-inheritance` то, что "
"вам нужно."

# 7ffe0a41523d4f0bafa7688dee9ebb35
#: ../../topics/db/models.txt:888
msgid ""
"Finally, if you only want to modify the Python-level behavior of a model, "
"without changing the models fields in any way, you can use :ref:`proxy-"
"models`."
msgstr ""
"Если же вы хотите переопределить поведение модели на уровне Python, не меняя "
"структуры базы данных, вы можете использовать :ref:`proxy-models`."

# 1e0180e04bb341d7a61c669ca83d5ed6
#: ../../topics/db/models.txt:895
msgid "Abstract base classes"
msgstr "Абстрактные модели"

# 7c5d668e42b5464eac3bfd734efbdd08
#: ../../topics/db/models.txt:897
msgid ""
"Abstract base classes are useful when you want to put some common "
"information into a number of other models. You write your base class and put "
"``abstract=True`` in the :ref:`Meta <meta-options>` class. This model will "
"then not be used to create any database table. Instead, when it is used as a "
"base class for other models, its fields will be added to those of the child "
"class. It is an error to have fields in the abstract base class with the "
"same name as those in the child (and Django will raise an exception)."
msgstr ""
"Абстрактные модели удобны при определении общих, для нескольких моделей, "
"полей. Вы создаете базовую модель и добавляете ``abstract=True`` в класс :"
"ref:`Meta <meta-options>`. Для этой модели не будет создана таблица в базе "
"данных. Используя эту модель как родительскую для другой модели - все ее "
"поля будут добавлены в таблицу в базе данных для этой модели. Нельзя "
"использовать поля с одинаковыми названиями в дочерней и родительской моделях "
"(Django вызовет исключение)."

# 9383f0ace70c4e9da05fc5ba2076b8fc
#: ../../topics/db/models.txt:906
msgid "An example::"
msgstr "Например::"

# a9abb69d7ac84aa2a533700033163851
#: ../../topics/db/models.txt:920
msgid ""
"The ``Student`` model will have three fields: ``name``, ``age`` and "
"``home_group``. The ``CommonInfo`` model cannot be used as a normal Django "
"model, since it is an abstract base class. It does not generate a database "
"table or have a manager, and cannot be instantiated or saved directly."
msgstr ""
"Модель ``Student`` содержит три поля: ``name``, ``age`` и ``home_group``. "
"Модель ``CommonInfo`` не может использоваться как обычная модель Django, т."
"к. это абстрактный класс. Она не имеет собственной таблицы в базе данных и "
"не имеет менеджера, нельзя создать экземпляр модели и сохранить его в базе "
"данных."

# 682792d1ed594e50a47bf6e3df554517
#: ../../topics/db/models.txt:925
#, fuzzy
msgid ""
"For many uses, this type of model inheritance will be exactly what you want. "
"It provides a way to factor out common information at the Python level, "
"while still only creating one database table per child model at the database "
"level."
msgstr ""
"В большинстве случаев вы будете использовать этот тип наследования моделей. "
"Он позволяет на уровне Python разделить общие данные, используя в то же "
"время одну таблицу в базе данных."

# 9598bd584a164731a56215b6679ba257
#: ../../topics/db/models.txt:930
msgid "``Meta`` inheritance"
msgstr "Наследование класса ``Meta``"

# 2fb27a269e76447caa3949fb45a940dc
#: ../../topics/db/models.txt:932
msgid ""
"When an abstract base class is created, Django makes any :ref:`Meta <meta-"
"options>` inner class you declared in the base class available as an "
"attribute. If a child class does not declare its own :ref:`Meta <meta-"
"options>` class, it will inherit the parent's :ref:`Meta <meta-options>`. If "
"the child wants to extend the parent's :ref:`Meta <meta-options>` class, it "
"can subclass it. For example::"
msgstr ""
"После создания абстрактной модели, Django добавляет класс :ref:`Meta <meta-"
"options>` как атрибут класса. Если дочерний класс не определяет собственный "
"класс :ref:`Meta <meta-options>`, он унаследует родительский класс :ref:"
"`Meta <meta-options>`. Если дочерняя модель хочет расширить родительский :"
"ref:`Meta <meta-options>` класс, она может унаследовать его. Например::"

# 831ac15359c64f668a913c7245b87aa7
#: ../../topics/db/models.txt:951
msgid ""
"Django does make one adjustment to the :ref:`Meta <meta-options>` class of "
"an abstract base class: before installing the :ref:`Meta <meta-options>` "
"attribute, it sets ``abstract=False``. This means that children of abstract "
"base classes don't automatically become abstract classes themselves. Of "
"course, you can make an abstract base class that inherits from another "
"abstract base class. You just need to remember to explicitly set "
"``abstract=True`` each time."
msgstr ""
"Django делает одно изменение в :ref:`Meta <meta-options>` для абстрактной "
"модели: перед добавлением в модель изменяет атрибут ``abstract=False``. Это "
"означает что дочерняя модель, наследуя :ref:`Meta <meta-options>`, не "
"становится сама абстрактной моделью. Конечно вы можете создать абстрактную "
"модель, которая наследуется от другой абстрактной модели. Вам только нужно "
"определить атрибут ``abstract=True``."

# 52859d946dfc415bb502b4234103f595
#: ../../topics/db/models.txt:958
msgid ""
"Some attributes won't make sense to include in the :ref:`Meta <meta-"
"options>` class of an abstract base class. For example, including "
"``db_table`` would mean that all the child classes (the ones that don't "
"specify their own :ref:`Meta <meta-options>`) would use the same database "
"table, which is almost certainly not what you want."
msgstr ""
"Некоторые атрибуты не имеет смысла добавлять в класс :ref:`Meta <meta-"
"options>` абстрактной модели. Например, добавление ``db_table`` означает, "
"что каждая дочерняя модель(каждая, которая не определяет свой собственный "
"класс :ref:`Meta <meta-options>`) будет использовать туже таблицу в базе "
"данных, что точно не то, что вам нужно."

# 09581e211daf44158073d27e1b1b4d59
#: ../../topics/db/models.txt:966
#, fuzzy
msgid "Be careful with ``related_name`` and ``related_query_name``"
msgstr "Осторожно с ``related_name``"

# 7077856cb48845cfa1223b1c0b7072c9
#: ../../topics/db/models.txt:968
#, fuzzy
msgid ""
"If you are using :attr:`~django.db.models.ForeignKey.related_name` or :attr:"
"`~django.db.models.ForeignKey.related_query_name` on a ``ForeignKey`` or "
"``ManyToManyField``, you must always specify a *unique* reverse name and "
"query name for the field. This would normally cause a problem in abstract "
"base classes, since the fields on this class are included into each of the "
"child classes, with exactly the same values for the attributes (including :"
"attr:`~django.db.models.ForeignKey.related_name` and :attr:`~django.db."
"models.ForeignKey.related_query_name`) each time."
msgstr ""
"Используя атрибут :attr:`~django.db.models.ForeignKey.related_name` для "
"``ForeignKey`` или ``ManyToManyField``, вы должны всегда определять "
"*уникальное* название для обратной связи. Это одна из проблем абстрактных "
"моделей, т.к. ее поля будут добавлены в каждой из дочерних моделей, с теми "
"же значениями аргументов (включая :attr:`~django.db.models.ForeignKey."
"related_name`)."

# c9d07202089e4079a0d7f2611b037132
#: ../../topics/db/models.txt:977
#, fuzzy
msgid ""
"To work around this problem, when you are using :attr:`~django.db.models."
"ForeignKey.related_name` or :attr:`~django.db.models.ForeignKey."
"related_query_name` in an abstract base class (only), part of the value "
"should contain ``'%(app_label)s'`` and ``'%(class)s'``."
msgstr ""
"Для решения этой проблемы, добавляя :attr:`~django.db.models.ForeignKey."
"related_name` для абстрактной модели (и только для абстрактной), можно "
"использовать в названии ``'%(app_label)s'`` и ``'%(class)s'``."

# cb082381ac45410ca32aaf390a1ada71
#: ../../topics/db/models.txt:983
msgid ""
"``'%(class)s'`` is replaced by the lower-cased name of the child class that "
"the field is used in."
msgstr ""
"``'%(class)s'`` будет заменен на название дочерней модели, в которой поле "
"используется, в нижнем регистре."

# 59ad42ab31d74b28af6526904a60f533
#: ../../topics/db/models.txt:985
msgid ""
"``'%(app_label)s'`` is replaced by the lower-cased name of the app the child "
"class is contained within. Each installed application name must be unique "
"and the model class names within each app must also be unique, therefore the "
"resulting name will end up being different."
msgstr ""
"``'%(app_label)s'`` будет заменено на название приложения, в котором "
"находится модель, в нижнем регистре. Название приложения должно быть "
"уникальным, так же, как и название модели в приложении, в результате "
"получится уникальное значение атрибута."

# 73355bd1bc6e43fd96353dcc118b6bad
#: ../../topics/db/models.txt:990
msgid "For example, given an app ``common/models.py``::"
msgstr "Например, есть приложение с ``common/models.py``::"

# 42c336bb451a4ea8baee3df5811da3b7
#: ../../topics/db/models.txt:1010
msgid "Along with another app ``rare/models.py``::"
msgstr "И еще другое ``rare/models.py``::"

# 74cf8b09934842baa3363d70abbd01c3
#: ../../topics/db/models.txt:1017
#, fuzzy
msgid ""
"The reverse name of the ``common.ChildA.m2m`` field will be "
"``common_childa_related`` and the reverse query name will be "
"``common_childas``. The reverse name of the ``common.ChildB.m2m`` field will "
"be ``common_childb_related`` and the reverse query name will be "
"``common_childbs``. Finally, the reverse name of the ``rare.ChildB.m2m`` "
"field will be ``rare_childb_related`` and the reverse query name will be "
"``rare_childbs``. It's up to you how you use the ``'%(class)s'`` and "
"``'%(app_label)s'`` portion to construct your related name or related query "
"name but if you forget to use it, Django will raise errors when you perform "
"system checks (or run :djadmin:`migrate`)."
msgstr ""
"Имя обратной связи поля ``common.ChildA.m2m`` будет "
"``common_childa_related``, в то время как для ``common.ChildB.m2m`` будет "
"``common_childb_related``, а для ``rare.ChildB.m2m`` - "
"``rare_childb_related``. Вы можете использовать ``'%(class)s'`` и "
"``'%(app_label)s`` как вам угодно для создания названия,  но если вы "
"забудете о них, Django вызовет исключение при проверке проекта (или при :"
"djadmin:`migrate`)."

# 44e39271527e48f9a91e7937097c7652
#: ../../topics/db/models.txt:1028
msgid ""
"If you don't specify a :attr:`~django.db.models.ForeignKey.related_name` "
"attribute for a field in an abstract base class, the default reverse name "
"will be the name of the child class followed by ``'_set'``, just as it "
"normally would be if you'd declared the field directly on the child class. "
"For example, in the above code, if the :attr:`~django.db.models.ForeignKey."
"related_name` attribute was omitted, the reverse name for the ``m2m`` field "
"would be ``childa_set`` in the ``ChildA`` case and ``childb_set`` for the "
"``ChildB`` field."
msgstr ""
"Не указав :attr:`~django.db.models.ForeignKey.related_name` для абстрактной "
"модели, для обратной связи будет использовано название дочерней модели плюс "
"``'_set'``, так же, как при добавлении связи непосредственно в дочернюю "
"модель. Например, в примере выше, без указания :attr:`~django.db.models."
"ForeignKey.related_name` название для обратной связи поля ``m2m`` будет "
"``childa_set`` для модели ``ChildA`` и ``childb_set`` для ``ChildB``."

#: ../../topics/db/models.txt:1039
msgid ""
"Interpolation of  ``'%(app_label)s'`` and ``'%(class)s'`` for "
"``related_query_name`` was added."
msgstr ""

# d928287b998f41ff8513e1b52abd30a5
#: ../../topics/db/models.txt:1045
msgid "Multi-table inheritance"
msgstr "Multi-table наследование"

# 5b71b61ebf754279add14a1c5195f822
#: ../../topics/db/models.txt:1047
msgid ""
"The second type of model inheritance supported by Django is when each model "
"in the hierarchy is a model all by itself. Each model corresponds to its own "
"database table and can be queried and created individually. The inheritance "
"relationship introduces links between the child model and each of its "
"parents (via an automatically-created :class:`~django.db.models."
"OneToOneField`). For example::"
msgstr ""
"Это второй тип наследования в Django - когда каждая модель в иерархии будет "
"независимой. Каждая модель имеет собственную таблицу в базе данных и может "
"быть использована независимо. Наследование использует связь между "
"родительской и дочерней моделью (через автоматически созданное поле :class:"
"`~django.db.models.OneToOneField`). Например::"

# bfcc95089b0b4b4da0690f517815f25a
#: ../../topics/db/models.txt:1064
msgid ""
"All of the fields of ``Place`` will also be available in ``Restaurant``, "
"although the data will reside in a different database table. So these are "
"both possible::"
msgstr ""
"Все поля ``Place`` будут доступны и в ``Restaurant``, в то время как данные "
"будут храниться в разных таблицах. Например::"

# 3012002ea44449c0a089a10c3d49e6d4
#: ../../topics/db/models.txt:1071
msgid ""
"If you have a ``Place`` that is also a ``Restaurant``, you can get from the "
"``Place`` object to the ``Restaurant`` object by using the lower-case "
"version of the model name::"
msgstr ""
"Если объект ``Place`` является одновременно и ``Restaurant``, вы можете из "
"объекта ``Place`` получить связанный объект ``Restaurant``, используя "
"название модели в нижнем регистре::"

# abc97764e172404b8bd083ab31e6a268
#: ../../topics/db/models.txt:1080
msgid ""
"However, if ``p`` in the above example was *not* a ``Restaurant`` (it had "
"been created directly as a ``Place`` object or was the parent of some other "
"class), referring to ``p.restaurant`` would raise a ``Restaurant."
"DoesNotExist`` exception."
msgstr ""
"Но, если ``p`` в примере выше *не* ``Restaurant`` (был создан "
"непосредственно как объект ``Place`` или был родителем другой модели), "
"использование ``p.restaurant`` вызовет ошибку ``Restaurant.DoesNotExist``."

#: ../../topics/db/models.txt:1085
msgid ""
"The automatically-created :class:`~django.db.models.OneToOneField` on "
"``Restaurant`` that links it to ``Place`` looks like this::"
msgstr ""

# 6fd7fa8fa67044c7baf84e5a0a7e37a5
#: ../../topics/db/models.txt:1093
#, fuzzy
msgid ""
"You can override that field by declaring your own :class:`~django.db.models."
"OneToOneField` with :attr:`parent_link=True <django.db.models.OneToOneField."
"parent_link>` on ``Restaurant``."
msgstr ""
":class:`~django.db.models.OneToOneField` также принимает один не "
"обязательный аргумент ``parent_link`` описанный в :ref:`спецификации поля "
"<ref-onetoone>`."

# 76d9a43a2a0e4fea8c6afa325018a32f
#: ../../topics/db/models.txt:1100
msgid "``Meta`` and multi-table inheritance"
msgstr "``Meta`` и multi-table наследование"

# 993dc2d9294e45a68c2977e9c967fb40
#: ../../topics/db/models.txt:1102
msgid ""
"In the multi-table inheritance situation, it doesn't make sense for a child "
"class to inherit from its parent's :ref:`Meta <meta-options>` class. All "
"the :ref:`Meta <meta-options>` options have already been applied to the "
"parent class and applying them again would normally only lead to "
"contradictory behavior (this is in contrast with the abstract base class "
"case, where the base class doesn't exist in its own right)."
msgstr ""
"При multi-table наследовании, не имеет смысла дочерней модели наследовать :"
"ref:`Meta <meta-options>` от родительской. Все атрибуты класса :ref:`Meta "
"<meta-options>` уже используются в родительской модели и использование их "
"снова может привести к противоречивому поведению (это отличие от абстрактной "
"модели, которая сама по себе не существует как независимая модель)."

# 524b703d562542bc8cdeb00cdd56c14f
#: ../../topics/db/models.txt:1109
msgid ""
"So a child model does not have access to its parent's :ref:`Meta <meta-"
"options>` class. However, there are a few limited cases where the child "
"inherits behavior from the parent: if the child does not specify an :attr:"
"`~django.db.models.Options.ordering` attribute or a :attr:`~django.db.models."
"Options.get_latest_by` attribute, it will inherit these from its parent."
msgstr ""
"Поэтому дочерняя модель не имеет доступа к родительскому классу :ref:`Meta "
"<meta-options>`. Но есть исключения, когда дочерняя модель наследует "
"поведение родительской: если дочерняя модель не определяет атрибут :attr:"
"`~django.db.models.Options.ordering` или :attr:`~django.db.models.Options."
"get_latest_by`, они будут унаследованы."

# 06e77dc6db65453eb16d86cfddfc8175
#: ../../topics/db/models.txt:1116
msgid ""
"If the parent has an ordering and you don't want the child to have any "
"natural ordering, you can explicitly disable it::"
msgstr ""
"Если родительская модель определяет сортировку, но вы не хотите ее "
"наследовать в дочерней модели, вы можете указать это таким способом::"

# ea60945ee09f4f0aa61a920d6036973e
#: ../../topics/db/models.txt:1126
msgid "Inheritance and reverse relations"
msgstr "Наследование и обратные связи"

# c11a08bb6aef4be7b7e4b74513b1d4b5
#: ../../topics/db/models.txt:1128
msgid ""
"Because multi-table inheritance uses an implicit :class:`~django.db.models."
"OneToOneField` to link the child and the parent, it's possible to move from "
"the parent down to the child, as in the above example. However, this uses up "
"the name that is the default :attr:`~django.db.models.ForeignKey."
"related_name` value for :class:`~django.db.models.ForeignKey` and :class:"
"`~django.db.models.ManyToManyField` relations.  If you are putting those "
"types of relations on a subclass of the parent model, you **must** specify "
"the :attr:`~django.db.models.ForeignKey.related_name` attribute on each such "
"field. If you forget, Django will raise a validation error."
msgstr ""
"Т.к. multi-table наследование использует :class:`~django.db.models."
"OneToOneField` для связи родительской и дочерней модели, возможно из "
"родительской модели получить дочернюю, как это показано в примере выше. "
"Используется название по умолчанию для атрибута :attr:`~django.db.models."
"ForeignKey.related_name` в :class:`~django.db.models.ForeignKey` и :class:"
"`~django.db.models.ManyToManyField`.  Если вы используете такие связи на "
"дочернюю модель с аналогичным предком, вы **должны** определить :attr:"
"`~django.db.models.ForeignKey.related_name` для каждого такого поля. Иначе "
"Django вызовет исключение."

# b6bb8021f39c4c9ebb8b43d8016066a0
#: ../../topics/db/models.txt:1140
msgid ""
"For example, using the above ``Place`` class again, let's create another "
"subclass with a :class:`~django.db.models.ManyToManyField`::"
msgstr ""
"Например, используя ``Place`` определенную выше, создадим еще одну дочернюю "
"модель с :class:`~django.db.models.ManyToManyField`::"

# e378397b83114d8191b86beffd88ec32
#: ../../topics/db/models.txt:1146
msgid "This results in the error::"
msgstr "Это приведет к ошибке::"

# ac4c1c7c9d5f4e59a9d6ac7079852322
#: ../../topics/db/models.txt:1154
msgid ""
"Adding ``related_name`` to the ``customers`` field as follows would resolve "
"the error: ``models.ManyToManyField(Place, related_name='provider')``."
msgstr ""
"Добавление ``related_name`` для поля ``customers`` -- ``models."
"ManyToManyField(Place, related_name='provider')`` -- решит эту проблему."

# 6b7c685d836847928a3a0395a90ac4ed
#: ../../topics/db/models.txt:1158
msgid "Specifying the parent link field"
msgstr "Определение связи к родительской модели"

# 3b342bbc60db458dbe652238a4c13d0e
#: ../../topics/db/models.txt:1160
msgid ""
"As mentioned, Django will automatically create a :class:`~django.db.models."
"OneToOneField` linking your child class back to any non-abstract parent "
"models. If you want to control the name of the attribute linking back to the "
"parent, you can create your own :class:`~django.db.models.OneToOneField` and "
"set :attr:`parent_link=True <django.db.models.OneToOneField.parent_link>` to "
"indicate that your field is the link back to the parent class."
msgstr ""
"Как уже упоминалось, Django самостоятельно создает :class:`~django.db.models."
"OneToOneField` для связи дочерней модели с каждой родительской не "
"абстрактной моделью. Если вы хотите определять имя обратной связи для "
"родительской модели, вы можете создать собственный :class:`~django.db.models."
"OneToOneField` с :attr:`parent_link=True <django.db.models.OneToOneField."
"parent_link>` чтобы указать, что это поле является связью с родительской "
"моделью."

# c047d5ee744642dbb949a9cba0dc4ad1
#: ../../topics/db/models.txt:1171
msgid "Proxy models"
msgstr "Proxy-модели"

# 30fe4cdf231d46bfa5caafbe188cac13
#: ../../topics/db/models.txt:1173
msgid ""
"When using :ref:`multi-table inheritance <multi-table-inheritance>`, a new "
"database table is created for each subclass of a model. This is usually the "
"desired behavior, since the subclass needs a place to store any additional "
"data fields that are not present on the base class. Sometimes, however, you "
"only want to change the Python behavior of a model -- perhaps to change the "
"default manager, or add a new method."
msgstr ""
"При использовании :ref:`multi-table наследования <multi-table-inheritance>`, "
"будет создана новая таблица в базе данных. Это обязательное требование, т.к. "
"дочерней модели необходимо хранить дополнительные поля. Иногда вам "
"необходимо изменить поведение модели на уровне Python -- переопределить "
"менеджер по умолчанию или добавить новые методы."

# ffe67274918b4f42bec162a1029b5566
#: ../../topics/db/models.txt:1180
msgid ""
"This is what proxy model inheritance is for: creating a *proxy* for the "
"original model. You can create, delete and update instances of the proxy "
"model and all the data will be saved as if you were using the original (non-"
"proxied) model. The difference is that you can change things like the "
"default model ordering or the default manager in the proxy, without having "
"to alter the original."
msgstr ""
"Вот для чего используют proxy-модель: создать *proxy* для оригинальной "
"модели. Вы можете создать, изменить или обновить объект proxy модели и все "
"изменения будут сохранены так же, как и при изменении оригинальной(non-"
"proxied) модели. Разница в том, что вы можете изменить сортировку по-"
"умолчанию или менеджер по умолчанию в proxy-модели, без изменения "
"оригинальной модели."

# c0d6200a93274980b6e99385b38469aa
#: ../../topics/db/models.txt:1187
msgid ""
"Proxy models are declared like normal models. You tell Django that it's a "
"proxy model by setting the :attr:`~django.db.models.Options.proxy` attribute "
"of the ``Meta`` class to ``True``."
msgstr ""
"Proxy-модели создаются так же, как и обычная модель. Указать что это proxy-"
"модель можно установив атрибут :attr:`~django.db.models.Options.proxy` в "
"классе ``Meta`` в ``True``."

# 8a3d40b42a1c440db013b79f03a1516a
#: ../../topics/db/models.txt:1191
msgid ""
"For example, suppose you want to add a method to the ``Person`` model. You "
"can do it like this::"
msgstr ""
"Например, вам нужно добавить метод в модель `Person``. Вы можете сделать это "
"так::"

# 2ba71b3e967d4f1890f490234bf13c38
#: ../../topics/db/models.txt:1207
msgid ""
"The ``MyPerson`` class operates on the same database table as its parent "
"``Person`` class. In particular, any new instances of ``Person`` will also "
"be accessible through ``MyPerson``, and vice-versa::"
msgstr ""
"Модель ``MyPerson`` использует ту же таблицу в базе данных, что и класс "
"``Person``. Также каждый новый экземпляр модели ``Person``` будет доступен "
"через модель ``MyPerson``, и наоборот::"

# 1916078fe747413c8ffb17a913e198a5
#: ../../topics/db/models.txt:1215
msgid ""
"You could also use a proxy model to define a different default ordering on a "
"model. You might not always want to order the ``Person`` model, but "
"regularly order by the ``last_name`` attribute when you use the proxy. This "
"is easy::"
msgstr ""
"Вы также можете использовать proxy модель для определения различной "
"сортировки по умолчанию. Модель ``Person`` не имеет сортировки по умолчанию "
"(намеренно; сортировка трудоемкая операция, и мы не хотим ее использовать "
"при каждом доступе к данным о пользователях). Возможно вы хотите сортировать "
"по полю ``last_name`` при использовании proxy-модели. Это просто::"

# d3a69b9ddecc4ce3a29baf46d1b6e743
#: ../../topics/db/models.txt:1224
msgid ""
"Now normal ``Person`` queries will be unordered and ``OrderedPerson`` "
"queries will be ordered by ``last_name``."
msgstr ""
"Теперь запросы через ``Person`` будут не отсортированы а для модели "
"``OrderedPerson``  будут отсортированы по полю ``last_name``."

#: ../../topics/db/models.txt:1227
msgid ""
"Proxy models inherit ``Meta`` attributes :ref:`in the same way as regular "
"models <meta-and-multi-table-inheritance>`."
msgstr ""

# a6ca4b8252474f108c6dd2ebac5f62d8
#: ../../topics/db/models.txt:1231
#, fuzzy
msgid "``QuerySet``\\s still return the model that was requested"
msgstr "QuerySets возвращает объекты запрашиваемого типа"

# 0b62b0db98e84e6cb3d6d587f31ca6af
#: ../../topics/db/models.txt:1233
msgid ""
"There is no way to have Django return, say, a ``MyPerson`` object whenever "
"you query for ``Person`` objects. A queryset for ``Person`` objects will "
"return those types of objects. The whole point of proxy objects is that code "
"relying on the original ``Person`` will use those and your own code can use "
"the extensions you included (that no other code is relying on anyway). It is "
"not a way to replace the ``Person`` (or any other) model everywhere with "
"something of your own creation."
msgstr ""
"Нет способа указать Django возвращать объекты модели ``MyPerson`` при "
"запросе через модель ``Person``. QuerySet для модели ``Person`` вернет "
"объекты этого типа. Стоит помнить, что код, который использует модель "
"``Person``, будет использовать ее независимо от добавления proxy-модели. Вы "
"не можете полностью заменить модель ``Person`` (или любую другую) всюду, где "
"она используется."

# 53ef4533648e4cb0aadb96df50b49ccf
#: ../../topics/db/models.txt:1242
msgid "Base class restrictions"
msgstr "Ограничения базового класса"

# f3ab4b245e5c46ff944b1cb85d826955
#: ../../topics/db/models.txt:1244
#, fuzzy
msgid ""
"A proxy model must inherit from exactly one non-abstract model class. You "
"can't inherit from multiple non-abstract models as the proxy model doesn't "
"provide any connection between the rows in the different database tables. A "
"proxy model can inherit from any number of abstract model classes, providing "
"they do *not* define any model fields. A proxy model may also inherit from "
"any number of proxy models that share a common non-abstract parent class."
msgstr ""
"Proxy-модель должна наследоваться от одной не абстрактной модели. Вы не "
"можете унаследоваться от нескольких не абстрактных моделей т.к. proxy-модель "
"не может хранить информации о полях в нескольких таблицах базы данных. Proxy-"
"модель может наследоваться от нескольких абстрактных моделей при условии, "
"что они *не* определяют поля модели."

#: ../../topics/db/models.txt:1253
msgid ""
"In earlier versions, a proxy model couldn't inherit more than one proxy "
"model that shared the same parent class."
msgstr ""

# cabb533e8a29477f91c59c2b0c5f7bd9
#: ../../topics/db/models.txt:1257
msgid "Proxy model managers"
msgstr "Менеджер proxy-модели"

# ce2c391c7a2d4f8ca5c53000d96d90ef
#: ../../topics/db/models.txt:1259
msgid ""
"If you don't specify any model managers on a proxy model, it inherits the "
"managers from its model parents. If you define a manager on the proxy model, "
"it will become the default, although any managers defined on the parent "
"classes will still be available."
msgstr ""
"Если вы не определите ни один менеджер для proxy-модели, он будет "
"унаследован от родительской модели. Если вы определите менеджер, он будет "
"использован как менеджер по умолчанию, в то же время доступны менеджеры, "
"определенные в родительской модели."

# a81df51964be4070a5f2d51f0f855fd7
#: ../../topics/db/models.txt:1264
msgid ""
"Continuing our example from above, you could change the default manager used "
"when you query the ``Person`` model like this::"
msgstr ""
"Используя пример выше, вы можете переопределить менеджер по умолчанию, "
"используемый для получения данных модели ``Person``, таким способом::"

# 4cf5f584dbbc4b62be6746c13c39b55f
#: ../../topics/db/models.txt:1279
msgid ""
"If you wanted to add a new manager to the Proxy, without replacing the "
"existing default, you can use the techniques described in the :ref:`custom "
"manager <custom-managers-and-inheritance>` documentation: create a base "
"class containing the new managers and inherit that after the primary base "
"class::"
msgstr ""
"Если вы хотите добавить новый менеджер, без замены существующего менеджера, "
"вы можете использовать методы, описанные в разделе о :ref:`собственных "
"менеджерах<custom-managers-and-inheritance>`: создайте базовый класс с новым "
"менеджером и добавьте его в наследование после базового класса::"

# 9a432c52fd6a4856a382dbd8e7c1188d
#: ../../topics/db/models.txt:1295
msgid ""
"You probably won't need to do this very often, but, when you do, it's "
"possible."
msgstr ""
"Скорее всего вам это не понадобится, но если все таки понадобится, знайте, "
"что это возможно."

# 62f377f567c640b4badb638cab44948c
#: ../../topics/db/models.txt:1301
#, fuzzy
msgid "Differences between proxy inheritance and unmanaged models"
msgstr "Разница между proxy наследованием и неуправляемой(unmanaged) моделью"

# 9acff3c4e12d45bb9e5d5c95bea6b371
#: ../../topics/db/models.txt:1303
#, fuzzy
msgid ""
"Proxy model inheritance might look fairly similar to creating an unmanaged "
"model, using the :attr:`~django.db.models.Options.managed` attribute on a "
"model's ``Meta`` class."
msgstr ""
"Proxy может выглядеть так же как и неуправляемая модель, используя атрибут :"
"attr:`~django.db.models.Options.managed` класса ``Meta`` модели. Оба "
"варианта не совсем то же самое, и это стоит учесть, при выборе что вы должны "
"использовать."

# 3aa4d7b7229c42a69095862f0b8e7166
#: ../../topics/db/models.txt:1307
#, fuzzy
msgid ""
"With careful setting of :attr:`Meta.db_table <django.db.models.Options."
"db_table>` you could create an unmanaged model that shadows an existing "
"model and adds Python methods to it. However, that would be very repetitive "
"and fragile as you need to keep both copies synchronized if you make any "
"changes."
msgstr ""
"Первое отличие в том, что вы можете (и должны, если вам не нужна пустая "
"модель) добавить поля для модели с ``Meta.managed=False``. Вы можете, указав "
"необходимый атрибут :attr:`Meta.db_table <django.db.models.Options."
"db_table>`, создать неуправляемую модель, которая отображает существующую "
"модель, и добавить ей новые методы. Тем не менее, это было не совсем удобно, "
"т.к. нужно соблюдать синхронность моделей, делая какие-либо изменения в "
"таблице."

#: ../../topics/db/models.txt:1313
msgid ""
"On the other hand, proxy models are intended to behave exactly like the "
"model they are proxying for. They are always in sync with the parent model "
"since they directly inherit its fields and managers."
msgstr ""

# dc68f51ff7d84b2eb68326648c7c73a8
#: ../../topics/db/models.txt:1317
#, fuzzy
msgid "The general rules are:"
msgstr "Основные правила:"

# c79456c86e4d433b84906bc8a06ee4ab
#: ../../topics/db/models.txt:1319
msgid ""
"If you are mirroring an existing model or database table and don't want all "
"the original database table columns, use ``Meta.managed=False``. That option "
"is normally useful for modeling database views and tables not under the "
"control of Django."
msgstr ""
"Если вы хотите отобразить существующую модель или таблицу в базе данных без "
"использования всех колонок таблицы, используйте ``Meta.managed=False``. "
"Также это очень полезно для использования таблиц базы данных, которые "
"управляются не Django."

# 6aea5fefef234ce592994dc913a64486
#: ../../topics/db/models.txt:1323
msgid ""
"If you are wanting to change the Python-only behavior of a model, but keep "
"all the same fields as in the original, use ``Meta.proxy=True``. This sets "
"things up so that the proxy model is an exact copy of the storage structure "
"of the original model when data is saved."
msgstr ""
"Если вы хотите изменить поведение модели на уровне Python, но использовать "
"все существующие поля таблицы, используйте ``Meta.proxy=True``. Proxy-модель "
"воспринимается как точная копия оригинальной при сохранении данных."

# 2086c62df8f04f768ee64325305e9547
#: ../../topics/db/models.txt:1331
msgid "Multiple inheritance"
msgstr "Множественное наследование"

# 4a0f21b359d4431e8591c3e0b6a2eee4
#: ../../topics/db/models.txt:1333
msgid ""
"Just as with Python's subclassing, it's possible for a Django model to "
"inherit from multiple parent models. Keep in mind that normal Python name "
"resolution rules apply. The first base class that a particular name (e.g. :"
"ref:`Meta <meta-options>`) appears in will be the one that is used; for "
"example, this means that if multiple parents contain a :ref:`Meta <meta-"
"options>` class, only the first one is going to be used, and all others will "
"be ignored."
msgstr ""
"Так же, как и наследование в Python, можно использовать множественное "
"наследование моделей Django. Имейте в виду, что используются правила "
"именования Python. Например, есть несколько родительских объектов с классом :"
"ref:`Meta <meta-options>`, в таком случае будет использован атрибут первой "
"родительской модели, остальные будут проигнорированы."

# 49a1ffdb8c724403b4e8003c21552d82
#: ../../topics/db/models.txt:1340
msgid ""
"Generally, you won't need to inherit from multiple parents. The main use-"
"case where this is useful is for \"mix-in\" classes: adding a particular "
"extra field or method to every class that inherits the mix-in. Try to keep "
"your inheritance hierarchies as simple and straightforward as possible so "
"that you won't have to struggle to work out where a particular piece of "
"information is coming from."
msgstr ""
"В большинстве случаев вам не нужно будет использовать множественное "
"наследование. В основном множественное наследование используют для \"mix-in"
"\" классов: добавление дополнительных полей и методов для каждой модели "
"унаследованной от mix-in класса. Старайтесь содержать иерархию наследования "
"настолько простой и понятной, насколько это возможно, чтобы не возникало "
"проблем с определением, откуда взялась та или другая информация."

# b08d3c1deaee46cb8dcdcb6190f83816
#: ../../topics/db/models.txt:1347
msgid ""
"Note that inheriting from multiple models that have a common ``id`` primary "
"key field will raise an error. To properly use multiple inheritance, you can "
"use an explicit :class:`~django.db.models.AutoField` in the base models::"
msgstr ""
"Обратите внимание, наследование от нескольких моделей, которые содержат "
"первичное поле ``id``, вызовет ошибку. Чтобы избежать этой проблемы, можно "
"явно указать :class:`~django.db.models.AutoField` поля в базовых моделях::"

# 98c18961c5eb439eb86bc0f0aa666982
#: ../../topics/db/models.txt:1362
msgid ""
"Or use a common ancestor to hold the :class:`~django.db.models.AutoField`::"
msgstr ""
"Или использовать общего предка, который содержит поле :class:`~django.db."
"models.AutoField`::"

# c40aca9df47e4e0fb62cb95e72451eb7
#: ../../topics/db/models.txt:1377
msgid "Field name \"hiding\" is not permitted"
msgstr "Переопределение полей запрещено"

# 54c9809587054cb0b8b07380a5297651
#: ../../topics/db/models.txt:1379
#, fuzzy
msgid ""
"In normal Python class inheritance, it is permissible for a child class to "
"override any attribute from the parent class. In Django, this isn't usually "
"permitted for model fields. If a non-abstract model base class has a field "
"called ``author``, you can't create another model field or define an "
"attribute called ``author`` in any class that inherits from that base class."
msgstr ""
"В Python можно переопределять атрибуты класса-родителя в дочернем классе. В "
"Django это запрещено для атрибутов, которые являются экземплярами :class:"
"`~django.db.models.Field` (по крайней мере, на данный момент). Если "
"родительская модель имеет поле ``author``, вы не можете создать поле с "
"именем ``author`` в дочерних моделях."

#: ../../topics/db/models.txt:1385
msgid ""
"This restriction doesn't apply to model fields inherited from an abstract "
"model. Such fields may be overridden with another field or value, or be "
"removed by setting ``field_name = None``."
msgstr ""

#: ../../topics/db/models.txt:1391
msgid "The ability to override abstract fields was added."
msgstr ""

#: ../../topics/db/models.txt:1395
msgid ""
"Model managers are inherited from abstract base classes. Overriding an "
"inherited field which is referenced by an inherited :class:`~django.db."
"models.Manager` may cause subtle bugs. See :ref:`custom managers and model "
"inheritance <custom-managers-and-inheritance>`."
msgstr ""

#: ../../topics/db/models.txt:1402
msgid ""
"Some fields define extra attributes on the model, e.g. a :class:`~django.db."
"models.ForeignKey` defines an extra attribute with ``_id`` appended to the "
"field name, as well as ``related_name`` and ``related_query_name`` on the "
"foreign model."
msgstr ""

#: ../../topics/db/models.txt:1407
msgid ""
"These extra attributes cannot be overridden unless the field that defines it "
"is changed or removed so that it no longer defines the extra attribute."
msgstr ""

# 2ea60b93e66e4d32a0a05223278618ee
#: ../../topics/db/models.txt:1410
msgid ""
"Overriding fields in a parent model leads to difficulties in areas such as "
"initializing new instances (specifying which field is being initialized in "
"``Model.__init__``) and serialization. These are features which normal "
"Python class inheritance doesn't have to deal with in quite the same way, so "
"the difference between Django model inheritance and Python class inheritance "
"isn't arbitrary."
msgstr ""
"Переопределение полей родительской модели приводит к проблемам при создании "
"модели (нельзя точно узнать, какое поле таблицы указывается в ``Model."
"__init__``) и при сериализации. При наследовании классов в Python работает "
"все немного по другому."

# bc73a22c790d4d93af6a9975358cec3e
#: ../../topics/db/models.txt:1417
msgid ""
"This restriction only applies to attributes which are :class:`~django.db."
"models.Field` instances. Normal Python attributes can be overridden if you "
"wish. It also only applies to the name of the attribute as Python sees it: "
"if you are manually specifying the database column name, you can have the "
"same column name appearing in both a child and an ancestor model for multi-"
"table inheritance (they are columns in two different database tables)."
msgstr ""
"Эти ограничения относятся только для атрибутов, которые являются "
"экземплярами :class:`~django.db.models.Field`. Остальные атрибуты могут быть "
"переопределены. Это также относится к атрибутам классов. Вы можете указать "
"одинаковое название поля в таблице БД для родительской и дочерней моделей т."
"к. они находятся в разных таблицах."

# de3b9fbfc05f455bb72881440bad07f0
#: ../../topics/db/models.txt:1425
msgid ""
"Django will raise a :exc:`~django.core.exceptions.FieldError` if you "
"override any model field in any ancestor model."
msgstr ""
"Django вызовет исключение :exc:`~django.core.exceptions.FieldError`, если вы "
"переопределите поле родительской модели."

#: ../../topics/db/models.txt:1429
msgid "Organizing models in a package"
msgstr ""

#: ../../topics/db/models.txt:1431
msgid ""
"The :djadmin:`manage.py startapp <startapp>` command creates an application "
"structure that includes a ``models.py`` file. If you have many models, "
"organizing them in separate files may be useful."
msgstr ""

#: ../../topics/db/models.txt:1435
msgid ""
"To do so, create a ``models`` package. Remove ``models.py`` and create a "
"``myapp/models/`` directory with an ``__init__.py`` file and the files to "
"store your models. You must import the models in the ``__init__.py`` file."
msgstr ""

#: ../../topics/db/models.txt:1439
msgid ""
"For example, if you had ``organic.py`` and ``synthetic.py`` in the "
"``models`` directory:"
msgstr ""

#: ../../topics/db/models.txt:1448
msgid ""
"Explicitly importing each model rather than using ``from .models import *`` "
"has the advantages of not cluttering the namespace, making code more "
"readable, and keeping code analysis tools useful."
msgstr ""

#: ../../topics/db/models.txt:1455
msgid "The Models Reference"
msgstr ""

#: ../../topics/db/models.txt:1455
msgid ""
"Covers all the model related APIs including model fields, related objects, "
"and ``QuerySet``."
msgstr "Описывает API всего, что связано с моделями."

# f15b4a8845cf41b59dda9f9abddce649
#~ msgid "The database column type (e.g. ``INTEGER``, ``VARCHAR``)."
#~ msgstr "Типа колонки в базе данных (например: ``INTEGER``, ``VARCHAR``)."

# 050936b2aab44c58ae8f34f6a1d0e180
#~ msgid ":attr:`~Field.null`"
#~ msgstr ":attr:`~Field.null`"

# bcc8eb1467504e92997f5769b621d7e6
#~ msgid ":attr:`~Field.blank`"
#~ msgstr ":attr:`~Field.blank`"

# 5ca3944d500949ba892df6f766c62e8d
#~ msgid ":attr:`~Field.choices`"
#~ msgstr ":attr:`~Field.choices`"

# 0fb5e385158845abb8bb76f00dec26cf
#~ msgid ":attr:`~Field.default`"
#~ msgstr ":attr:`~Field.default`"

# 1a7fe5090af24f98a47190cf005d8b36
#~ msgid ":attr:`~Field.help_text`"
#~ msgstr ":attr:`~Field.help_text`"

# 93971cfc5c354eefb546bb03c43b5835
#~ msgid ":attr:`~Field.primary_key`"
#~ msgstr ":attr:`~Field.primary_key`"

# a0ced81eda1546eab7433a34274b43ed
#~ msgid ":attr:`~Field.unique`"
#~ msgstr ":attr:`~Field.unique`"

# 092266b85308496e9e32d1993f2f8b7d
#~ msgid ""
#~ "The other difference that is more important for proxy models, is how "
#~ "model managers are handled. Proxy models are intended to behave exactly "
#~ "like the model they are proxying for. So they inherit the parent model's "
#~ "managers, including the default manager. In the normal multi-table model "
#~ "inheritance case, children do not inherit managers from their parents as "
#~ "the custom managers aren't always appropriate when extra fields are "
#~ "involved. The :ref:`manager documentation <custom-managers-and-"
#~ "inheritance>` has more details about this latter case."
#~ msgstr ""
#~ "Другим отличием, которое больше относится к proxy-модели - это как Django "
#~ "работает с этими моделями. Proxy-модели предназначены для использования "
#~ "так же, как и оригинальная модель. Они наследуют менеджеры оригинальной "
#~ "модели, включая менеджер по умолчанию. При multi-table наследовании "
#~ "дочерние модели не наследуют менеджеры от родительской т.к. они не всегда "
#~ "будут работать корректно, учитывая, что есть дополнительные поля. :ref:"
#~ "`Документация о менеджерах <custom-managers-and-inheritance>` содержит "
#~ "больше информации об этом."

# 8a621d0da9a241a1937c23cb3caffd50
#~ msgid ""
#~ "When these two features were implemented, attempts were made to squash "
#~ "them into a single option. It turned out that interactions with "
#~ "inheritance, in general, and managers, in particular, made the API very "
#~ "complicated and potentially difficult to understand and use. It turned "
#~ "out that two options were needed in any case, so the current separation "
#~ "arose."
#~ msgstr ""
#~ "Когда эти две функции были реализованы, была попытка объединить их в одно "
#~ "решение. Оказалось, что работа с наследованием в общем и менеджеры в "
#~ "частности делает API очень сложным и потенциально тяжелым для понимания. "
#~ "Так возникло решение использовать два механизма."

#~ msgid ":doc:`The Models Reference </ref/models/index>`"
#~ msgstr ":doc:`Справочник по моделям </ref/models/index>`"

# 2f6992c1b1e34ebeae668ce3e03c2ee3
#~ msgid ""
#~ "In Django 1.6 and earlier, intermediate models containing more than one "
#~ "foreign key to any of the models involved in the many-to-many "
#~ "relationship used to be prohibited."
#~ msgstr ""
#~ "В Django 1.6 и ниже был запрещено использовать промежуточную модель, "
#~ "которая имела несколько связей со связываемой моделью."

# fbb86bce98b045e8850ff0c48c0f37d2
#~ msgid ""
#~ "Proxy models inherit any ``Meta`` options that they don't define from "
#~ "their non-abstract model parent (the model they are proxying for)."
#~ msgstr ""
#~ "Proxy-модель наследует атрибуты класса ``Meta`` родительской не "
#~ "абстрактной модели, которые она не переопределяет."

# 5a7be81a8c81477e8b056d825a27be4b
#~ msgid ""
#~ "Before Django 1.7, inheriting from multiple models that had an ``id`` "
#~ "primary key field did not raise an error, but could result in data loss. "
#~ "For example, consider these models (which no longer validate due to the "
#~ "clashing ``id`` fields)::"
#~ msgstr ""
#~ "До Django 1.7, наследование от нескольких моделей, которые содержат "
#~ "первичный ключ ``id``, не вызывало ошибки, но могло привести к потере "
#~ "данных. Например, возьмем следующие модели (которые уже не работают из-за "
#~ "конфликта полей ``id``)::"

# 1f708b52559f45618c53c5edbf1d83a1
#~ msgid ""
#~ "This snippet demonstrates how creating a child object overwrote the value "
#~ "of a previously created parent object::"
#~ msgstr ""
#~ "Следующий код показывает, как создание дочернего объекта может "
#~ "перезаписать данные в родительском::"

# b8eb7ab534c149c88d74a8aa0861e391
#~ msgid ""
#~ "Your intermediate model must contain one - and *only* one - foreign key "
#~ "to the target model (this would be ``Person`` in our example). If you "
#~ "have more than one foreign key, a validation error will be raised."
#~ msgstr ""
#~ "Промежуточная модель должна содержать один и *только* один внешний ключ "
#~ "на связанную модель (в нашем примере это ``Person``). При нескольких "
#~ "ключах будет вызвано исключение."

# 2061a8ba52884cd088215bfa6bdcb809
#~ msgid ""
#~ "Your intermediate model must contain one - and *only* one - foreign key "
#~ "to the source model (this would be ``Group`` in our example). If you have "
#~ "more than one foreign key, a validation error will be raised."
#~ msgstr ""
#~ "Промежуточная модель должна содержать один и *только* один внешний ключ "
#~ "на модель-источник (в нашем примере это ``Group``). При нескольких ключах "
#~ "будет вызвано исключение."
