# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-03 16:48+0300\n"
"PO-Revision-Date: 2016-03-01 18:08+0200\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# bdb93eaefd364936a9887a44682519a0
#: ../../topics/db/queries.txt:3
msgid "Making queries"
msgstr "Выполнение запросов"

# 39d54aa7cfa3495bb44614d6afc19532
#: ../../topics/db/queries.txt:7
msgid ""
"Once you've created your :doc:`data models </topics/db/models>`, Django "
"automatically gives you a database-abstraction API that lets you create, "
"retrieve, update and delete objects. This document explains how to use this "
"API. Refer to the :doc:`data model reference </ref/models/index>` for full "
"details of all the various model lookup options."
msgstr ""
"После создания :doc:`модели </topics/db/models>`, Django автоматически "
"создает API для работы с базой данных, который позволяет вам создавать, "
"получать, изменять и удалять объекты. Этот раздел расскажет вам как "
"использовать этот API. В :doc:`описании моделей </ref/models/index>` вы "
"можете найти список всех существующих опций поиска."

# ed797a0cb12b48b482c43a7c27b78e50
#: ../../topics/db/queries.txt:13
msgid ""
"Throughout this guide (and in the reference), we'll refer to the following "
"models, which comprise a Weblog application:"
msgstr "В этом разделе(и последующих) мы будем использовать такие модели:"

# 214abe3695e0474eb33a993452e202f5
#: ../../topics/db/queries.txt:51
msgid "Creating objects"
msgstr "Создание объектов"

# 91a82e93d8db4c6aa8cf8cf3fe7b8df2
#: ../../topics/db/queries.txt:53
msgid ""
"To represent database-table data in Python objects, Django uses an intuitive "
"system: A model class represents a database table, and an instance of that "
"class represents a particular record in the database table."
msgstr ""
"Для представления данных таблицы в виде объектов Python, Django использует "
"интуитивно понятную систему: класс модели представляет таблицу, а экземпляр "
"модели - запись в этой таблице."

# 44d1d5cef05f4f5fa4cd4e5bc0d78293
#: ../../topics/db/queries.txt:57
msgid ""
"To create an object, instantiate it using keyword arguments to the model "
"class, then call :meth:`~django.db.models.Model.save` to save it to the "
"database."
msgstr ""
"Чтобы создать объект, создайте экземпляр класса модели, указав необходимые "
"поля в аргументах и вызовите метод :meth:`~django.db.models.Model.save` "
"чтобы сохранить его в базе данных."

# 4f8109ce20844472abc9f5f235f4d8f2
#: ../../topics/db/queries.txt:60
msgid ""
"Assuming models live in a file ``mysite/blog/models.py``, here's an example::"
msgstr "Предположим, что модель находится в ``mysite/blog/models.py``::"

# fa058105d9a24a56bc787f806d5ba406
#: ../../topics/db/queries.txt:66
msgid ""
"This performs an ``INSERT`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call :meth:`~django.db.models.Model."
"save`."
msgstr ""
"В результате выполнения этого кода будет создан ``INSERT`` SQL-запрос. "
"Django не выполняет запросов к базе данных, пока не будет вызван метод :meth:"
"`~django.db.models.Model.save`."

# f0b45d018f5548f0b9eb9e653a33483c
#: ../../topics/db/queries.txt:69
msgid "The :meth:`~django.db.models.Model.save` method has no return value."
msgstr "Метод :meth:`~django.db.models.Model.save` ничего не возвращает."

# edd3c4ad955c43659bdba26f82170e58
#: ../../topics/db/queries.txt:73
msgid ""
":meth:`~django.db.models.Model.save` takes a number of advanced options not "
"described here. See the documentation for :meth:`~django.db.models.Model."
"save` for complete details."
msgstr ""
":meth:`~django.db.models.Model.save` принимает ряд аргументов, не описанных "
"в этом разделе. Смотрите документацию о методе :meth:`~django.db.models."
"Model.save` для подробностей."

# 8315103794ad4013bf4f1dcc5bb27b46
#: ../../topics/db/queries.txt:77
msgid ""
"To create and save an object in a single step, use the :meth:`~django.db."
"models.query.QuerySet.create()` method."
msgstr ""
"Чтобы создать и сохранить объект используйте метод :meth:`~django.db.models."
"query.QuerySet.create()`."

# fcac470e103146d7b0591630f381417a
#: ../../topics/db/queries.txt:81
msgid "Saving changes to objects"
msgstr "Сохранение изменений в объектах"

# 32cd7e30dc36437cb37b0ae2ce886732
#: ../../topics/db/queries.txt:83
msgid ""
"To save changes to an object that's already in the database, use :meth:"
"`~django.db.models.Model.save`."
msgstr ""
"Для сохранения изменений в объект, который уже существует в базе данных, "
"используйте :meth:`~django.db.models.Model.save`."

# a8cdaaed9aec406994b8610219ad1c5c
#: ../../topics/db/queries.txt:86
msgid ""
"Given a ``Blog`` instance ``b5`` that has already been saved to the "
"database, this example changes its name and updates its record in the "
"database::"
msgstr ""
"В данном примере изменяется название объекта ``b5`` модели ``Blog`` и "
"обновляется запись в базе данных::"

# 545bb75ea29e46a198344d220e0f0f44
#: ../../topics/db/queries.txt:92
msgid ""
"This performs an ``UPDATE`` SQL statement behind the scenes. Django doesn't "
"hit the database until you explicitly call :meth:`~django.db.models.Model."
"save`."
msgstr ""
"В результате выполнения этого кода будет создан ``UPDATE`` SQL запрос. "
"Django не выполняет каких либо запросов к базе данных, пока не будет вызван "
"метод :meth:`~django.db.models.Model.save`."

# 61fc6798d83341919647dd8eec754e24
#: ../../topics/db/queries.txt:96
msgid "Saving ``ForeignKey`` and ``ManyToManyField`` fields"
msgstr "Сохранение полей ``ForeignKey`` и ``ManyToManyField``"

# 7b6667eb03eb44869680a74b24fa6ddb
#: ../../topics/db/queries.txt:98
msgid ""
"Updating a :class:`~django.db.models.ForeignKey` field works exactly the "
"same way as saving a normal field -- simply assign an object of the right "
"type to the field in question. This example updates the ``blog`` attribute "
"of an ``Entry`` instance ``entry``, assuming appropriate instances of "
"``Entry`` and ``Blog`` are already saved to the database (so we can retrieve "
"them below)::"
msgstr ""
"Обновление :class:`~django.db.models.ForeignKey` работает так же, как и "
"сохранение обычных полей; просто назначьте полю объект необходимого типа. В "
"этом примере обновляется атрибут ``blog`` модели ``Entry`` объектом "
"``entry``, предполагается что в базе данных уже существуют используемые "
"объекты::"

# b3a73e0272ef462daad7421096970447
#: ../../topics/db/queries.txt:110
msgid ""
"Updating a :class:`~django.db.models.ManyToManyField` works a little "
"differently -- use the :meth:`~django.db.models.fields.related."
"RelatedManager.add` method on the field to add a record to the relation. "
"This example adds the ``Author`` instance ``joe`` to the ``entry`` object::"
msgstr ""
"Обновление :class:`~django.db.models.ManyToManyField` работает немного по-"
"другому; используйте метод :meth:`~django.db.models.fields.related."
"RelatedManager.add` поля, чтобы добавить связанный объект. В этом примере "
"объект ``joe`` модели  ``Author`` добавляется к объекту ``entry``::"

# 5b1f65fabce6419a83f2f5388991515a
#: ../../topics/db/queries.txt:120
msgid ""
"To add multiple records to a :class:`~django.db.models.ManyToManyField` in "
"one go, include multiple arguments in the call to :meth:`~django.db.models."
"fields.related.RelatedManager.add`, like this::"
msgstr ""
"Для добавления сразу нескольких объектов в :class:`~django.db.models."
"ManyToManyField`, добавьте несколько аргументов в метод :meth:`~django.db."
"models.fields.related.RelatedManager.add`. Например::"

# 39ba66c21d0942e7a6f993bed62e81cc
#: ../../topics/db/queries.txt:130
msgid ""
"Django will complain if you try to assign or add an object of the wrong type."
msgstr ""
"Django вызовет исключение, если вы попытаетесь добавить объект неверного "
"типа."

# 8c7bd471ea974988b5d7c3e1445da818
#: ../../topics/db/queries.txt:135
msgid "Retrieving objects"
msgstr "Получение объектов"

# 0a5adb968aa7466faa0b09f698a14bab
#: ../../topics/db/queries.txt:137
msgid ""
"To retrieve objects from your database, construct a :class:`~django.db."
"models.query.QuerySet` via a :class:`~django.db.models.Manager` on your "
"model class."
msgstr ""
"Для получения объектов из базы данных, создается :class:`~django.db.models."
"query.QuerySet` через :class:`~django.db.models.Manager` модели."

# 4344cb14e331406aa163cdb656f09892
#: ../../topics/db/queries.txt:141
msgid ""
"A :class:`~django.db.models.query.QuerySet` represents a collection of "
"objects from your database. It can have zero, one or many *filters*. Filters "
"narrow down the query results based on the given parameters. In SQL terms, "
"a :class:`~django.db.models.query.QuerySet` equates to a ``SELECT`` "
"statement, and a filter is a limiting clause such as ``WHERE`` or ``LIMIT``."
msgstr ""
":class:`~django.db.models.query.QuerySet` представляет выборку объектов из "
"базы данных. Он может не содержать, или содержать один или несколько "
"*фильтров* -- критерии для ограничения выборки по определенным параметрам. В "
"терминах SQL,  :class:`~django.db.models.query.QuerySet` - это оператор "
"``SELECT``, а фильтры - условия такие, как ``WHERE`` или ``LIMIT``."

# c6eadadf12584b72998b2d4e75f5a288
#: ../../topics/db/queries.txt:147
msgid ""
"You get a :class:`~django.db.models.query.QuerySet` by using your model's :"
"class:`~django.db.models.Manager`. Each model has at least one :class:"
"`~django.db.models.Manager`, and it's called :attr:`~django.db.models.Model."
"objects` by default. Access it directly via the model class, like so::"
msgstr ""
"Вы получаете :class:`~django.db.models.query.QuerySet`, используя :class:"
"`~django.db.models.Manager`. Каждая модель содержит как минимум один :class:"
"`~django.db.models.Manager`, и он называется :attr:`~django.db.models.Model."
"objects` по умолчанию. Обратиться к нему можно непосредственно через класс "
"модели::"

# 6b8bb227ae234bf18ea7723899f1ed8b
#: ../../topics/db/queries.txt:163
msgid ""
"``Managers`` are accessible only via model classes, rather than from model "
"instances, to enforce a separation between \"table-level\" operations and "
"\"record-level\" operations."
msgstr ""
"Обратиться к менеджерам можно только через модель и нельзя через ее "
"экземпляр. Это сделано для разделения \"table-level\" операций и \"record-"
"level\" операций."

# 53c4bfaf079340ffb99e11e4f208c6c4
#: ../../topics/db/queries.txt:167
msgid ""
"The :class:`~django.db.models.Manager` is the main source of ``QuerySets`` "
"for a model. For example, ``Blog.objects.all()`` returns a :class:`~django."
"db.models.query.QuerySet` that contains all ``Blog`` objects in the database."
msgstr ""
":class:`~django.db.models.Manager` - главный источник :class:`~django.db."
"models.query.QuerySet` для модели. Например, ``Blog.objects.all()`` вернет :"
"class:`~django.db.models.query.QuerySet`, который содержит все объекты "
"``Blog`` из базы данных."

# 5144a2871c694667bff5ecb88f2d1e18
#: ../../topics/db/queries.txt:173
msgid "Retrieving all objects"
msgstr "Получение всех объектов"

# 2c6b2f4e92f14bbf9671e2438fe600a9
#: ../../topics/db/queries.txt:175
msgid ""
"The simplest way to retrieve objects from a table is to get all of them. To "
"do this, use the :meth:`~django.db.models.query.QuerySet.all` method on a :"
"class:`~django.db.models.Manager`::"
msgstr ""
"Самый простой способ получить объекты из таблицы - это получить их всех. Для "
"этого используйте метод :meth:`~django.db.models.query.QuerySet.all` "
"менеджера(:class:`~django.db.models.Manager`)::"

# 2e512666102e4fc0afdb13823fc8a4ce
#: ../../topics/db/queries.txt:181
msgid ""
"The :meth:`~django.db.models.query.QuerySet.all` method returns a :class:"
"`~django.db.models.query.QuerySet` of all the objects in the database."
msgstr ""
"Метод :meth:`~django.db.models.query.QuerySet.all` возвращает :class:"
"`~django.db.models.query.QuerySet` всех объектов в базе данных."

# 538083ba75be487a8e4f45ae3ffcdc97
#: ../../topics/db/queries.txt:185
msgid "Retrieving specific objects with filters"
msgstr "Получение объектов через фильтры"

# 3ec487a3588e488c9743989ef3f77657
#: ../../topics/db/queries.txt:187
msgid ""
"The :class:`~django.db.models.query.QuerySet` returned by :meth:`~django.db."
"models.query.QuerySet.all` describes all objects in the database table. "
"Usually, though, you'll need to select only a subset of the complete set of "
"objects."
msgstr ""
":class:`~django.db.models.query.QuerySet`, возвращенный :class:`~django.db."
"models.Manager`, описывает все объекты в таблице базы данных. Обычно вам "
"нужно выбрать только подмножество всех объектов."

# 182f1928158949fdb2bd2a87d2976d2d
#: ../../topics/db/queries.txt:192
msgid ""
"To create such a subset, you refine the initial :class:`~django.db.models."
"query.QuerySet`, adding filter conditions. The two most common ways to "
"refine a :class:`~django.db.models.query.QuerySet` are:"
msgstr ""
"Для создания такого подмножества, вы можете изменить :class:`~django.db."
"models.query.QuerySet`, добавив условия фильтрации. Два самых простых метода "
"изменить :class:`~django.db.models.query.QuerySet` - это:"

# a1f139c7a5df4dd989db81b46e91f137
#: ../../topics/db/queries.txt:198
#, fuzzy
msgid "``filter(**kwargs)``"
msgstr "``filter(**kwargs)``"

# 23611b20266b40e1af50abf1f167d2c7
#: ../../topics/db/queries.txt:197
msgid ""
"Returns a new :class:`~django.db.models.query.QuerySet` containing objects "
"that match the given lookup parameters."
msgstr ""
"Возвращает новый :class:`~django.db.models.query.QuerySet`, который содержит "
"объекты удовлетворяющие параметрам фильтрации."

# 2fff78f5a9da410ca77922276605f4c6
#: ../../topics/db/queries.txt:202
#, fuzzy
msgid "``exclude(**kwargs)``"
msgstr "``exclude(**kwargs)``"

# 0d937d9209f84bfbbe96b53423db16b3
#: ../../topics/db/queries.txt:201
msgid ""
"Returns a new :class:`~django.db.models.query.QuerySet` containing objects "
"that do *not* match the given lookup parameters."
msgstr ""
"Возвращает новый :class:`~django.db.models.query.QuerySet` содержащий "
"объекты, которые *не* удовлетворяют параметрам фильтрации."

# aa47e448337245a48b065f3d29c84496
#: ../../topics/db/queries.txt:204
msgid ""
"The lookup parameters (``**kwargs`` in the above function definitions) "
"should be in the format described in `Field lookups`_ below."
msgstr ""
"Параметры фильтрации (``**kwargs`` в определении функций выше) должны быть в "
"формате описанном в разделе `Field lookups`_."

# 49dbfe6da92941528300a75cbbf1f08a
#: ../../topics/db/queries.txt:207
msgid ""
"For example, to get a :class:`~django.db.models.query.QuerySet` of blog "
"entries from the year 2006, use :meth:`~django.db.models.query.QuerySet."
"filter` like so::"
msgstr ""
"Например, для создания :class:`~django.db.models.query.QuerySet` чтобы "
"получить записи с 2006, используйте :meth:`~django.db.models.query.QuerySet."
"filter` таким образом::"

# b07f884906e447b6b3f72f66c7c96ff5
#: ../../topics/db/queries.txt:213
msgid "With the default manager class, it is the same as::"
msgstr "Это аналогично::"

# eb78dea098a94225b381acb84fe69e50
#: ../../topics/db/queries.txt:220
msgid "Chaining filters"
msgstr "Цепочка фильтров"

# 586d2e9b00934a52af2fa7723197d315
#: ../../topics/db/queries.txt:222
msgid ""
"The result of refining a :class:`~django.db.models.query.QuerySet` is itself "
"a :class:`~django.db.models.query.QuerySet`, so it's possible to chain "
"refinements together. For example::"
msgstr ""
"Результат изменения :class:`~django.db.models.query.QuerySet` - это новый :"
"class:`~django.db.models.query.QuerySet` и можно использовать цепочки "
"фильтров. Например::"

# 208aeca4bd80471f84a25f969113c2d4
#: ../../topics/db/queries.txt:234
msgid ""
"This takes the initial :class:`~django.db.models.query.QuerySet` of all "
"entries in the database, adds a filter, then an exclusion, then another "
"filter. The final result is a :class:`~django.db.models.query.QuerySet` "
"containing all entries with a headline that starts with \"What\", that were "
"published between January 30, 2005, and the current day."
msgstr ""
"В этом примере к начальному :class:`~django.db.models.query.QuerySet`, "
"который возвращает все объекты, добавляется фильтр, затем исключающий "
"фильтр, и еще один фильтр. Полученный :class:`~django.db.models.query."
"QuerySet` содержит все объекты, у которых заголовок начинается с  \"What\", "
"и которые были опубликованы между 30-го января 2005 и текущей датой."

# 71863ecd36b142f8a4e0d057a30b6c32
#: ../../topics/db/queries.txt:243
#, fuzzy
msgid "Filtered ``QuerySet``\\s are unique"
msgstr "Отфильтрованный QuerySet -- уникален"

# b6864fa2683b488b9811b1a1583915f1
#: ../../topics/db/queries.txt:245
msgid ""
"Each time you refine a :class:`~django.db.models.query.QuerySet`, you get a "
"brand-new :class:`~django.db.models.query.QuerySet` that is in no way bound "
"to the previous :class:`~django.db.models.query.QuerySet`. Each refinement "
"creates a separate and distinct :class:`~django.db.models.query.QuerySet` "
"that can be stored, used and reused."
msgstr ""
"После каждого изменения :class:`~django.db.models.query.QuerySet`, вы "
"получаете новый :class:`~django.db.models.query.QuerySet`, который никак не "
"связан с предыдущим  :class:`~django.db.models.query.QuerySet`. Каждый раз "
"создается отдельный  :class:`~django.db.models.query.QuerySet`, который "
"может быть сохранен и использован."

# dc29c0ea27ea476ab715e2683544683f
# 5e91e24cb1594c89b6bfe3f55ac80f24
# 433aa0a799de4613be266c553c4b00ce
#: ../../topics/db/queries.txt:251 ../../topics/db/queries.txt:1102
#: ../../topics/db/queries.txt:1152
msgid "Example::"
msgstr "Например::"

# 33fbb1a88791463e85aa5048781e9106
#: ../../topics/db/queries.txt:257
msgid ""
"These three ``QuerySets`` are separate. The first is a base :class:`~django."
"db.models.query.QuerySet` containing all entries that contain a headline "
"starting with \"What\". The second is a subset of the first, with an "
"additional criteria that excludes records whose ``pub_date`` is today or in "
"the future. The third is a subset of the first, with an additional criteria "
"that selects only the records whose ``pub_date`` is today or in the future. "
"The initial :class:`~django.db.models.query.QuerySet` (``q1``) is unaffected "
"by the refinement process."
msgstr ""
"Эти три ``QuerySets`` независимы. Первый -- это базовый :class:`~django.db."
"models.query.QuerySet`, который содержит все объекты с заголовками, которые "
"начинаются с \"What\". Второй -- это множество первых с дополнительным "
"критерием фильтрации, который исключает объекты с ``pub_date`` больше, чем "
"текущая дата. Третий -- это множество первого, с отфильтрованными объектами, "
"у которых ``pub_date`` больше, чем текущая дата. Первоначальный :class:"
"`~django.db.models.query.QuerySet` (``q1``) не изменяется последующим "
"добавлением фильтров."

# d4643599691b41bfa29abd565dfdc595
#: ../../topics/db/queries.txt:269
#, fuzzy
msgid "``QuerySet``\\s are lazy"
msgstr "QuerySets -- ленивы"

# 3ef428696244448f98e4b6327e75bd1e
#: ../../topics/db/queries.txt:271
msgid ""
"``QuerySets`` are lazy -- the act of creating a :class:`~django.db.models."
"query.QuerySet` doesn't involve any database activity. You can stack filters "
"together all day long, and Django won't actually run the query until the :"
"class:`~django.db.models.query.QuerySet` is *evaluated*. Take a look at this "
"example::"
msgstr ""
"``QuerySets`` -- ленивы, создание :class:`~django.db.models.query.QuerySet` "
"не выполняет запросов к базе данных. Вы можете добавлять фильтры хоть весь "
"день и Django не выполнит ни один запрос, пока :class:`~django.db.models."
"query.QuerySet` не *вычислен*. Разберем такой пример::"

# 8257179a41074dbf85545adcceac9d26
#: ../../topics/db/queries.txt:282
msgid ""
"Though this looks like three database hits, in fact it hits the database "
"only once, at the last line (``print(q)``). In general, the results of a :"
"class:`~django.db.models.query.QuerySet` aren't fetched from the database "
"until you \"ask\" for them. When you do, the :class:`~django.db.models.query."
"QuerySet` is *evaluated* by accessing the database. For more details on "
"exactly when evaluation takes place, see :ref:`when-querysets-are-evaluated`."
msgstr ""
"Глядя на это можно подумать что было выполнено три запроса в базу данных. На "
"самом деле был выполнен один запрос, в последней строке (``print(q)``). "
"Результат :class:`~django.db.models.query.QuerySet` не будет получен из базы "
"данных, пока вы не \"попросите\" об этом. Когда вы делаете это, :class:"
"`~django.db.models.query.QuerySet` *вычисляется* запросом к базе данных. Для "
"подробностей, в какой момент выполняется запрос, смотрите :ref:`when-"
"querysets-are-evaluated`."

# 2674d6c7da6a4c189a08b80540561e2a
#: ../../topics/db/queries.txt:293
#, fuzzy
msgid "Retrieving a single object with ``get()``"
msgstr "Получение одного объекта с помощью ``get``"

# e2cc2906ccd04763950d12cb7d230178
#: ../../topics/db/queries.txt:295
msgid ""
":meth:`~django.db.models.query.QuerySet.filter` will always give you a :"
"class:`~django.db.models.query.QuerySet`, even if only a single object "
"matches the query - in this case, it will be a :class:`~django.db.models."
"query.QuerySet` containing a single element."
msgstr ""
":meth:`~django.db.models.query.QuerySet.filter` всегда возвращает :class:"
"`~django.db.models.query.QuerySet`, даже если только один объект возвращен "
"запросом - в этом случае, это будет :class:`~django.db.models.query."
"QuerySet` содержащий один объект."

# 0acb3c9442e44d02832a7e2ce77c75d5
#: ../../topics/db/queries.txt:300
msgid ""
"If you know there is only one object that matches your query, you can use "
"the :meth:`~django.db.models.query.QuerySet.get` method on a :class:`~django."
"db.models.Manager` which returns the object directly::"
msgstr ""
"Если вы знаете, что только один объект возвращается запросом, вы можете "
"использовать метод :meth:`~django.db.models.query.QuerySet.get` менеджера(:"
"class:`~django.db.models.Manager`), который возвращает непосредственно "
"объект::"

# 315449410ab24115a7d18c12a37913f3
#: ../../topics/db/queries.txt:306
msgid ""
"You can use any query expression with :meth:`~django.db.models.query."
"QuerySet.get`, just like with :meth:`~django.db.models.query.QuerySet."
"filter` - again, see `Field lookups`_ below."
msgstr ""
"Вы можете использовать для :meth:`~django.db.models.query.QuerySet.get` "
"аргументы, такие же, как и для :meth:`~django.db.models.query.QuerySet."
"filter` - смотрите `Field lookups`_ далее."

# feec9f84114f4941bcb44dc8b96269d6
#: ../../topics/db/queries.txt:311
msgid ""
"Note that there is a difference between using :meth:`~django.db.models.query."
"QuerySet.get`, and using :meth:`~django.db.models.query.QuerySet.filter` "
"with a slice of ``[0]``. If there are no results that match the query, :meth:"
"`~django.db.models.query.QuerySet.get` will raise a ``DoesNotExist`` "
"exception. This exception is an attribute of the model class that the query "
"is being performed on - so in the code above, if there is no ``Entry`` "
"object with a primary key of 1, Django will raise ``Entry.DoesNotExist``."
msgstr ""
"Учтите, что есть разница между использованием :meth:`~django.db.models.query."
"QuerySet.get` и :meth:`~django.db.models.query.QuerySet.filter` с ``[0]``. "
"Если результат пустой, :meth:`~django.db.models.query.QuerySet.get` вызовет "
"исключение ``DoesNotExist``. Это исключение является атрибутом модели, для "
"которой выполняется запрос. Если в примере выше не существует объекта "
"``Entry`` с первичным ключом равным 1, Django вызовет исключение ``Entry."
"DoesNotExist``."

# 150c11fe427a45418a203491b6d3f216
#: ../../topics/db/queries.txt:320
msgid ""
"Similarly, Django will complain if more than one item matches the :meth:"
"`~django.db.models.query.QuerySet.get` query. In this case, it will raise :"
"exc:`~django.core.exceptions.MultipleObjectsReturned`, which again is an "
"attribute of the model class itself."
msgstr ""
"Также Django отреагирует, если запрос :meth:`~django.db.models.query."
"QuerySet.get` вернет не один объект. В этом случае будет вызвано исключение :"
"exc:`~django.core.exceptions.MultipleObjectsReturned`, которое также "
"является атрибутом класса модели."

# 7020ee026d014fa39a53e805a0666d5d
#: ../../topics/db/queries.txt:327
#, fuzzy
msgid "Other ``QuerySet`` methods"
msgstr "Другие методы QuerySet"

# afc80b1fae7948d6a2ff98ecea318a5a
#: ../../topics/db/queries.txt:329
msgid ""
"Most of the time you'll use :meth:`~django.db.models.query.QuerySet.all`, :"
"meth:`~django.db.models.query.QuerySet.get`, :meth:`~django.db.models.query."
"QuerySet.filter` and :meth:`~django.db.models.query.QuerySet.exclude` when "
"you need to look up objects from the database. However, that's far from all "
"there is; see the :ref:`QuerySet API Reference <queryset-api>` for a "
"complete list of all the various :class:`~django.db.models.query.QuerySet` "
"methods."
msgstr ""
"В большинстве случаев вы будете использовать :meth:`~django.db.models.query."
"QuerySet.all`, :meth:`~django.db.models.query.QuerySet.get`, :meth:`~django."
"db.models.query.QuerySet.filter` и :meth:`~django.db.models.query.QuerySet."
"exclude` для получения объектов из базы данных. Однако это не все доступные "
"возможности; смотрите :ref:`документацию о QuerySet API <queryset-api>` для "
"получения информации о всех существующих методах :class:`~django.db.models."
"query.QuerySet`."

# e6ab06f5a63c4e5094c4759fe9d7fd90
#: ../../topics/db/queries.txt:340
#, fuzzy
msgid "Limiting ``QuerySet``\\s"
msgstr "Ограничение выборки"

# 848a171c660d468cb9817d448d4b1ff7
#: ../../topics/db/queries.txt:342
msgid ""
"Use a subset of Python's array-slicing syntax to limit your :class:`~django."
"db.models.query.QuerySet` to a certain number of results. This is the "
"equivalent of SQL's ``LIMIT`` and ``OFFSET`` clauses."
msgstr ""
"Используйте синтаксис срезов для списков Python для ограничения результата "
"выборки :class:`~django.db.models.query.QuerySet`. Это эквивалент таких "
"операторов SQL как ``LIMIT`` и ``OFFSET``."

# 9bfb58adbc01425c9338db52127220d9
#: ../../topics/db/queries.txt:346
msgid "For example, this returns the first 5 objects (``LIMIT 5``)::"
msgstr "Например, этот код возвращает 5 первых объектов (``LIMIT 5``)::"

# 9339b0a5a1424cd788eea90b9736832d
#: ../../topics/db/queries.txt:350
msgid "This returns the sixth through tenth objects (``OFFSET 5 LIMIT 5``)::"
msgstr "Этот возвращает с шестого по десятый (``OFFSET 5 LIMIT 5``)::"

# c21b44f0108f450e8d1cbfb175c98afb
#: ../../topics/db/queries.txt:354
msgid "Negative indexing (i.e. ``Entry.objects.all()[-1]``) is not supported."
msgstr ""
"Отрицательные индексы (например, ``Entry.objects.all()[-1]``) не "
"поддерживаются."

# 5b26a862fb314eb9878516d586f8ed4b
#: ../../topics/db/queries.txt:356
msgid ""
"Generally, slicing a :class:`~django.db.models.query.QuerySet` returns a "
"new :class:`~django.db.models.query.QuerySet` -- it doesn't evaluate the "
"query. An exception is if you use the \"step\" parameter of Python slice "
"syntax. For example, this would actually execute the query in order to "
"return a list of every *second* object of the first 10::"
msgstr ""
"На самом деле, срез :class:`~django.db.models.query.QuerySet` возвращает "
"новый :class:`~django.db.models.query.QuerySet` -- запрос не выполняется. "
"Исключением является использовании \"шага\" в срезе. Например, этот пример "
"выполнил бы запрос, возвращающий каждый *второй* объект из первых 10::"

#: ../../topics/db/queries.txt:364
msgid ""
"Further filtering or ordering of a sliced queryset is prohibited due to the "
"ambiguous nature of how that might work."
msgstr ""

# fadc974392e040b8b3a3fff0c101d29a
#: ../../topics/db/queries.txt:367
msgid ""
"To retrieve a *single* object rather than a list (e.g. ``SELECT foo FROM bar "
"LIMIT 1``), use a simple index instead of a slice. For example, this returns "
"the first ``Entry`` in the database, after ordering entries alphabetically "
"by headline::"
msgstr ""
"Для получения *одного* объекта, а не списка (например, ``SELECT foo FROM bar "
"LIMIT 1``), используйте индекс вместо среза. Например, этот код возвращает "
"первый объект ``Entry`` в базе данных, после сортировки записей по "
"заголовку::"

# 220cb5d52ebc474e87721620ed596880
#: ../../topics/db/queries.txt:374
msgid "This is roughly equivalent to::"
msgstr "Это эквивалент::"

# 569721c7a2fa41db8548d77a432bca46
#: ../../topics/db/queries.txt:378
msgid ""
"Note, however, that the first of these will raise ``IndexError`` while the "
"second will raise ``DoesNotExist`` if no objects match the given criteria. "
"See :meth:`~django.db.models.query.QuerySet.get` for more details."
msgstr ""
"Заметим, что первый пример вызовет ``IndexError``, в то время как второй - "
"``DoesNotExist``, если запрос не вернёт ни одного объекта. Смотрите :meth:"
"`~django.db.models.query.QuerySet.get` для подробностей."

# 02f871217c9f4b9ea83acb8b1287a2cf
#: ../../topics/db/queries.txt:385
msgid "Field lookups"
msgstr "Фильтры полей"

# 598d069f7a26443fa09d4d8eea785a44
#: ../../topics/db/queries.txt:387
msgid ""
"Field lookups are how you specify the meat of an SQL ``WHERE`` clause. "
"They're specified as keyword arguments to the :class:`~django.db.models."
"query.QuerySet` methods :meth:`~django.db.models.query.QuerySet.filter`, :"
"meth:`~django.db.models.query.QuerySet.exclude` and :meth:`~django.db.models."
"query.QuerySet.get`."
msgstr ""
"Фильтры полей -- это \"операторы\" для составления условий SQL ``WHERE``. "
"Они задаются как именованные аргументы для метода :meth:`~django.db.models."
"query.QuerySet.filter`,  :meth:`~django.db.models.query.QuerySet.exclude` и :"
"meth:`~django.db.models.query.QuerySet.get` в :class:`~django.db.models."
"query.QuerySet`."

# 9f1e3bb16101488693f7c293b170d957
#: ../../topics/db/queries.txt:393
msgid ""
"Basic lookups keyword arguments take the form ``field__lookuptype=value``. "
"(That's a double-underscore). For example::"
msgstr ""
"Фильтры полей выглядят как ``field__lookuptype=value``. (Используется "
"двойное подчеркивание). Например::"

# 1a5163a9e32446308bf900587d901cec
#: ../../topics/db/queries.txt:398
msgid "translates (roughly) into the following SQL:"
msgstr "будет транслировано в SQL:"

# 385dc24bcfda4da4815bb52cd92e0b8a
#: ../../topics/db/queries.txt:404
msgid "How this is possible"
msgstr "Как это работает"

# fea015493f45478bb68f74805f67e744
#: ../../topics/db/queries.txt:406
#, fuzzy
msgid ""
"Python has the ability to define functions that accept arbitrary name-value "
"arguments whose names and values are evaluated at runtime. For more "
"information, see :ref:`tut-keywordargs` in the official Python tutorial."
msgstr ""
"Python позволяет определить функции, которые принимают именованные аргументы "
"с динамически вычисляемыми названиями и значениями. Подробности смотрите в "
"разделе `Именованные аргументы <http://docs.python.org/tutorial/controlflow."
"html#keyword-arguments>`_ в официальной документации Python."

# 9f403d8c4c6b4f649f23d545be783a1e
#: ../../topics/db/queries.txt:410
msgid ""
"The field specified in a lookup has to be the name of a model field. There's "
"one exception though, in case of a :class:`~django.db.models.ForeignKey` you "
"can specify the field name suffixed with ``_id``. In this case, the value "
"parameter is expected to contain the raw value of the foreign model's "
"primary key. For example:"
msgstr ""
"Поля указанные при фильтрации должны быть полями модели. Есть одно "
"исключение, для поля :class:`~django.db.models.ForeignKey` можно указать "
"поле с суффиксом ``_id``. В этом случае необходимо передать значение "
"первичного ключа связанной модели. Например:"

# e3c6e5556fe04855a379c97c888c3b8e
#: ../../topics/db/queries.txt:418
msgid ""
"If you pass an invalid keyword argument, a lookup function will raise "
"``TypeError``."
msgstr ""
"При передаче неверного именованного аргумента, будет вызвано исключение "
"``TypeError``."

# 43f6899d141c4ab9ade3aa47a6c1052f
#: ../../topics/db/queries.txt:421
msgid ""
"The database API supports about two dozen lookup types; a complete reference "
"can be found in the :ref:`field lookup reference <field-lookups>`. To give "
"you a taste of what's available, here's some of the more common lookups "
"you'll probably use:"
msgstr ""
"API базы данных поддерживает около двух дюжин фильтров; полный список можно "
"найти в :ref:`разделе о фильтрах полей <field-lookups>`. Вот пример самых "
"используемых фильтров:"

# 5bb25d5ee0224c1cafa04aceda279c1b
#: ../../topics/db/queries.txt:446
msgid ":lookup:`exact`"
msgstr ":lookup:`exact`"

# 28bae35c780c4821ae88dba1112fb92e
#: ../../topics/db/queries.txt:427
msgid "An \"exact\" match. For example::"
msgstr "\"Точное\" совпадение. Например::"

# b019ec8c34b146878d932824f57f1ae9
#: ../../topics/db/queries.txt:431
msgid "Would generate SQL along these lines:"
msgstr "Создаст такой SQL запрос:"

# 8614ff18facd4222a3ad393eaf8905b3
#: ../../topics/db/queries.txt:437
msgid ""
"If you don't provide a lookup type -- that is, if your keyword argument "
"doesn't contain a double underscore -- the lookup type is assumed to be "
"``exact``."
msgstr ""
"Если вы не указали фильтр -- именованный аргумент не содержит двойное "
"подчеркивание -- будет использован фильтр ``exact``."

# 37440d02b41842a183968a9de6a21096
#: ../../topics/db/queries.txt:441
msgid "For example, the following two statements are equivalent::"
msgstr "Например, эти два выражения идентичны::"

# ef0175f7fcca4bcf9b90b44d1c0ce1a9
#: ../../topics/db/queries.txt:446
msgid "This is for convenience, because ``exact`` lookups are the common case."
msgstr ""
"Это сделано для удобства, т.к. ``exact`` самый распространенный фильтр."

# c316e09a6dd348d8b640752319388235
#: ../../topics/db/queries.txt:454
msgid ":lookup:`iexact`"
msgstr ":lookup:`iexact`"

# 71dcd93a692e47b6a4047f2d9dd82f06
#: ../../topics/db/queries.txt:449
msgid "A case-insensitive match. So, the query::"
msgstr "Регистронезависимое совпадение. Такой запрос::"

# 8433df2478144fbda0847a88ed8ccca6
#: ../../topics/db/queries.txt:453
msgid ""
"Would match a ``Blog`` titled ``\"Beatles Blog\"``, ``\"beatles blog\"``, or "
"even ``\"BeAtlES blOG\"``."
msgstr ""
"Найдет ``Blog`` с названием ``\"Beatles Blog\"``, ``\"beatles blog\"``, и "
"даже ``\"BeAtlES blOG\"``."

# 5bb25d5ee0224c1cafa04aceda279c1b
#: ../../topics/db/queries.txt:470
#, fuzzy
msgid ":lookup:`contains`"
msgstr ":lookup:`exact`"

# 76db870a6e6c41db983f2ffff7de61ce
#: ../../topics/db/queries.txt:457
msgid "Case-sensitive containment test. For example::"
msgstr "Регистрозависимая проверка на вхождение. Например::"

# bc59e9b2d10d44c9a3c49044f7dc3b6f
#: ../../topics/db/queries.txt:461
msgid "Roughly translates to this SQL:"
msgstr "Будет конвертировано в такой SQL запрос:"

# 2307a528ce81481382b9a8a56a3682ef
#: ../../topics/db/queries.txt:467
msgid ""
"Note this will match the headline ``'Today Lennon honored'`` but not "
"``'today lennon honored'``."
msgstr ""
"Заметим, что этот пример найдет заголовок ``'Today Lennon honored'``, но не "
"найдет ``'today lennon honored'``."

# f7a625a14ee24abebce04602d73e8f6c
#: ../../topics/db/queries.txt:470
msgid "There's also a case-insensitive version, :lookup:`icontains`."
msgstr "Существуют также регистронезависимые версии, :lookup:`icontains`."

# 52d8408c76434819b03e564ce7b9c452
#: ../../topics/db/queries.txt:475
#, fuzzy
msgid ":lookup:`startswith`, :lookup:`endswith`"
msgstr ":lookup:`startswith`, :lookup:`endswith`"

# 203d7a48fcab4001a57459e299a75d81
#: ../../topics/db/queries.txt:473
msgid ""
"Starts-with and ends-with search, respectively. There are also case-"
"insensitive versions called :lookup:`istartswith` and :lookup:`iendswith`."
msgstr ""
"Поиск по началу и окончанию соответственно. Существуют также "
"регистронезависимые версии :lookup:`istartswith` и :lookup:`iendswith`."

# 87cd7f058691427ba396a54066760024
#: ../../topics/db/queries.txt:477
msgid ""
"Again, this only scratches the surface. A complete reference can be found in "
"the :ref:`field lookup reference <field-lookups>`."
msgstr ""
"Это только основные фильтры. Полный список ищите в :ref:`разделе о фильтрах "
"по полям <field-lookups>`."

# 29d44ab4f0cc4353909092c2dfe0ea24
#: ../../topics/db/queries.txt:483
msgid "Lookups that span relationships"
msgstr "Фильтры по связанным объектам"

# 9f2fa0201f9949d9aae759ad993fa66e
#: ../../topics/db/queries.txt:485
msgid ""
"Django offers a powerful and intuitive way to \"follow\" relationships in "
"lookups, taking care of the SQL ``JOIN``\\s for you automatically, behind "
"the scenes. To span a relationship, just use the field name of related "
"fields across models, separated by double underscores, until you get to the "
"field you want."
msgstr ""
"Django предлагает удобный и понятный интерфейс для фильтрации по связанным "
"объектам, самостоятельно заботясь о ``JOIN`` в SQL. Для фильтра по полю из "
"связанных моделей, используйте имена связывающих полей разделенных двойным "
"нижним подчеркиванием, пока вы не достигните нужного поля."

# 55e64e2168d84553a6b63ad8f2b42fdf
#: ../../topics/db/queries.txt:491
msgid ""
"This example retrieves all ``Entry`` objects with a ``Blog`` whose ``name`` "
"is ``'Beatles Blog'``::"
msgstr ""
"Этот пример получает все объекты ``Entry`` с ``Blog``, ``name`` которого "
"равен ``'Beatles Blog'``::"

# 168b259fd9f04a82ac775974bef1915e
#: ../../topics/db/queries.txt:496
msgid "This spanning can be as deep as you'd like."
msgstr "Этот поиск может быть столь глубоким, как вам будет угодно."

# 9069ac0d75b44358b5f125d83bb77179
#: ../../topics/db/queries.txt:498
msgid ""
"It works backwards, too. To refer to a \"reverse\" relationship, just use "
"the lowercase name of the model."
msgstr ""
"Все работает и в другую сторону. Чтобы обратиться к \"обратной\" связи, "
"просто используйте имя модели в нижнем регистре."

# d27965616e9f48a18d38c51eaf12d4c6
#: ../../topics/db/queries.txt:501
msgid ""
"This example retrieves all ``Blog`` objects which have at least one "
"``Entry`` whose ``headline`` contains ``'Lennon'``::"
msgstr ""
"Этот пример получает все объекты ``Blog``, которые имеют хотя бы один "
"связанный объект ``Entry`` с ``headline`` содержащим ``'Lennon'``::"

# 36fad69af884472cb2ced7751e38b3bc
#: ../../topics/db/queries.txt:506
msgid ""
"If you are filtering across multiple relationships and one of the "
"intermediate models doesn't have a value that meets the filter condition, "
"Django will treat it as if there is an empty (all values are ``NULL``), but "
"valid, object there. All this means is that no error will be raised. For "
"example, in this filter::"
msgstr ""
"Если вы используйте фильтр через несколько связей и одна из промежуточных "
"моделей не содержит подходящей связи, Django расценит это как пустое "
"значение (все значения равны ``NULL``). Исключение не будет вызвано. "
"Например, в этом фильтре::"

# ea722f4d5cae4ae8a56cfdec92c36bac
#: ../../topics/db/queries.txt:513
msgid ""
"(if there was a related ``Author`` model), if there was no ``author`` "
"associated with an entry, it would be treated as if there was also no "
"``name`` attached, rather than raising an error because of the missing "
"``author``. Usually this is exactly what you want to have happen. The only "
"case where it might be confusing is if you are using :lookup:`isnull`. Thus::"
msgstr ""
"(при связанной модели ``Author``), если нет объекта ``author`` связанного с "
"``entry``, это будет расценено как отсутствие ``name``, вместо вызова "
"исключения т.к. ``author`` отсутствует. В большинстве случаев это то, что "
"вам нужно. Единственный случай, когда это может работать не однозначно - при "
"использовании :lookup:`isnull`. Например::"

# 6b8ae985d83a4a9182be16753422ad76
#: ../../topics/db/queries.txt:521
msgid ""
"will return ``Blog`` objects that have an empty ``name`` on the ``author`` "
"and also those which have an empty ``author`` on the ``entry``. If you don't "
"want those latter objects, you could write::"
msgstr ""
"вернет объекты ``Blog`` у которого пустое поле ``name`` у ``author`` и также "
"объекты, у которых пустой ``author``в  ``entry``. Если вы не хотите включать "
"вторые объекты, используйте::"

# 7dfbc48ae5eb436293a1ebe39fe76c49
#: ../../topics/db/queries.txt:528
msgid "Spanning multi-valued relationships"
msgstr "Фильтрация по связям многие-ко-многим"

# ae164b44f5564345b5d2ce74f2fae93a
#: ../../topics/db/queries.txt:530
msgid ""
"When you are filtering an object based on a :class:`~django.db.models."
"ManyToManyField` or a reverse :class:`~django.db.models.ForeignKey`, there "
"are two different sorts of filter you may be interested in. Consider the "
"``Blog``/``Entry`` relationship (``Blog`` to ``Entry`` is a one-to-many "
"relation). We might be interested in finding blogs that have an entry which "
"has both *\"Lennon\"* in the headline and was published in 2008. Or we might "
"want to find blogs that have an entry with *\"Lennon\"* in the headline as "
"well as an entry that was published in 2008. Since there are multiple "
"entries associated with a single ``Blog``, both of these queries are "
"possible and make sense in some situations."
msgstr ""
"Когда вы используете фильтрацию по связанным через :class:`~django.db.models."
"ManyToManyField` объектам или по обратной связи для :class:`~django.db."
"models.ForeignKey`, может быть два вида фильтров. Рассмотрим связь ``Blog``/"
"``Entry`` (от ``Blog`` к ``Entry`` -- это связь один-ко-многим). Нам может "
"понадобиться получить блоги с записями, у которых заголовок содержит *"
"\"Lennon\"* и которые были опубликованы в 2008. Или нам могут понадобиться "
"блоги с записями с *\"Lennon\"* в заголовке и в то же время блоги с записями "
"опубликованными до 2008. Т.к. один ``Blog`` может иметь несколько связанных "
"``Entry``, оба варианта возможны."

# 3723c17a0362496e9cb5312c546c5ee2
#: ../../topics/db/queries.txt:541
msgid ""
"The same type of situation arises with a :class:`~django.db.models."
"ManyToManyField`. For example, if an ``Entry`` has a :class:`~django.db."
"models.ManyToManyField` called ``tags``, we might want to find entries "
"linked to tags called *\"music\"* and *\"bands\"* or we might want an entry "
"that contains a tag with a name of *\"music\"* and a status of *\"public\"*."
msgstr ""
"Аналогичная ситуация и с :class:`~django.db.models.ManyToManyField`. "
"Например, если ``Entry`` имеет :class:`~django.db.models.ManyToManyField` "
"названное ``tags``, нам могут понадобиться записи связанные с тегами *\"music"
"\"* и *\"bands\"* или нам может понадобиться запись содержащая тег *\"music"
"\"* и статусом *\"public\"*."

# c0cfd5cb496e46b9a50035f791c80e6f
#: ../../topics/db/queries.txt:547
msgid ""
"To handle both of these situations, Django has a consistent way of "
"processing :meth:`~django.db.models.query.QuerySet.filter` calls. Everything "
"inside a single :meth:`~django.db.models.query.QuerySet.filter` call is "
"applied simultaneously to filter out items matching all those requirements. "
"Successive :meth:`~django.db.models.query.QuerySet.filter` calls further "
"restrict the set of objects, but for multi-valued relations, they apply to "
"any object linked to the primary model, not necessarily those objects that "
"were selected by an earlier :meth:`~django.db.models.query.QuerySet.filter` "
"call."
msgstr ""
"Чтобы обеспечить оба варианта, Django использует определенные правила для "
"вызовов :meth:`~django.db.models.query.QuerySet.filter`. Все, что в одном "
"вызове :meth:`~django.db.models.query.QuerySet.filter`, применяется "
"одновременно, чтобы отфильтровать все объекты, соответствующие этим "
"параметрам фильтрации. Успешные вызовы :meth:`~django.db.models.query."
"QuerySet.filter` каждый раз сокращают выборку объектов, но для множественных "
"связей, они применяются каждый раз ко всем связанным объектам, а не только к "
"объектам отфильтрованным предыдущим вызовом :meth:`~django.db.models.query."
"QuerySet.filter`."

# 7bd3f99bf3fe44208404a8672d8a7292
#: ../../topics/db/queries.txt:556
msgid ""
"That may sound a bit confusing, so hopefully an example will clarify. To "
"select all blogs that contain entries with both *\"Lennon\"* in the headline "
"and that were published in 2008 (the same entry satisfying both conditions), "
"we would write::"
msgstr ""
"Звучит немного непонятно, но пример должен все прояснить. Для выбора всех "
"блогов, содержащих записи и с *\"Lennon\"* в заголовке и опубликованные в "
"2008 (запись должна удовлетворять оба условия), мы будем использовать такой "
"код::"

# 7a884561801443c9a3944ea257dd4c99
#: ../../topics/db/queries.txt:563
msgid ""
"To select all blogs that contain an entry with *\"Lennon\"* in the headline "
"**as well as** an entry that was published in 2008, we would write::"
msgstr ""
"Для выбора блогов с записями, у которых заголовок содержит *\"Lennon\"*, **а "
"также** с записями опубликованными в 2008, мы напишем::"

# 6398ede0fab4430db86645d7e987aa2d
#: ../../topics/db/queries.txt:568
msgid ""
"Suppose there is only one blog that had both entries containing *\"Lennon\"* "
"and entries from 2008, but that none of the entries from 2008 contained *"
"\"Lennon\"*. The first query would not return any blogs, but the second "
"query would return that one blog."
msgstr ""
"Предположим, существует только один блог, и в нем есть записи со словом *"
"\"Lennon\"* и записи 2008-го года, но ни одна запись 2008-го не содержит "
"слово *\"Lennon\"*. Первый запрос вернет пустой ответ, второй запрос - один "
"блог."

# 0171ffc0fb7c48c2a81d1c78dbad5d72
#: ../../topics/db/queries.txt:573
msgid ""
"In the second example, the first filter restricts the queryset to all those "
"blogs linked to entries with *\"Lennon\"* in the headline. The second filter "
"restricts the set of blogs *further* to those that are also linked to "
"entries that were published in 2008. The entries selected by the second "
"filter may or may not be the same as the entries in the first filter. We are "
"filtering the ``Blog`` items with each filter statement, not the ``Entry`` "
"items."
msgstr ""
"В этом примере, первый фильтр ограничит выборку блогами со связанными "
"записями содержащими *\"Lennon\"* в заголовке. Второй фильтр *далее* "
"ограничит выборку блогами с записями, опубликованными в 2008. Записи "
"выбранные вторым фильтром могут быть такими же, как и из первого фильтра, а "
"могут и не быть. Мы фильтруем объекты ``Blog`` с каждым вызовом "
"``filter()``, а не объекты ``Entry``."

#: ../../topics/db/queries.txt:582
msgid ""
"The behavior of :meth:`~django.db.models.query.QuerySet.filter` for queries "
"that span multi-value relationships, as described above, is not implemented "
"equivalently for :meth:`~django.db.models.query.QuerySet.exclude`. Instead, "
"the conditions in a single :meth:`~django.db.models.query.QuerySet.exclude` "
"call will not necessarily refer to the same item."
msgstr ""
"Поведение :meth:`~django.db.models.query.QuerySet.exclude` при запросе, "
"который использует множественную связь, отличается от аналогичных запросов "
"с :meth:`~django.db.models.query.QuerySet.filter`, поведение которых описано "
"выше. Несколько условий в одном вызове :meth:`~django.db.models.query."
"QuerySet.exclude` не обязательно будут применяться к одной записи."

# 7a884561801443c9a3944ea257dd4c99
#: ../../topics/db/queries.txt:588
msgid ""
"For example, the following query would exclude blogs that contain *both* "
"entries with *\"Lennon\"* in the headline *and* entries published in 2008::"
msgstr ""
"Например, следующий запрос исключит блоги, с записями, у которых заголовок "
"содержит *\"Lennon\"*, **а также** с записями опубликованными в 2008::"

#: ../../topics/db/queries.txt:596
msgid ""
"However, unlike the behavior when using :meth:`~django.db.models.query."
"QuerySet.filter`, this will not limit blogs based on entries that satisfy "
"both conditions. In order to do that, i.e. to select all blogs that do not "
"contain entries published with *\"Lennon\"* that were published in 2008, you "
"need to make two queries::"
msgstr ""
"Однако, в отличии от :meth:`~django.db.models.query.QuerySet.filter`, этот "
"запрос не отфильтрует блоги по записям, которые удовлетворяют двум условиям. "
"Для того, чтобы выбрать все блоги, которые не содержат записи с *\"Lennon\"* "
"и опубликованные в 2008, необходимо сделать два запроса::"

# d03542d8cfc94a68be7678d4fc5c16c3
#: ../../topics/db/queries.txt:612
msgid "Filters can reference fields on the model"
msgstr "Фильтры могут ссылаться на поля модели"

# daf680ef5b7b4c1dae58f9d4d4715432
#: ../../topics/db/queries.txt:614
msgid ""
"In the examples given so far, we have constructed filters that compare the "
"value of a model field with a constant. But what if you want to compare the "
"value of a model field with another field on the same model?"
msgstr ""
"В примерах выше мы использовали фильтры, которые сравнивали поля с "
"определенными значениями(константами). Но что, если вы хотите сравнить одно "
"поле с другим полем одной модели?"

# 96c2498aa253463899e504d5e5696d0a
#: ../../topics/db/queries.txt:618
msgid ""
"Django provides :class:`F expressions <django.db.models.F>` to allow such "
"comparisons. Instances of ``F()`` act as a reference to a model field within "
"a query. These references can then be used in query filters to compare the "
"values of two different fields on the same model instance."
msgstr ""
"Django предоставляет :class:`класс F <django.db.models.F>` для таких "
"сравнений. Экземпляр ``F()`` рассматривается как ссылка на другое поле "
"модели. Эти ссылки могут быть использованы для сравнения значений двух "
"разных полей одного объекта модели."

# 5dbba97bfd8d46feb6b62def596a66b8
#: ../../topics/db/queries.txt:623
msgid ""
"For example, to find a list of all blog entries that have had more comments "
"than pingbacks, we construct an ``F()`` object to reference the pingback "
"count, and use that ``F()`` object in the query::"
msgstr ""
"Например, чтобы выбрать все записи, у которых количество комментариев "
"больше, чем \"pingback\", мы создаем объект ``F()`` с ссылкой на поле "
"\"pingback\", и используем этот объект ``F()`` в запросе::"

# 38a8b48e80b240bd876eb2daf7ebd84b
#: ../../topics/db/queries.txt:630
msgid ""
"Django supports the use of addition, subtraction, multiplication, division, "
"modulo, and power arithmetic with ``F()`` objects, both with constants and "
"with other ``F()`` objects. To find all the blog entries with more than "
"*twice* as many comments as pingbacks, we modify the query::"
msgstr ""
"Django поддерживает операции суммирования, вычитания, умножения, деления и "
"арифметический модуль для объектов ``F()``, с константами или другими "
"объектами ``F()``. Чтобы найти все записи с количеством комментариев в *два "
"раза больше* чем \"pingbacks\", используем такой запрос::"

# 1b4656c76a914e7c989975855b270f2d
#: ../../topics/db/queries.txt:637
msgid ""
"To find all the entries where the rating of the entry is less than the sum "
"of the pingback count and comment count, we would issue the query::"
msgstr ""
"Чтобы найти все записи с рейтингом ниже суммы \"pingback\" и количества "
"комментариев, необходимо выполнить такой запрос::"

# 7640beb6287741be8fb1e3b627883152
#: ../../topics/db/queries.txt:643
msgid ""
"You can also use the double underscore notation to span relationships in an "
"``F()`` object. An ``F()`` object with a double underscore will introduce "
"any joins needed to access the related object. For example, to retrieve all "
"the entries where the author's name is the same as the blog name, we could "
"issue the query::"
msgstr ""
"Вы можете использовать два нижних подчеркивания для использования полей "
"связанных объектов в ``F()``. Объект ``F()`` с двойным нижним подчеркиванием "
"обеспечит все необходимые ``JOIN`` для получения необходимых связанных "
"объектов. Например, чтобы получить все записи, у которых имя автора "
"совпадает с названием блога, нужно выполнить такой запрос::"

# 33f2bb6676324a2ab398a74705af9cfa
#: ../../topics/db/queries.txt:651
msgid ""
"For date and date/time fields, you can add or subtract a :class:`~datetime."
"timedelta` object. The following would return all entries that were modified "
"more than 3 days after they were published::"
msgstr ""
"Для полей даты и времени вы можете использовать сумму или разницу объектов :"
"class:`~datetime.timedelta`.  Этот код вернет все записи, которые были "
"отредактированы через 3 дня после публикации::"

# 85c94a81d156475d8916800dec4c96c4
#: ../../topics/db/queries.txt:658
#, fuzzy
msgid ""
"The ``F()`` objects support bitwise operations by ``.bitand()``, ``."
"bitor()``, ``.bitrightshift()``, and ``.bitleftshift()``. For example::"
msgstr ""
"Объект ``F()`` теперь позволяет использовать битовые операции ``.bitand()`` "
"и ``.bitor()``, например::"

# 747410fa45a143589fc635ec7d748c00
#: ../../topics/db/queries.txt:664
#, fuzzy
msgid "The ``pk`` lookup shortcut"
msgstr "\"Shortcut\" для фильтрации по первичному ключу"

# 6be18a0ecccd41218e0df6f3492c6655
#: ../../topics/db/queries.txt:666
msgid ""
"For convenience, Django provides a ``pk`` lookup shortcut, which stands for "
"\"primary key\"."
msgstr ""
"Для удобства, Django предоставляет специальный фильтр ``pk`` для работы с "
"первичным ключом."

# 729e96fa9f6a4d15b7aceb1bf99a25c1
#: ../../topics/db/queries.txt:669
msgid ""
"In the example ``Blog`` model, the primary key is the ``id`` field, so these "
"three statements are equivalent::"
msgstr ""
"Например, первичный ключ модели ``Blog`` -- поле ``id``. Эти три запроса "
"идентичны::"

# bd8f98e87fe64fb5b741d19900b4d293
#: ../../topics/db/queries.txt:676
msgid ""
"The use of ``pk`` isn't limited to ``__exact`` queries -- any query term can "
"be combined with ``pk`` to perform a query on the primary key of a model::"
msgstr ""
"Использование ``pk`` не ограничено только фильтром ``__exact`` -- любой "
"фильтр может быть использован с ``pk``::"

# 440e5e390e324d54a6a24936e7a08982
#: ../../topics/db/queries.txt:685
msgid ""
"``pk`` lookups also work across joins. For example, these three statements "
"are equivalent::"
msgstr ""
"``pk`` работает также и для связей. Например, эти три запроса идентичны::"

# 2734ae7f3b434e19bf4dc2c193c3f548
#: ../../topics/db/queries.txt:693
#, fuzzy
msgid "Escaping percent signs and underscores in ``LIKE`` statements"
msgstr ""
"Экранирование знака процента и нижнего подчеркивания для оператора LIKE"

# 6b8f4c6a30084ef9aea95d40f8316362
#: ../../topics/db/queries.txt:695
msgid ""
"The field lookups that equate to ``LIKE`` SQL statements (``iexact``, "
"``contains``, ``icontains``, ``startswith``, ``istartswith``, ``endswith`` "
"and ``iendswith``) will automatically escape the two special characters used "
"in ``LIKE`` statements -- the percent sign and the underscore. (In a "
"``LIKE`` statement, the percent sign signifies a multiple-character wildcard "
"and the underscore signifies a single-character wildcard.)"
msgstr ""
"Фильтры, эквивалентные оператору ``LIKE`` в SQL(``iexact``, ``contains``, "
"``icontains``, ``startswith``, ``istartswith``, ``endswith`` и "
"``iendswith``), автоматически экранируют два символа, используемых "
"оператором ``LIKE`` -- знак процента и нижнего подчеркивания. (В операторе "
"``LIKE``, знак процента означает \"wildcard\" из нескольких символов, "
"нижнего подчеркивания - односимвольный \"wildcard\".)"

# 3f68ccdad09a4628adaf0417bb4b9e02
#: ../../topics/db/queries.txt:702
msgid ""
"This means things should work intuitively, so the abstraction doesn't leak. "
"For example, to retrieve all the entries that contain a percent sign, just "
"use the percent sign as any other character::"
msgstr ""
"Это делает работу с API интуитивно-понятной. Например, чтобы получить все "
"записи со знаком процента, просто используйте символ знака процента как "
"любой другой символ::"

# 27aaccc5d173456191bdc649cfc4bc5d
#: ../../topics/db/queries.txt:708
msgid ""
"Django takes care of the quoting for you; the resulting SQL will look "
"something like this:"
msgstr ""
"Django самостоятельно позаботится об экранировании; полученный SQL будет "
"выглядеть приблизительно вот так:"

# d7edc2b172e44cdab998ca5284b7346a
#: ../../topics/db/queries.txt:715
msgid ""
"Same goes for underscores. Both percentage signs and underscores are handled "
"for you transparently."
msgstr ""
"Также работает и символ нижнего подчеркивания. Оба, знак процента и нижнего "
"подчеркивания, обрабатываются автоматически, прозрачно для вас."

# f968d2f6665c47a0854ca91731525e61
#: ../../topics/db/queries.txt:721
#, fuzzy
msgid "Caching and ``QuerySet``\\s"
msgstr "Кэширование и QuerySets"

# 4410cb11d332487280399ced7fbba0d0
#: ../../topics/db/queries.txt:723
msgid ""
"Each :class:`~django.db.models.query.QuerySet` contains a cache to minimize "
"database access. Understanding how it works will allow you to write the most "
"efficient code."
msgstr ""
"Каждый :class:`~django.db.models.query.QuerySet` содержит кэш, для "
"уменьшения количества запросов. Очень важно знать как он работает для "
"эффективного использования Django."

# 5212b8430b004737973f06edf4697629
#: ../../topics/db/queries.txt:727
msgid ""
"In a newly created :class:`~django.db.models.query.QuerySet`, the cache is "
"empty. The first time a :class:`~django.db.models.query.QuerySet` is "
"evaluated -- and, hence, a database query happens -- Django saves the query "
"results in the :class:`~django.db.models.query.QuerySet`’s cache and returns "
"the results that have been explicitly requested (e.g., the next element, if "
"the :class:`~django.db.models.query.QuerySet` is being iterated over). "
"Subsequent evaluations of the :class:`~django.db.models.query.QuerySet` "
"reuse the cached results."
msgstr ""
"В только что созданном :class:`~django.db.models.query.QuerySet` кеш пустой. "
"После вычисления :class:`~django.db.models.query.QuerySet`  и будет выполнен "
"запрос к базе данных -- Django сохраняет результат запроса в кеше :class:"
"`~django.db.models.query.QuerySet` и возвращает необходимый результат "
"(например, следующий элемент при итерации по :class:`~django.db.models.query."
"QuerySet`). Последующие вычисления :class:`~django.db.models.query.QuerySet` "
"используют кеш."

# 485d2b9560224de6b2e96c47e41c0c9a
#: ../../topics/db/queries.txt:736
msgid ""
"Keep this caching behavior in mind, because it may bite you if you don't use "
"your :class:`~django.db.models.query.QuerySet`\\s correctly. For example, "
"the following will create two :class:`~django.db.models.query.QuerySet`\\s, "
"evaluate them, and throw them away::"
msgstr ""
"Помните о кэшировании, чтобы использовать :class:`~django.db.models.query."
"QuerySet` правильно. Например, этот код создаст два экземпляра :class:"
"`~django.db.models.query.QuerySet` и вычислит их не сохраняя::"

# 17a35f3adc8d43928f2e476a2e1a30ef
#: ../../topics/db/queries.txt:744
msgid ""
"That means the same database query will be executed twice, effectively "
"doubling your database load. Also, there's a possibility the two lists may "
"not include the same database records, because an ``Entry`` may have been "
"added or deleted in the split second between the two requests."
msgstr ""
"Это означает, что один и тот же запрос будет выполнен дважды, удваивая "
"нагрузку на базу данных. Также, есть вероятность, что списки могут содержать "
"разные результаты, потому что запись ``Entry`` может быть добавлена или "
"удалена в доли секунды между запросами."

# 32a73dc57b404d8a85eef07fc6ceb410
#: ../../topics/db/queries.txt:749
msgid ""
"To avoid this problem, simply save the :class:`~django.db.models.query."
"QuerySet` and reuse it::"
msgstr ""
"Чтобы избежать этой проблемы, просто сохраните :class:`~django.db.models."
"query.QuerySet` и используйте его повторно::"

# 335613a407ee43bc95690fd6fafc1948
#: ../../topics/db/queries.txt:757
#, fuzzy
msgid "When ``QuerySet``\\s are not cached"
msgstr "Когда queryset не кэшируется"

# 2dc48ea0df894c6da300972aef27389a
#: ../../topics/db/queries.txt:759
msgid ""
"Querysets do not always cache their results.  When evaluating only *part* of "
"the queryset, the cache is checked, but if it is not populated then the "
"items returned by the subsequent query are not cached. Specifically, this "
"means that :ref:`limiting the queryset <limiting-querysets>` using an array "
"slice or an index will not populate the cache."
msgstr ""
"Queryset не всегда кэширует результаты. При выполнении только *части* "
"queryset-а, кэш проверяется, но если кэш пустой, выполняется запрос без "
"сохранения его результата в кэш. Это значит, что :ref:`ограничение выборки "
"<limiting-querysets>`, используя индекс или срез, как при использовании "
"списков, не заполнит кэш."

# 5283eae897104fe3a79b0f3aeb0fd225
#: ../../topics/db/queries.txt:765
msgid ""
"For example, repeatedly getting a certain index in a queryset object will "
"query the database each time::"
msgstr ""
"Например, при получении объекта по индексу несколько раз будет каждый раз "
"выполнять запрос к базе данных::"

# e6dc0170f9d045f4af43d1fa7ff5c846
#: ../../topics/db/queries.txt:772
msgid ""
"However, if the entire queryset has already been evaluated, the cache will "
"be checked instead::"
msgstr ""
"Однако, если уже был загружен весь queryset, он будет использоваться для "
"получения значения::"

# 0af62391d6384f67aea89ea28dd3a945
#: ../../topics/db/queries.txt:780
msgid ""
"Here are some examples of other actions that will result in the entire "
"queryset being evaluated and therefore populate the cache::"
msgstr ""
"Еще несколько примеров, когда загружается весь queryset и результат "
"сохраняется в кэше::"

# 1b77672ea3724ca386e2ad7e769d6d60
#: ../../topics/db/queries.txt:790
msgid ""
"Simply printing the queryset will not populate the cache. This is because "
"the call to ``__repr__()`` only returns a slice of the entire queryset."
msgstr ""
"Использование  ``print`` с queryset не заполнит кэш т.к. будет вызван "
"``__repr__()``, который показывает только часть объектов."

# 223d8b76d30d4f8b8c5539dc89d26e90
#: ../../topics/db/queries.txt:796
#, fuzzy
msgid "Complex lookups with ``Q`` objects"
msgstr "Сложные запросы с помощью объектов Q"

# 875b5fab606e49688631a843c5dc1bed
#: ../../topics/db/queries.txt:798
msgid ""
"Keyword argument queries -- in :meth:`~django.db.models.query.QuerySet."
"filter`, etc. -- are \"AND\"ed together. If you need to execute more complex "
"queries (for example, queries with ``OR`` statements), you can use :class:`Q "
"objects <django.db.models.Q>`."
msgstr ""
"Именованные аргументы функции :meth:`~django.db.models.query.QuerySet."
"filter` и др. -- объединяются оператором \"AND\". Если вам нужны более "
"сложные запросы (например, запросы с оператором ``OR``), вы можете "
"использовать :class:`объекты Q <django.db.models.Q>`."

# 674127ebd747487089e469ba45fff1d4
#: ../../topics/db/queries.txt:802
msgid ""
"A :class:`Q object <django.db.models.Q>` (``django.db.models.Q``) is an "
"object used to encapsulate a collection of keyword arguments. These keyword "
"arguments are specified as in \"Field lookups\" above."
msgstr ""
":class:`Объект Q <django.db.models.Q>` (``django.db.models.Q``) -- объект, "
"используемый для инкапсуляции множества именованных аргументов для "
"фильтрации. Аргументы определяются так же, как и в примерах выше."

# 9a3eea84c46149589a0b8881e789cc9b
#: ../../topics/db/queries.txt:806
msgid "For example, this ``Q`` object encapsulates a single ``LIKE`` query::"
msgstr "Например, этот объект ``Q`` определяет запрос ``LIKE``::"

# bbefbbfb4d0941eda81fa43a71138c0c
#: ../../topics/db/queries.txt:811
msgid ""
"``Q`` objects can be combined using the ``&`` and ``|`` operators. When an "
"operator is used on two ``Q`` objects, it yields a new ``Q`` object."
msgstr ""
"Объекты ``Q`` могут быть объединены операторами  ``&`` и ``|``, при этом "
"будет создан новый объект ``Q``."

# e9d6d727a53a43669301e5b843e7d03e
#: ../../topics/db/queries.txt:814
msgid ""
"For example, this statement yields a single ``Q`` object that represents the "
"\"OR\" of two ``\"question__startswith\"`` queries::"
msgstr ""
"Например, это определение представляет объект ``Q``, который представляет "
"операцию \"OR\" двух фильтров с ``\"question__startswith\"``::"

# 705510ff892d44f3a18cc95c9ae46d5d
#: ../../topics/db/queries.txt:819
msgid "This is equivalent to the following SQL ``WHERE`` clause::"
msgstr "Этот фильтр равнозначен такому оператору SQL ``WHERE``::"

# c13885b1e2874b65ad91bf58787a1240
#: ../../topics/db/queries.txt:823
msgid ""
"You can compose statements of arbitrary complexity by combining ``Q`` "
"objects with the ``&`` and ``|`` operators and use parenthetical grouping. "
"Also, ``Q`` objects can be negated using the ``~`` operator, allowing for "
"combined lookups that combine both a normal query and a negated (``NOT``) "
"query::"
msgstr ""
"Вы можете комбинировать различные объекты ``Q`` с операторами ``&`` и ``|`` "
"и использовать скобки. Можно использовать оператор ``~`` для "
"отрицания(``NOT``) в запросе::"

# 3ccf0a35a62341d087ac8e8fcd6a514d
#: ../../topics/db/queries.txt:830
msgid ""
"Each lookup function that takes keyword-arguments (e.g. :meth:`~django.db."
"models.query.QuerySet.filter`, :meth:`~django.db.models.query.QuerySet."
"exclude`, :meth:`~django.db.models.query.QuerySet.get`) can also be passed "
"one or more ``Q`` objects as positional (not-named) arguments. If you "
"provide multiple ``Q`` object arguments to a lookup function, the arguments "
"will be \"AND\"ed together. For example::"
msgstr ""
"Каждый метод для фильтрации, который принимает именованные аргументы "
"(например, :meth:`~django.db.models.query.QuerySet.filter`, :meth:`~django."
"db.models.query.QuerySet.exclude`, :meth:`~django.db.models.query.QuerySet."
"get`:meth:`~django.db.models.query.QuerySet.get`) также может принимать "
"объекты ``Q``. Если вы передадите несколько объектов ``Q`` как аргументы, "
"они будут объединены оператором \"AND\". Например::"

# 8a2b582e756f4e25af771abdd008aa2b
#: ../../topics/db/queries.txt:843
msgid "... roughly translates into the SQL::"
msgstr "... примерно переводится в SQL::"

# 5bd89ed905d94e80912bef8cf3999e92
#: ../../topics/db/queries.txt:848
msgid ""
"Lookup functions can mix the use of ``Q`` objects and keyword arguments. All "
"arguments provided to a lookup function (be they keyword arguments or ``Q`` "
"objects) are \"AND\"ed together. However, if a ``Q`` object is provided, it "
"must precede the definition of any keyword arguments. For example::"
msgstr ""
"Вы можете использовать одновременно объекты ``Q`` и именованные аргументы. "
"Все аргументы(будь то именованные аргументы или объекты ``Q``) объединяются "
"оператором \"AND\". Однако, если присутствует объект ``Q``, он должен "
"следовать перед именованными аргументами. Например::"

# 91663bded41c4d89abffacd92cd56d7b
#: ../../topics/db/queries.txt:858
msgid "... would be a valid query, equivalent to the previous example; but::"
msgstr "... правильный запрос, идентичный предыдущему примеру; но::"

# 824e3be530e94066a9a7ca961684fbb0
#: ../../topics/db/queries.txt:866
msgid "... would not be valid."
msgstr ""
"... будет неправильный`(Вообще Django здесь не причем. Синтаксис Python не "
"позволяет передавать именованные аргументы перед позиционными -- прим. "
"переводчика)`."

# 9c3dc79cbab141ecbcf0b54674db105b
#: ../../topics/db/queries.txt:870
msgid ""
"The `OR lookups examples`_ in the Django unit tests show some possible uses "
"of ``Q``."
msgstr ""
"Вы можете найти `примеры использования OR с Q <https://code.djangoproject."
"com/browser/django/trunk/tests/modeltests/or_lookups/tests.py>`_."

# 2a5bbb7cbe4b4308baaa21b4faf17e95
#: ../../topics/db/queries.txt:876
msgid "Comparing objects"
msgstr "Сравнение объектов"

# 3b377f861a164ba2922f651aebf8b364
#: ../../topics/db/queries.txt:878
msgid ""
"To compare two model instances, just use the standard Python comparison "
"operator, the double equals sign: ``==``. Behind the scenes, that compares "
"the primary key values of two models."
msgstr ""
"Для сравнения двух экземпляров модели, используйте стандартный оператор "
"сравнения Python, двойной знак равно: ``==``. При этом будут сравнены "
"первичные ключи."

# 34f084c0f65143feb8d10782bf55a4f1
#: ../../topics/db/queries.txt:882
msgid ""
"Using the ``Entry`` example above, the following two statements are "
"equivalent::"
msgstr ""
"Используя модель ``Entry`` из примеров выше, эти два утверждения "
"эквивалентны::"

# c67dd80bf875447c9ef8fe8c99a2a3ba
#: ../../topics/db/queries.txt:887
msgid ""
"If a model's primary key isn't called ``id``, no problem. Comparisons will "
"always use the primary key, whatever it's called. For example, if a model's "
"primary key field is called ``name``, these two statements are equivalent::"
msgstr ""
"Если первичный ключ назван не ``id`` -- это не проблема. Сравнение всегда "
"использует первичный ключ. Например, если первичный ключ назван ``name``, "
"эти два утверждения эквивалентны::"

# e79b6b8b79214d0ebdcf90a1ea3296c2
#: ../../topics/db/queries.txt:897
msgid "Deleting objects"
msgstr "Удаление объектов"

# 12c8a561a8db436cac6b9e7026b6169b
#: ../../topics/db/queries.txt:899
msgid ""
"The delete method, conveniently, is named :meth:`~django.db.models.Model."
"delete`. This method immediately deletes the object and returns the number "
"of objects deleted and a dictionary with the number of deletions per object "
"type. Example::"
msgstr ""
"Метод удаления соответственно называется :meth:`~django.db.models.Model."
"delete`. Этот метод сразу удаляет объект и возвращает количество удаленных "
"объектов, и словарь с количеством удаленных объектов для каждого типа. "
"Например::"

# f562bcec62704e03a6eeca005171bafd
#: ../../topics/db/queries.txt:907
msgid ""
"You can also delete objects in bulk. Every :class:`~django.db.models.query."
"QuerySet` has a :meth:`~django.db.models.query.QuerySet.delete` method, "
"which deletes all members of that :class:`~django.db.models.query.QuerySet`."
msgstr ""
"Можно также удалить несколько объектов сразу. Каждый :class:`~django.db."
"models.query.QuerySet` имеет метод :meth:`~django.db.models.query.QuerySet."
"delete`, который удаляет все объекты из :class:`~django.db.models.query."
"QuerySet`."

# 29d5a6d552b34dfc902b9af19607082a
#: ../../topics/db/queries.txt:912
msgid ""
"For example, this deletes all ``Entry`` objects with a ``pub_date`` year of "
"2005::"
msgstr ""
"Например, этот код удаляет все объекты ``Entry`` с годом ``pub_date`` равным "
"2005::"

# 42fafab98e06479d880cc1d583dee050
#: ../../topics/db/queries.txt:918
msgid ""
"Keep in mind that this will, whenever possible, be executed purely in SQL, "
"and so the ``delete()`` methods of individual object instances will not "
"necessarily be called during the process. If you've provided a custom "
"``delete()`` method on a model class and want to ensure that it is called, "
"you will need to \"manually\" delete instances of that model (e.g., by "
"iterating over a :class:`~django.db.models.query.QuerySet` and calling "
"``delete()`` on each object individually) rather than using the bulk :meth:"
"`~django.db.models.query.QuerySet.delete` method of a :class:`~django.db."
"models.query.QuerySet`."
msgstr ""
"Учтите, что при любой возможности будет использован непосредственно SQL "
"запрос, то есть метод ``delete()`` объекта может и не использоваться при "
"удалении. Если вы переопределяете метод ``delete()`` модели и хотите быть "
"уверенным, что он будет вызван, вы должны \"самостоятельно\" удалить объект "
"модели (например, использовать цикл по :class:`~django.db.models.query."
"QuerySet` и вызывать метод ``delete()`` для каждого объекта) не используя "
"метод :meth:`~django.db.models.query.QuerySet.delete` :class:`~django.db."
"models.query.QuerySet`."

# 0ede23c152e542dd988752b6af812fed
#: ../../topics/db/queries.txt:928
msgid ""
"When Django deletes an object, by default it emulates the behavior of the "
"SQL constraint ``ON DELETE CASCADE`` -- in other words, any objects which "
"had foreign keys pointing at the object to be deleted will be deleted along "
"with it. For example::"
msgstr ""
"При удалении Django повторяет поведение SQL выражения ``ON DELETE CASCADE`` "
"-- другими словами, каждый объект, имеющий связь(``ForeignKey``) с удаляемым "
"объектом, будет также удален. Например::"

# e9a498fc256b4a4c8d84a92ca9800765
#: ../../topics/db/queries.txt:937
msgid ""
"This cascade behavior is customizable via the :attr:`~django.db.models."
"ForeignKey.on_delete` argument to the :class:`~django.db.models.ForeignKey`."
msgstr ""
"Это поведение можно изменить, определив аргумент :attr:`~django.db.models."
"ForeignKey.on_delete` поля :class:`~django.db.models.ForeignKey`."

# f67a2d004f8044ad821ce0afbcb87b44
#: ../../topics/db/queries.txt:941
msgid ""
"Note that :meth:`~django.db.models.query.QuerySet.delete` is the only :class:"
"`~django.db.models.query.QuerySet` method that is not exposed on a :class:"
"`~django.db.models.Manager` itself. This is a safety mechanism to prevent "
"you from accidentally requesting ``Entry.objects.delete()``, and deleting "
"*all* the entries. If you *do* want to delete all the objects, then you have "
"to explicitly request a complete query set::"
msgstr ""
"Метод :meth:`~django.db.models.query.QuerySet.delete` содержится только в :"
"class:`~django.db.models.query.QuerySet` и не существует в :class:`~django."
"db.models.Manager`. Это сделано, чтобы вы случайно не выполнили ``Entry."
"objects.delete()``, и не удалили *все* записи. Если вы *на самом деле* "
"хотите удалить все объекты, сначала явно получите ``QuerySet``, содержащий "
"все записи::"

# ae2a313325c54157b06781adbd7f8ac1
#: ../../topics/db/queries.txt:953
msgid "Copying model instances"
msgstr "Копирование объекта модели"

# 81c2d5d79d1d41c48414728113e1a885
#: ../../topics/db/queries.txt:955
msgid ""
"Although there is no built-in method for copying model instances, it is "
"possible to easily create new instance with all fields' values copied. In "
"the simplest case, you can just set ``pk`` to ``None``. Using our blog "
"example::"
msgstr ""
"Хоть модель и не содержит встроенного метода для копирования объекта модели, "
"очень просто создать новый экземпляр с копией всех полей другого объекта. "
"Самый простой вариант -- установите ``pk`` в ``None``. Используя модели из "
"примеров выше::"

# 4cf698eb363649559b38f6aebd891382
#: ../../topics/db/queries.txt:965
msgid ""
"Things get more complicated if you use inheritance. Consider a subclass of "
"``Blog``::"
msgstr ""
"Все немного сложнее, если вы используете наследование. Рассмотрим подкласс "
"``Blog``::"

# 4aafc8d17e2a41669e1bab2715b2bb84
#: ../../topics/db/queries.txt:974
msgid ""
"Due to how inheritance works, you have to set both ``pk`` and ``id`` to "
"None::"
msgstr ""
"Учитывая, как работает наследование, необходимо установить и ``pk`` и ``id`` "
"в None::"

#: ../../topics/db/queries.txt:980
msgid ""
"This process doesn't copy relations that aren't part of the model's database "
"table. For example, ``Entry`` has a ``ManyToManyField`` to ``Author``. After "
"duplicating an entry, you must set the many-to-many relations for the new "
"entry::"
msgstr ""

#: ../../topics/db/queries.txt:991
msgid ""
"For a ``OneToOneField``, you must duplicate the related object and assign it "
"to the new object's field to avoid violating the one-to-one unique "
"constraint. For example, assuming ``entry`` is already duplicated as above::"
msgstr ""

# 4e99683ce0e947be9167c79edb058c5f
#: ../../topics/db/queries.txt:1003
msgid "Updating multiple objects at once"
msgstr "Изменение нескольких объектов"

# d3d4c95936a4497eabd03a6652c10613
#: ../../topics/db/queries.txt:1005
msgid ""
"Sometimes you want to set a field to a particular value for all the objects "
"in a :class:`~django.db.models.query.QuerySet`. You can do this with the :"
"meth:`~django.db.models.query.QuerySet.update` method. For example::"
msgstr ""
"Если вам понадобиться установить значение поля для всех объектов в :class:"
"`~django.db.models.query.QuerySet`, используйте метод :meth:`~django.db."
"models.query.QuerySet.update`. Например::"

# bf7b6e6c7753494291b9891c9dc5b89b
#: ../../topics/db/queries.txt:1012
msgid ""
"You can only set non-relation fields and :class:`~django.db.models."
"ForeignKey` fields using this method. To update a non-relation field, "
"provide the new value as a constant. To update :class:`~django.db.models."
"ForeignKey` fields, set the new value to be the new model instance you want "
"to point to. For example::"
msgstr ""
"Вы можете изменить только обычные поля или :class:`~django.db.models."
"ForeignKey`, используя этот метод. Для обычных полей просто определите новое "
"значение как константу. Чтобы обновить :class:`~django.db.models."
"ForeignKey`, укажите объект связанной модели. Например::"

# 43a9217ba7a542afb5e96c6444f638d7
#: ../../topics/db/queries.txt:1022
msgid ""
"The ``update()`` method is applied instantly and returns the number of rows "
"matched by the query (which may not be equal to the number of rows updated "
"if some rows already have the new value). The only restriction on the :class:"
"`~django.db.models.query.QuerySet` being updated is that it can only access "
"one database table: the model's main table. You can filter based on related "
"fields, but you can only update columns in the model's main table. Example::"
msgstr ""
"Метод ``update()`` применяется мгновенно и возвращает количество записей, "
"удовлетворяющих запросу(что может быть не равно количеству обновленных "
"записей, если они уже содержат новые значения). Единственное ограничение для "
"изменяемого  :class:`~django.db.models.query.QuerySet` -- он может изменять "
"только одну таблицу в базе данных: главную таблицу модели. Вы можете "
"использовать фильтры по связанным полям, но вы можете изменять поля только "
"таблицы изменяемой модели. Например::"

# c32824823bdb4d788282ff418af903b7
#: ../../topics/db/queries.txt:1035
msgid ""
"Be aware that the ``update()`` method is converted directly to an SQL "
"statement. It is a bulk operation for direct updates. It doesn't run any :"
"meth:`~django.db.models.Model.save` methods on your models, or emit the "
"``pre_save`` or ``post_save`` signals (which are a consequence of calling :"
"meth:`~django.db.models.Model.save`), or honor the :attr:`~django.db.models."
"DateField.auto_now` field option. If you want to save every item in a :class:"
"`~django.db.models.query.QuerySet` and make sure that the :meth:`~django.db."
"models.Model.save` method is called on each instance, you don't need any "
"special function to handle that. Just loop over them and call :meth:`~django."
"db.models.Model.save`::"
msgstr ""
"Учтите, что метод ``update()`` использует непосредственно SQL запрос. Это "
"операция для массового изменения. Метод :meth:`~django.db.models.Model.save` "
"модели не будет вызван, сигналы ``pre_save`` или ``post_save`` не будут "
"вызваны (которые являются следствием вызова :meth:`~django.db.models.Model."
"save`), аргумент :attr:`~django.db.models.DateField.auto_now` не будет "
"учтен. Если вы хотите сохранить каждый объект в :class:`~django.db.models."
"query.QuerySet` и удостовериться что метод :meth:`~django.db.models.Model."
"save` вызван для каждого объекта, вы не должны использовать какой-либо "
"специальный метод. Просто используйте цикл и вызовите метод :meth:`~django."
"db.models.Model.save`::"

# 6ec6bee63e7348d1aeb7ce9230d36876
#: ../../topics/db/queries.txt:1049
msgid ""
"Calls to update can also use :class:`F expressions <django.db.models.F>` to "
"update one field based on the value of another field in the model. This is "
"especially useful for incrementing counters based upon their current value. "
"For example, to increment the pingback count for every entry in the blog::"
msgstr ""
"Метод ``update()`` может использовать :class:`объект F <django.db.models.F>` "
"для обновления одного поля значением другого поля модели. Это особенно "
"полезно для изменения счетчика. Например, увеличить значение ``n_pingbacks`` "
"на один для каждой записи::"

# 512e4e1efe294d0d9da9579148de042d
#: ../../topics/db/queries.txt:1056
msgid ""
"However, unlike ``F()`` objects in filter and exclude clauses, you can't "
"introduce joins when you use ``F()`` objects in an update -- you can only "
"reference fields local to the model being updated. If you attempt to "
"introduce a join with an ``F()`` object, a ``FieldError`` will be raised::"
msgstr ""
"Однако, в отличии от использования объектов ``F()`` в методах ``filter()`` и "
"``exclude()``, вы не можете использовать связанные поля при обновлении. Если "
"вы будете использовать связанное поле в объекте ``F()``, буде вызвано "
"исключение ``FieldError``::"

# 1181022be17a492db4e34ced0747fcc4
#: ../../topics/db/queries.txt:1067
msgid "Related objects"
msgstr "Связанные объекты"

# 12ca6be79571436c817ebce5e7d6f5f8
#: ../../topics/db/queries.txt:1069
msgid ""
"When you define a relationship in a model (i.e., a :class:`~django.db.models."
"ForeignKey`, :class:`~django.db.models.OneToOneField`, or :class:`~django.db."
"models.ManyToManyField`), instances of that model will have a convenient API "
"to access the related object(s)."
msgstr ""
"Используя связанные объекты в модели (например, :class:`~django.db.models."
"ForeignKey`, :class:`~django.db.models.OneToOneField` или :class:`~django.db."
"models.ManyToManyField`), в объект модели будет добавлен API для работы со "
"связанными объектами."

# 76a00e3eabcb497b9cdaf9000060755e
#: ../../topics/db/queries.txt:1075
msgid ""
"Using the models at the top of this page, for example, an ``Entry`` object "
"``e`` can get its associated ``Blog`` object by accessing the ``blog`` "
"attribute: ``e.blog``."
msgstr ""
"Используя модели из примеров выше, например, объект ``e`` модели ``Entry``, "
"может получить связанные объекты ``Blog`` используя атрибут ``blog``: ``e."
"blog``."

# a6ec2c148731455cb7b7381415382104
#: ../../topics/db/queries.txt:1079
msgid ""
"(Behind the scenes, this functionality is implemented by Python "
"descriptors_. This shouldn't really matter to you, but we point it out here "
"for the curious.)"
msgstr ""
"(Это все работает благодаря  `дескрипторам Python <http://users.rcn.com/"
"python/download/Descriptor.htm>`_. Это совсем не важно и упоминается для "
"любознательных.)"

# 2432ded29ac746fc9cc2b23e86703616
#: ../../topics/db/queries.txt:1082
msgid ""
"Django also creates API accessors for the \"other\" side of the relationship "
"-- the link from the related model to the model that defines the "
"relationship. For example, a ``Blog`` object ``b`` has access to a list of "
"all related ``Entry`` objects via the ``entry_set`` attribute: ``b.entry_set."
"all()``."
msgstr ""
"Django также предоставляет доступ к связанным объектам с \"другой\" стороны  "
"-- ссылка с связанного объекта на объект, который определяет связь. "
"Например, объект ``b`` модели ``Blog`` имеет доступ ко всем связанным "
"объектам ``Entry`` через атрибут ``entry_set``: ``b.entry_set.all()``."

# f9c620084c2340699062d5cd7e99b510
#: ../../topics/db/queries.txt:1087
msgid ""
"All examples in this section use the sample ``Blog``, ``Author`` and "
"``Entry`` models defined at the top of this page."
msgstr ""
"Все примеры в этом разделе используют вышеупомянутые модели ``Blog``, "
"``Author`` и ``Entry``."

# ddba1e5f35134b1d9b42c3f6e3e05951
#: ../../topics/db/queries.txt:1093
msgid "One-to-many relationships"
msgstr "Связь один-к-многим"

# 2a588632bef445558e59b9e4f6e921d4
#: ../../topics/db/queries.txt:1096
msgid "Forward"
msgstr "Прямая"

# ca55dce52f474004a985e923621508ba
#: ../../topics/db/queries.txt:1098
msgid ""
"If a model has a :class:`~django.db.models.ForeignKey`, instances of that "
"model will have access to the related (foreign) object via a simple "
"attribute of the model."
msgstr ""
"Если модель содержит :class:`~django.db.models.ForeignKey`, объект этой "
"модели может получить связанный объект через атрибут модели."

# 046b04d00de8478c877833241743ad96
#: ../../topics/db/queries.txt:1107
msgid ""
"You can get and set via a foreign-key attribute. As you may expect, changes "
"to the foreign key aren't saved to the database until you call :meth:"
"`~django.db.models.Model.save`. Example::"
msgstr ""
"Вы можете получить и изменить его через атрибут внешнего ключа. Как вы "
"можете предполагать, изменения не будут сохранены в базу данных, пока не "
"будет вызван метод :meth:`~django.db.models.Model.save`. Например::"

# a7dfa9b31d80453ea55661fb837380e5
#: ../../topics/db/queries.txt:1115
msgid ""
"If a :class:`~django.db.models.ForeignKey` field has ``null=True`` set (i."
"e., it allows ``NULL`` values), you can assign ``None`` to remove the "
"relation. Example::"
msgstr ""
"Если поле :class:`~django.db.models.ForeignKey` содержит ``null=True`` (то "
"есть разрешено значение ``NULL``), вы можете указать ``None`` для этого "
"поля. Например::"

# aaecabd4a9994a2aabee92706f81442a
#: ../../topics/db/queries.txt:1123
msgid ""
"Forward access to one-to-many relationships is cached the first time the "
"related object is accessed. Subsequent accesses to the foreign key on the "
"same object instance are cached. Example::"
msgstr ""
"Прямой доступ для связи один-ко-многим кэширует полученное значение при "
"первом обращении. Последующие обращения к внешнему ключу этого же объекта "
"будут использовать кэшированное значение. Например::"

# b0c2840f6ebc48c9821ae1199ac04cb9
#: ../../topics/db/queries.txt:1131
msgid ""
"Note that the :meth:`~django.db.models.query.QuerySet.select_related` :class:"
"`~django.db.models.query.QuerySet` method recursively prepopulates the cache "
"of all one-to-many relationships ahead of time. Example::"
msgstr ""
"Запомните, что вызов метода :meth:`~django.db.models.query.QuerySet."
"select_related` :class:`~django.db.models.query.QuerySet` рекурсивно "
"заполняет кэш значениями для всех связей один-ко-многим. Например::"

# 2ac51945c1724da08d97c46265d95795
#: ../../topics/db/queries.txt:1142
msgid "Following relationships \"backward\""
msgstr "\"Обратная\" связь"

# 6fa632cc418e43fe9e9403e72960ca1c
#: ../../topics/db/queries.txt:1144
msgid ""
"If a model has a :class:`~django.db.models.ForeignKey`, instances of the "
"foreign-key model will have access to a :class:`~django.db.models.Manager` "
"that returns all instances of the first model. By default, this :class:"
"`~django.db.models.Manager` is named ``FOO_set``, where ``FOO`` is the "
"source model name, lowercased. This :class:`~django.db.models.Manager` "
"returns ``QuerySets``, which can be filtered and manipulated as described in "
"the \"Retrieving objects\" section above."
msgstr ""
"Если модель содержит :class:`~django.db.models.ForeignKey, экземпляры "
"модели, указанной в :class:`~django.db.models.ForeignKey`, будет содержать :"
"class:`~django.db.models.Manager`, который вернет все связанные объекты "
"первой модели. По-умолчанию, этот :class:`~django.db.models.Manager` "
"называется ``FOO_set``, где ``FOO`` название основной модели в нижнем "
"регистре. Этот :class:`~django.db.models.Manager` возвращает ``QuerySets``, "
"который может быть отфильтрован и изменен как было описано в разделе "
"\"Получение объектов\"."

# 2b06ad760bd24dd485cae060c6fb842d
#: ../../topics/db/queries.txt:1161
msgid ""
"You can override the ``FOO_set`` name by setting the :attr:`~django.db."
"models.ForeignKey.related_name` parameter in the :class:`~django.db.models."
"ForeignKey` definition. For example, if the ``Entry`` model was altered to "
"``blog = ForeignKey(Blog, on_delete=models.CASCADE, "
"related_name='entries')``, the above example code would look like this::"
msgstr ""
"Вы можете переопределить название ``FOO_set``, установив параметр :attr:"
"`~django.db.models.ForeignKey.related_name` при определении :class:`~django."
"db.models.ForeignKey`. Например, если бы модель ``Entry`` содержала ``blog = "
"ForeignKey(Blog, on_delete=models.CASCADE, related_name='entries')``, пример "
"выше выглядел бы как::"

# 358de7d8ffa841bcaf2dcf4c024c9131
#: ../../topics/db/queries.txt:1177
msgid "Using a custom reverse manager"
msgstr "Использование своего менеджера для обратных связей"

# 4e907f69c16145e887160968c0e2e9d3
#: ../../topics/db/queries.txt:1179
msgid ""
"By default the :class:`~django.db.models.fields.related.RelatedManager` used "
"for reverse relations is a subclass of the :ref:`default manager <manager-"
"names>` for that model. If you would like to specify a different manager for "
"a given query you can use the following syntax::"
msgstr ""
"По умолчанию для обратных связей используется менеджер :class:`~django.db."
"models.fields.related.RelatedManager`, который является дочерним классом :"
"ref:`менеджера по умолчанию <manager-names>` модели. Чтобы указать свой "
"менеджер, используйте следующий подход::"

# 96e04fa7ddaa46df91b6ad5e2fb4deeb
#: ../../topics/db/queries.txt:1194
msgid ""
"If ``EntryManager`` performed default filtering in its ``get_queryset()`` "
"method, that filtering would apply to the ``all()`` call."
msgstr ""
"Если ``EntryManager`` выполняет фильтрацию в методе ``get_queryset()``, она "
"будет выполнена и при вызове ``all()``."

# cb02797f3a4e4ef29a6c1928397c4bca
#: ../../topics/db/queries.txt:1197
msgid ""
"Of course, specifying a custom reverse manager also enables you to call its "
"custom methods::"
msgstr "Также вы можете вызывать методы указанного менеджера::"

# 216f9640763048febb0bd4facc1c8c5e
#: ../../topics/db/queries.txt:1203
msgid "Additional methods to handle related objects"
msgstr "Дополнительные методы менеджера связанных объектов"

# 961836648e6a477e824770cf337525fd
#: ../../topics/db/queries.txt:1205
msgid ""
"In addition to the :class:`~django.db.models.query.QuerySet` methods defined "
"in \"Retrieving objects\" above, the :class:`~django.db.models.ForeignKey` :"
"class:`~django.db.models.Manager` has additional methods used to handle the "
"set of related objects. A synopsis of each is below, and complete details "
"can be found in the :doc:`related objects reference </ref/models/relations>`."
msgstr ""
"В дополнение к методам :class:`~django.db.models.query.QuerySet` описанным в "
"разделе \"Получение объектов\", \"обратный\" менеджер  :class:`~django.db."
"models.ForeignKey` содержит дополнительные методы для работы со связанными "
"объектами. Краткий список находится ниже, полное описание смотрите в разделе "
"о :doc:`связанных объектах </ref/models/relations>`."

# 31dad4f72fbc4ba2b12661614903e5d1
#: ../../topics/db/queries.txt:1212
#, fuzzy
msgid "``add(obj1, obj2, ...)``"
msgstr "``add(obj1, obj2, ...)``"

# 216f9640763048febb0bd4facc1c8c5e
#: ../../topics/db/queries.txt:1212
msgid "Adds the specified model objects to the related object set."
msgstr "Добавляет указанный объект к связанным объектам."

# 41ef0939d5794ff09a4e58ec2d7bb183
#: ../../topics/db/queries.txt:1216
#, fuzzy
msgid "``create(**kwargs)``"
msgstr "``create(**kwargs)``"

# db0515d208244ec39a0a80028f6a47c1
#: ../../topics/db/queries.txt:1215
msgid ""
"Creates a new object, saves it and puts it in the related object set. "
"Returns the newly created object."
msgstr ""
"Создает новый объект, сохраняет его и добавляет к связанным объектам. "
"Возвращает созданный объект."

# 0856c5bd8c3540929b40a4378dc66437
#: ../../topics/db/queries.txt:1219
#, fuzzy
msgid "``remove(obj1, obj2, ...)``"
msgstr "``remove(obj1, obj2, ...)``"

# deda08b2ca3244ea8106ec0558c7d55c
#: ../../topics/db/queries.txt:1219
msgid "Removes the specified model objects from the related object set."
msgstr "Удаляет указанный объект из списка связанных объектов."

# 934d5a36831b4105a5a5ba019743581d
#: ../../topics/db/queries.txt:1222
#, fuzzy
msgid "``clear()``"
msgstr "``clear()``"

# 7389187100f54ca7972ee45ce505af34
#: ../../topics/db/queries.txt:1222
msgid "Removes all objects from the related object set."
msgstr "Удаляет все объекты из списка связанных."

#: ../../topics/db/queries.txt:1225
#, fuzzy
msgid "``set(objs)``"
msgstr "``set(objs)``"

# 0895351da3b84730bedbb16e1bdeaecd
#: ../../topics/db/queries.txt:1225
msgid "Replace the set of related objects."
msgstr "Запросы со связанными объектами."

# f3a792203f994426b93f1ff3b68a491e
#: ../../topics/db/queries.txt:1227
#, fuzzy
msgid ""
"To assign the members of a related set, use the ``set()`` method with an "
"iterable of object instances. For example, if ``e1`` and ``e2`` are "
"``Entry`` instances::"
msgstr ""
"Чтобы добавить несколько связанных объектов одним махом, просто установите "
"любой итератор. Итератор должен содержать объекты или просто значения "
"первичных ключей. Например::"

# 9c0557108268448c94282e171e6e3893
#: ../../topics/db/queries.txt:1234
msgid ""
"If the ``clear()`` method is available, any pre-existing objects will be "
"removed from the ``entry_set`` before all objects in the iterable (in this "
"case, a list) are added to the set. If the ``clear()`` method is *not* "
"available, all objects in the iterable will be added without removing any "
"existing elements."
msgstr ""
"Если доступен метод ``clear()``, все связанные объекты будут удаленны из "
"``entry_set`` перед тем, как все объекты из итератора(в примере это список) "
"будут добавлены в список связанных объектов. Если метод ``clear()`` *не* "
"доступен, все объекты из итератора будут добавлены без удаления существующих "
"объектов."

# 592feacc21004d15b4cfd91271940422
#: ../../topics/db/queries.txt:1240
msgid ""
"Each \"reverse\" operation described in this section has an immediate effect "
"on the database. Every addition, creation and deletion is immediately and "
"automatically saved to the database."
msgstr ""
"Все вышеупомянутые методы сохраняют результат в базу. Каждое добавление, "
"создание или удаление сразу и автоматически выполняет соответствующий запрос "
"в базу данных."

# 6be458cd37dc4e59ae7498f5729fec3d
#: ../../topics/db/queries.txt:1247
msgid "Many-to-many relationships"
msgstr "Связь многие-ко-многим"

# 9a401310d540429bb0db647a8a06ab3b
#: ../../topics/db/queries.txt:1249
#, fuzzy
msgid ""
"Both ends of a many-to-many relationship get automatic API access to the "
"other end. The API works similar to a \"backward\" one-to-many relationship, "
"above."
msgstr ""
"Обе \"стороны\" связи многое-ко-многим автоматически получают API для работы "
"со связанными объектами. Этот API работает так же, как и \"обратный\" "
"менеджер для связи один-ко-многим, описанный выше."

# f00cec0ad3044822ae04b25f8996a9b0
#: ../../topics/db/queries.txt:1252
#, fuzzy
msgid ""
"One difference is in the attribute naming: The model that defines the :class:"
"`~django.db.models.ManyToManyField` uses the attribute name of that field "
"itself, whereas the \"reverse\" model uses the lowercased model name of the "
"original model, plus ``'_set'`` (just like reverse one-to-many "
"relationships)."
msgstr ""
"Единственное отличие: Модель, содержащая :class:`~django.db.models."
"ManyToManyField`, использует имя атрибута этого поля, в то время, как "
"\"обратная\" модель использует название, состоящее из названия модели в "
"нижнем регистре плюс ``'_set'`` (так же, как и для связи один-ко-многим)."

# 5d56c76b4efd46ef8b082d43eba6ed1a
#: ../../topics/db/queries.txt:1257
msgid "An example makes this easier to understand::"
msgstr "Пример все разъяснит::"

# ed67193473614bfca7a6d6917f7118e5
#: ../../topics/db/queries.txt:1267
msgid ""
"Like :class:`~django.db.models.ForeignKey`, :class:`~django.db.models."
"ManyToManyField` can specify :attr:`~django.db.models.ManyToManyField."
"related_name`. In the above example, if the :class:`~django.db.models."
"ManyToManyField` in ``Entry`` had specified ``related_name='entries'``, then "
"each ``Author`` instance would have an ``entries`` attribute instead of "
"``entry_set``."
msgstr ""
"Так же, как и :class:`~django.db.models.ForeignKey`, :class:`~django.db."
"models.ManyToManyField` позволяет определить :attr:`~django.db.models."
"ManyToManyField.related_name`. В примере выше, если поле  :class:`~django.db."
"models.ManyToManyField` модели ``Entry`` содержит "
"``related_name='entries'``, тогда каждый объект модели ``Author`` будет с "
"атрибутом ``entries`` вместо ``entry_set``."

#: ../../topics/db/queries.txt:1274
msgid ""
"Another difference from one-to-many relationships is that in addition to "
"model instances,  the ``add()``, ``set()``, and ``remove()`` methods on many-"
"to-many relationships accept primary key values. For example, if ``e1`` and "
"``e2`` are ``Entry`` instances, then these ``set()`` calls work identically::"
msgstr ""

# 58dc0610d67d4894aafc637cfe84e268
#: ../../topics/db/queries.txt:1284
msgid "One-to-one relationships"
msgstr "Связь один-к-одному"

# 2518ca1f41df40339d225f06c55de122
#: ../../topics/db/queries.txt:1286
msgid ""
"One-to-one relationships are very similar to many-to-one relationships. If "
"you define a :class:`~django.db.models.OneToOneField` on your model, "
"instances of that model will have access to the related object via a simple "
"attribute of the model."
msgstr ""
"Связь один-к-одному похожа на связь многое-к-одному. При добавлении :class:"
"`~django.db.models.OneToOneField` в модель, объект этой модели будет "
"содержать ссылку на связанный объект через атрибут модели."

# 5bac17ba464a44eb8ef73610c30e948f
#: ../../topics/db/queries.txt:1291
msgid "For example::"
msgstr "Например::"

# b535b1d1d0e74fa8a83cef302cac0422
#: ../../topics/db/queries.txt:1300
msgid ""
"The difference comes in \"reverse\" queries. The related model in a one-to-"
"one relationship also has access to a :class:`~django.db.models.Manager` "
"object, but that :class:`~django.db.models.Manager` represents a single "
"object, rather than a collection of objects::"
msgstr ""
"Разница в обратной связи. Связанная модель также имеет доступ к объекту :"
"class:`~django.db.models.Manager`, но :class:`~django.db.models.Manager` "
"представляет один объект, а не множество объектов::"

# b6b0e183769c4289a508aa9db77ac531
#: ../../topics/db/queries.txt:1308
msgid ""
"If no object has been assigned to this relationship, Django will raise a "
"``DoesNotExist`` exception."
msgstr ""
"Если ни один объект не добавлен в связь, Django вызовет исключение "
"``DoesNotExist``."

# 117c826dc5e149499692bc3f3b44c688
#: ../../topics/db/queries.txt:1311
msgid ""
"Instances can be assigned to the reverse relationship in the same way as you "
"would assign the forward relationship::"
msgstr ""
"Объект может быть назначен через обратную связь так же, как и через прямую::"

# 2c5d938af4784825997033f0a4011056
#: ../../topics/db/queries.txt:1317
msgid "How are the backward relationships possible?"
msgstr "Как работает обратная связь?"

# d86cc532225542b2be233f21db22980d
#: ../../topics/db/queries.txt:1319
msgid ""
"Other object-relational mappers require you to define relationships on both "
"sides. The Django developers believe this is a violation of the DRY (Don't "
"Repeat Yourself) principle, so Django only requires you to define the "
"relationship on one end."
msgstr ""
"Другие ORM требуют определять связь с обеих сторон. Разработчики Django "
"считают, что это противоречит принципу DRY (Don't Repeat Yourself - не "
"повторяй себя), по этому принципу Django требует определить связь только для "
"одной модели."

# 7928531e4fa4471397b2b353b22d6361
#: ../../topics/db/queries.txt:1324
msgid ""
"But how is this possible, given that a model class doesn't know which other "
"model classes are related to it until those other model classes are loaded?"
msgstr ""
"Но как это возможно, учитывая, что модель не знает, какие другие модели "
"связаны с ней, пока классы этих моделей не будут загружены?"

# d256060e25d34cbf8c6ff2972ebd432e
#: ../../topics/db/queries.txt:1327
msgid ""
"The answer lies in the :data:`app registry <django.apps.apps>`. When Django "
"starts, it imports each application listed in :setting:`INSTALLED_APPS`, and "
"then the ``models`` module inside each application. Whenever a new model "
"class is created, Django adds backward-relationships to any related models. "
"If the related models haven't been imported yet, Django keeps tracks of the "
"relationships and adds them when the related models eventually are imported."
msgstr ""
"Все происходит при :data:`регистрации приложений <django.apps.apps>`. Когда "
"запускается Django, происходит импорт всех приложений из :setting:"
"`INSTALLED_APPS`, далее импорт модуля ``models`` этих приложений. Когда "
"создается класс модели, Django добавляет обратные связи для всех связанных "
"моделей. Если связанная модель еще не импортирована, Django запоминает эту "
"модель и добавит связь при ее импорте."

# d0e4ac6238fb4c3992f01c27421e5aeb
#: ../../topics/db/queries.txt:1334
msgid ""
"For this reason, it's particularly important that all the models you're "
"using be defined in applications listed in :setting:`INSTALLED_APPS`. "
"Otherwise, backwards relations may not work properly."
msgstr ""
"Поэтому важно, чтобы все модели, которые вы используете, находились в "
"приложениях из :setting:`INSTALLED_APPS`. Иначе связи не будут работать."

# 0895351da3b84730bedbb16e1bdeaecd
#: ../../topics/db/queries.txt:1339
msgid "Queries over related objects"
msgstr "Запросы со связанными объектами"

# c6ef9029545d436584d6bcda98e006d5
#: ../../topics/db/queries.txt:1341
msgid ""
"Queries involving related objects follow the same rules as queries involving "
"normal value fields. When specifying the value for a query to match, you may "
"use either an object instance itself, or the primary key value for the "
"object."
msgstr ""
"Запросы со связанными объектами используют те же правила, что и с обычными "
"значениями. Вы можете использовать объект или значение первичного ключа."

# 0f6f6b8d11404210b59d152cff37f99c
#: ../../topics/db/queries.txt:1345
msgid ""
"For example, if you have a Blog object ``b`` with ``id=5``, the following "
"three queries would be identical::"
msgstr ""
"Например, если у вас объект ``Blog`` ``b`` с ``id=5``, эти три запроса будут "
"идентичны::"

# ecf21c78d1ee407092fd93800876f849
#: ../../topics/db/queries.txt:1353
msgid "Falling back to raw SQL"
msgstr "Использование чистого SQL"

# eea72f40671a41d2bf2c11ec33d9ba86
#: ../../topics/db/queries.txt:1355
msgid ""
"If you find yourself needing to write an SQL query that is too complex for "
"Django's database-mapper to handle, you can fall back on writing SQL by "
"hand. Django has a couple of options for writing raw SQL queries; see :doc:`/"
"topics/db/sql`."
msgstr ""
"Если вам нужно создать SQL запрос, который слишком сложен для API Django, вы "
"можете использовать чистый SQL. Django имеет несколько возможностей "
"использовать SQL запросы; смотрите :doc:`/topics/db/sql`."

# 5c5bcff1298f471abee7b10697f6d16a
#: ../../topics/db/queries.txt:1360
msgid ""
"Finally, it's important to note that the Django database layer is merely an "
"interface to your database. You can access your database via other tools, "
"programming languages or database frameworks; there's nothing Django-"
"specific about your database."
msgstr ""
"Наконец, важно отметить, что API Django для работы с базой данных является "
"лишь интерфейсом к базе данных. Вы можете получить доступ к базе данных "
"через другие инструменты, языки программирования и фреймворки; Django не "
"делает ничего специфического с вашей базой данных."

# 1aaed1cd411b456eab1caa3d6692aad1
#~ msgid ""
#~ "In this example, ``e1`` and ``e2`` can be full Entry instances, or "
#~ "integer primary key values."
#~ msgstr ""
#~ "В этом примере ``e1`` и ``e2`` могут быть экземплярами ``Entry``, или "
#~ "значениями первичного ключа."

# 21c776a9daa54041932d385a74e8683e
#, fuzzy
#~ msgid "contains"
#~ msgstr ":lookup:`contains`"

#~ msgid "The return value describing the number of objects deleted was added."
#~ msgstr "Было добавлено возвращение данных об удаленных объектах."

# fa510ea6d64c461a85892099ce76d86f
#~ msgid ""
#~ "This process does not copy related objects. If you want to copy "
#~ "relations, you have to write a little bit more code. In our example, "
#~ "``Entry`` has a many to many field to ``Author``::"
#~ msgstr ""
#~ "Связанные объекты не копируются. Если вы хотите скопировать связанные "
#~ "объекты, нужно написать немного больше кода. В нашем примере, ``Entry`` "
#~ "содержит связь многие-ко-многим к модели ``Author``::"

# cea7d992185544e489fdc073bf92c131
#~ msgid "The power operator ``**`` was added."
#~ msgstr "Был добавлен оператор вознесения в степень ``**``."

# e0c354100c6a4f72b5ed282f90ac2cf3
#~ msgid ""
#~ "All of this behavior also applies to :meth:`~django.db.models.query."
#~ "QuerySet.exclude`: all the conditions in a single :meth:`~django.db."
#~ "models.query.QuerySet.exclude` statement apply to a single instance (if "
#~ "those conditions are talking about the same multi-valued relation). "
#~ "Conditions in subsequent :meth:`~django.db.models.query.QuerySet.filter` "
#~ "or :meth:`~django.db.models.query.QuerySet.exclude` calls that refer to "
#~ "the same relation may end up filtering on different linked objects."
#~ msgstr ""
#~ "Все эти правила также распространяются и на :meth:`~django.db.models."
#~ "query.QuerySet.exclude`: все условия в одном :meth:`~django.db.models."
#~ "query.QuerySet.exclude` применяются к одному объекту (если эти условия "
#~ "относятся к одной связи). Условия в последующих вызовах :meth:`~django.db."
#~ "models.query.QuerySet.filter` или :meth:`~django.db.models.query.QuerySet."
#~ "exclude` для одной связи могут применяться к различным связанным объектам."

# a1daedded2014169aa4c423b77f1dda1
#~ msgid ""
#~ "You import the model class from wherever it lives on the Python path, as "
#~ "you may expect. (We point this out here because previous Django versions "
#~ "required funky model importing.)"
#~ msgstr ""
#~ "Вы можете импортировать класс модели, как и любой другой класс в Python. "
#~ "(Мы упомянули это потому что в ранних версиях Django импорт моделей "
#~ "выглядел немного необычно.)"

# 3cf18a59ead34c549fc971e29c91ee8a
#~ msgid ""
#~ "The answer lies in the :setting:`INSTALLED_APPS` setting. The first time "
#~ "any model is loaded, Django iterates over every model in :setting:"
#~ "`INSTALLED_APPS` and creates the backward relationships in memory as "
#~ "needed. Essentially, one of the functions of :setting:`INSTALLED_APPS` is "
#~ "to tell Django the entire model domain."
#~ msgstr ""
#~ "Суть ответа в настройке :setting:`INSTALLED_APPS`. При загрузке любой "
#~ "модели в первый раз, Django перебирает все модели из приложений в :"
#~ "setting:`INSTALLED_APPS` и создает обратные связи для каждой модели.По "
#~ "сути, это одна из функций :setting:`INSTALLED_APPS` -- определить все "
#~ "используемые модели для Django."

# 9961ef20f97a4df5b272a1165f4f62b2
#~ msgid ""
#~ "You cannot access a reverse :class:`~django.db.models.ForeignKey` :class:"
#~ "`~django.db.models.Manager` from the class; it must be accessed from an "
#~ "instance::"
#~ msgstr ""
#~ "Вы не можете обращаться к \"обратному\" менеджеру через класс модели; вы "
#~ "должны использовать экземпляр модели::"
