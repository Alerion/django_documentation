# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-16 11:56+0200\n"
"PO-Revision-Date: 2017-04-05 19:16+0300\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.7\n"

# bf092ab9c1464273ada66a67dddf8c9e
#: ../../howto/custom-template-tags.txt:3
msgid "Custom template tags and filters"
msgstr "Собственные шаблонные теги и фильтры"

# 57805d2a525049bc93be7785368876fb
#: ../../howto/custom-template-tags.txt:5
msgid ""
"Django's template language comes with a wide variety of :doc:`built-in tags "
"and filters </ref/templates/builtins>` designed to address the presentation "
"logic needs of your application. Nevertheless, you may find yourself needing "
"functionality that is not covered by the core set of template primitives. "
"You can extend the template engine by defining custom tags and filters using "
"Python, and then make them available to your templates using the :ttag:`{% "
"load %}<load>` tag."
msgstr ""
"Шаблонизатор Django содержит большое количество :doc:`встроенных тегов и "
"фильтров </ref/templates/builtins>`. Тем не менее, вам может понадобиться "
"добавить собственный функционал к шаблонам. Вы можете сделать это добавив "
"собственную библиотеку тегов и фильтров используя Python, затем добавить ее "
"в шаблон с помощью тега :ttag:`{% load %}<load>`."

# 6d184360205b4067b657525310d025c2
#: ../../howto/custom-template-tags.txt:14
msgid "Code layout"
msgstr "Добавление собственной библиотеки"

#: ../../howto/custom-template-tags.txt:16
msgid ""
"The most common place to specify custom template tags and filters is inside "
"a Django app. If they relate to an existing app, it makes sense to bundle "
"them there; otherwise, they can be added to a new app. When a Django app is "
"added to :setting:`INSTALLED_APPS`, any tags it defines in the conventional "
"location described below are automatically made available to load within "
"templates."
msgstr ""
"Обычно шаблонные теги и фильтры располагаются в приложении Django. Если они "
"связаны с существующим приложением, это логично расположить его там. Иначе "
"можно добавить их в новое приложение. Если приложение Django добавлено :"
"setting:`INSTALLED_APPS`, все библиотеки тегов, расположенные в определенном "
"модуле приложения, будут доступны для загрузки в шаблонах."

# 4b941576efb446cb9304d544874aca63
#: ../../howto/custom-template-tags.txt:22
msgid ""
"The app should contain a ``templatetags`` directory, at the same level as "
"``models.py``, ``views.py``, etc. If this doesn't already exist, create it - "
"don't forget the ``__init__.py`` file to ensure the directory is treated as "
"a Python package."
msgstr ""
"Приложение должно содержать каталог ``templatetags`` на том же уровне что и "
"``models.py``, ``views.py`` и др. Если он не существует, создайте его. Не "
"забудьте создать файл ``__init__.py`` чтобы каталог мог использоваться как "
"пакет Python."

#: ../../howto/custom-template-tags.txt:27
msgid "Development server won't automatically restart"
msgstr "Сервер для разработки не перезапускается автоматически"

#: ../../howto/custom-template-tags.txt:29
msgid ""
"After adding the ``templatetags``  module, you will need to restart your "
"server before you can use the tags or filters in templates."
msgstr ""
"После добавления модуля ``templatetags`` вам необходимо перезапустить "
"сервер, чтобы использовать теги и фильтры в шаблонах."

# f7b1921d75f24e5cbd1aec472cadb266
#: ../../howto/custom-template-tags.txt:32
msgid ""
"Your custom tags and filters will live in a module inside the "
"``templatetags`` directory. The name of the module file is the name you'll "
"use to load the tags later, so be careful to pick a name that won't clash "
"with custom tags and filters in another app."
msgstr ""
"Выше теги и фильтры будут находиться в модуле пакета ``templatetags``. "
"Название модуля будет использоваться при загрузке библиотеки в шаблоне, так "
"что убедитесь что оно не совпадает с названиями библиотек других приложений."

# 9fa9a12cdf1b4547a50906f5bbb90a2f
#: ../../howto/custom-template-tags.txt:37
msgid ""
"For example, if your custom tags/filters are in a file called ``poll_extras."
"py``, your app layout might look like this::"
msgstr ""
"Например, если теги/фильтры находятся в файле ``poll_extras.py``, ваше "
"приложение может выглядеть следующим образом::"

# 589c12bd91d4456387dad76eb447ee84
#: ../../howto/custom-template-tags.txt:48
msgid "And in your template you would use the following:"
msgstr "И в шаблоне вы будете использовать:"

# 09091289f35f486a9bfa3167b401e115
#: ../../howto/custom-template-tags.txt:54
msgid ""
"The app that contains the custom tags must be in :setting:`INSTALLED_APPS` "
"in order for the :ttag:`{% load %}<load>` tag to work. This is a security "
"feature: It allows you to host Python code for many template libraries on a "
"single host machine without enabling access to all of them for every Django "
"installation."
msgstr ""
"Приложение содержащее собственные теги и фильтры должно быть добавлено в :"
"setting:`INSTALLED_APPS`, чтобы тег :ttag:`{% load %}<load>` мог загрузить "
"его. Это сделано в целях безопасности."

# ddd2e843d0c947fabd3577306d9e4f8f
#: ../../howto/custom-template-tags.txt:59
msgid ""
"There's no limit on how many modules you put in the ``templatetags`` "
"package. Just keep in mind that a :ttag:`{% load %}<load>` statement will "
"load tags/filters for the given Python module name, not the name of the app."
msgstr ""
"Не имеет значение сколько модулей добавлено в пакет ``templatetags``. "
"Помните что тег :ttag:`{% load %}<load>` использует название модуля, а не "
"название приложения."

# 9eabe059f6d642b1bb4f7e14bd6552c1
#: ../../howto/custom-template-tags.txt:63
msgid ""
"To be a valid tag library, the module must contain a module-level variable "
"named ``register`` that is a ``template.Library`` instance, in which all the "
"tags and filters are registered. So, near the top of your module, put the "
"following::"
msgstr ""
"Библиотека тегов должна содержать переменную ``register`` равную экземпляру "
"``template.Library``, в которой регистрируются все определенные теги и "
"фильтры. Так что в начале вашего модуля укажите следующие строки::"

#: ../../howto/custom-template-tags.txt:72
msgid ""
"Alternatively, template tag modules can be registered through the "
"``'libraries'`` argument to :class:`~django.template.backends.django."
"DjangoTemplates`. This is useful if you want to use a different label from "
"the template tag module name when loading template tags. It also enables you "
"to register tags without installing an application."
msgstr ""
"Модуль с шаблонными тегами можно также зарегистрировать через аргумент "
"``'libraries'`` класса :class:`~django.template.backends.django."
"DjangoTemplates`. Это полезно, если вы хотите изменить название библиотеки "
"тегов. Также вы можете зарегистрировать библиотеку без установки приложения."

# c0021276e66940889b47fb8fa3ca046b
#: ../../howto/custom-template-tags.txt:79
msgid "Behind the scenes"
msgstr "За кулисами"

# f628c78c49a84033a7e4d36d9b88420d
#: ../../howto/custom-template-tags.txt:81
msgid ""
"For a ton of examples, read the source code for Django's default filters and "
"tags. They're in ``django/template/defaultfilters.py`` and ``django/template/"
"defaulttags.py``, respectively."
msgstr ""
"Вы можете найти большое количество примеров в исходном коде встроенных тегов "
"и фильтров Django. Они находятся в файлах ``django/template/defaultfilters."
"py`` и ``django/template/defaulttags.py``."

# 67c2dfa2ad28430488469578143c4420
#: ../../howto/custom-template-tags.txt:85
msgid "For more information on the :ttag:`load` tag, read its documentation."
msgstr "Подробности о теге :ttag:`load` читайте в этой документации."

# f2d008daf93941118d689a96e8cf2148
#: ../../howto/custom-template-tags.txt:90
msgid "Writing custom template filters"
msgstr "Создание собственного шаблонного фильтра"

# 261cc73e2163475599a6c301261ac291
#: ../../howto/custom-template-tags.txt:92
msgid ""
"Custom filters are just Python functions that take one or two arguments:"
msgstr ""
"Фильтры это просто функции Python, которые принимают один или несколько "
"аргументов:"

# 8ce1c3217c2d4132abb2cc29b488daa8
#: ../../howto/custom-template-tags.txt:94
msgid "The value of the variable (input) -- not necessarily a string."
msgstr "Входящее значение -- не обязательно строка."

# 82158502cd174ba0a94ff1f152dc8612
#: ../../howto/custom-template-tags.txt:95
msgid ""
"The value of the argument -- this can have a default value, or be left out "
"altogether."
msgstr ""
"Значение аргументов -- можно указать значение по умолчанию или вообще не "
"использовать аргументы."

# b9cd9e8e897b436c903f950445c13fd7
#: ../../howto/custom-template-tags.txt:98
msgid ""
"For example, in the filter ``{{ var|foo:\"bar\" }}``, the filter ``foo`` "
"would be passed the variable ``var`` and the argument ``\"bar\"``."
msgstr ""
"Например, при ``{{ var|foo:\"bar\" }}`` функция фильтра ``foo`` будет "
"выполнена со значением переменной ``var`` и аргументом ``\"bar\"``."

# 7a5927f30b4c4b1589268cb64d4d563f
#: ../../howto/custom-template-tags.txt:101
msgid ""
"Since the template language doesn't provide exception handling, any "
"exception raised from a template filter will be exposed as a server error. "
"Thus, filter functions should avoid raising exceptions if there is a "
"reasonable fallback value to return. In case of input that represents a "
"clear bug in a template, raising an exception may still be better than "
"silent failure which hides the bug."
msgstr ""
"Исключение, вызванное в шаблонном фильтре, приведет к серверной ошибке. По "
"этому фильтр должен избегать исключений, если можно вернуть какое-то "
"значение по умолчанию. Если же переданное значение явно ведет к багу, лучше "
"вызвать исключение, чем скрыть баг."

# bb10835e8415456981cd928dcf38b28b
#: ../../howto/custom-template-tags.txt:108
msgid "Here's an example filter definition::"
msgstr "Пример фильтра::"

# 67dd05820d36433fb99da74e11bfdaa6
#: ../../howto/custom-template-tags.txt:114
msgid "And here's an example of how that filter would be used:"
msgstr "И пример как его использовать:"

# 0afbfe0b81494412a2c1d84904da9039
#: ../../howto/custom-template-tags.txt:120
msgid ""
"Most filters don't take arguments. In this case, just leave the argument out "
"of your function. Example::"
msgstr "Большинство фильтров не принимают аргументы. Например::"

# b256539c12ba43feb482efcb52af16e5
#: ../../howto/custom-template-tags.txt:128
msgid "Registering custom filters"
msgstr "Регистрация фильтров"

# a9b056a648224fd29ab034ce7d5066f7
#: ../../howto/custom-template-tags.txt:132
msgid ""
"Once you've written your filter definition, you need to register it with "
"your ``Library`` instance, to make it available to Django's template "
"language::"
msgstr ""
"Создав функцию фильтра, ее необходимо зарегистрировать в экземпляре "
"``Library``, чтобы использовать в шаблонах Django::"

# 95482b0137dc4b4280b7c97ddc77946d
#: ../../howto/custom-template-tags.txt:138
msgid "The ``Library.filter()`` method takes two arguments:"
msgstr "Метод ``Library.filter()`` принимает два аргумента:"

# adbf65624be24133b3cf275d5728f120
#: ../../howto/custom-template-tags.txt:140
msgid "The name of the filter -- a string."
msgstr "Название фильтра -- строка."

# 94698c365d4a4dcc8ba0b9cff1c142cb
# 20d12548aa7f48878299423c04f7722a
#: ../../howto/custom-template-tags.txt:141
#: ../../howto/custom-template-tags.txt:904
msgid ""
"The compilation function -- a Python function (not the name of the function "
"as a string)."
msgstr "Функция компиляции -- функция Python (не название функции строкой)."

# 41a00276886b46ad83e9995f9d49e8fe
#: ../../howto/custom-template-tags.txt:144
msgid "You can use ``register.filter()`` as a decorator instead::"
msgstr "Вы можете использовать ``register.filter()`` как декоратор::"

# 49fbe16b2f0b4f608079edc03a46039c
#: ../../howto/custom-template-tags.txt:154
msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the filter name."
msgstr ""
"Если вы не укажете аргумент ``name``, как показано во втором примере, Django "
"будет использовать название функции в качестве названия фильтра."

# 4a6f38f922a64819969e0c2c888cac15
#: ../../howto/custom-template-tags.txt:157
msgid ""
"Finally, ``register.filter()`` also accepts three keyword arguments, "
"``is_safe``, ``needs_autoescape``, and ``expects_localtime``. These "
"arguments are described in :ref:`filters and auto-escaping <filters-auto-"
"escaping>` and :ref:`filters and time zones <filters-timezones>` below."
msgstr ""
"Также ``register.filter()`` принимает три именованных аргумента: "
"``is_safe``, ``needs_autoescape`` и ``expects_localtime``. Эти аргументы "
"описан в разделе :ref:`фильтры и автоматическое экранирование <filters-auto-"
"escaping>` и в разделе :ref:`фильтры и часовые пояса <filters-timezones>` "
"далее."

# d894e696402041f8b229b92a1f321372
#: ../../howto/custom-template-tags.txt:163
msgid "Template filters that expect strings"
msgstr "Шаблонные фильтры, которые обрабатывают строки"

# a59eac4494fc4250a67cacd820c982cc
#: ../../howto/custom-template-tags.txt:167
msgid ""
"If you're writing a template filter that only expects a string as the first "
"argument, you should use the decorator ``stringfilter``. This will convert "
"an object to its string value before being passed to your function::"
msgstr ""
"Если вы создали фильтр, который работает только со строками, используйте "
"декоратор ``stringfilter``. Он преобразует объект в строковое значение перед "
"передачей в функцию::"

# d737caffadd141f2a9f4fb6b345f4218
#: ../../howto/custom-template-tags.txt:181
msgid ""
"This way, you'll be able to pass, say, an integer to this filter, and it "
"won't cause an ``AttributeError`` (because integers don't have ``lower()`` "
"methods)."
msgstr ""
"В этом случае вы можете передать число в фильтр и это не вызовет исключение "
"``AttributeError`` (так как число не содержит метод ``lower()``)."

# 1ef69d78a5ff4a5e9d283333ce6b32b9
#: ../../howto/custom-template-tags.txt:188
msgid "Filters and auto-escaping"
msgstr "Фильтры и автоматическое экранирование"

# c00ac3b691994b22b4ebccc9a3ad84e1
#: ../../howto/custom-template-tags.txt:190
#, fuzzy
msgid ""
"When writing a custom filter, give some thought to how the filter will "
"interact with Django's auto-escaping behavior. Note that two types of "
"strings can be passed around inside the template code:"
msgstr ""
"Создавая собственный фильтр, учитывайте как он будет работать с политикой "
"автоматического экранирования в Django. Есть три типа строк, которые могу "
"передаваться в коде шаблона."

# 04873eb679e84de8ba7e20858a89c1ea
#: ../../howto/custom-template-tags.txt:194
#, fuzzy
msgid ""
"**Raw strings** are the native Python strings. On output, they're escaped if "
"auto-escaping is in effect and presented unchanged, otherwise."
msgstr ""
"**\"Сырые\" строки** -- это обычные типы Python ``str`` или ``unicode``. При "
"выводе они экранируются при включенном авто-экранировании, иначе -- "
"выводятся как есть."

# a4465a3e668e44a19f26f588c1431628
#: ../../howto/custom-template-tags.txt:197
msgid ""
"**Safe strings** are strings that have been marked safe from further "
"escaping at output time. Any necessary escaping has already been done. "
"They're commonly used for output that contains raw HTML that is intended to "
"be interpreted as-is on the client side."
msgstr ""
"**Безопасные строки** -- строки, которые были помечены как безопасные. "
"Указывают на то, что последующее экранирование не требуется. Они обычно "
"используются для строк, которые содержат готовый HTML, которые необходимо "
"отобразить на странице."

# ce5968ed4116452591a5f5fd559230e8
#: ../../howto/custom-template-tags.txt:202
#, fuzzy
msgid ""
"Internally, these strings are of type :class:`~django.utils.safestring."
"SafeText`. You can test for them using code like::"
msgstr ""
"Внутри эти строки представлены типами ``SafeBytes`` или ``SafeText``. Эти "
"типа наследуются от базового класса ``SafeData``, таким образом вы можете "
"проверять их следующим образом::"

# 2baba831c7234bd08d61eccd9445cd50
#: ../../howto/custom-template-tags.txt:212
msgid "Template filter code falls into one of two situations:"
msgstr "При создании фильтра вы можете столкнуться со следующими ситуациями:"

# 93cd4ba53b7447d9a73e04f40bedeebc
#: ../../howto/custom-template-tags.txt:214
msgid ""
"Your filter does not introduce any HTML-unsafe characters (``<``, ``>``, "
"``'``, ``\"`` or ``&``) into the result that were not already present. In "
"this case, you can let Django take care of all the auto-escaping handling "
"for you. All you need to do is set the ``is_safe`` flag to ``True`` when you "
"register your filter function, like so::"
msgstr ""
"Ваш фильтр не добавляет никаких не экранированных HTML-символов (``<``, "
"``>``, ``'``, ``\"`` or ``&``) в результат. В таком случае вы можете "
"полностью положиться на политику автоматического экранирования Django. Для "
"этого передайте параметр ``is_safe`` с значением ``True`` при регистрации "
"функции фильтра::"

# 4db79f6294254a9abdff0faf7e140d3e
#: ../../howto/custom-template-tags.txt:224
msgid ""
"This flag tells Django that if a \"safe\" string is passed into your filter, "
"the result will still be \"safe\" and if a non-safe string is passed in, "
"Django will automatically escape it, if necessary."
msgstr ""
"Этот параметр указывает Django что фильтр никак не изменяет \"безопасность\" "
"переданной строки. То есть, если передать в фильтр \"безопасную\" строку, "
"результат также будет \"безопасным\" для Django, если же передать "
"\"небезопасную\" строку, Django автоматически экранирует результат фильтра."

# 7f24aa2789b14113bd0bd2fa2990a645
#: ../../howto/custom-template-tags.txt:228
msgid ""
"You can think of this as meaning \"this filter is safe -- it doesn't "
"introduce any possibility of unsafe HTML.\""
msgstr ""
"Другими словами можно сказать \"этот фильтр безопасный -- он никаким образом "
"не добавляет небезопасный HTML в результат.\""

# 2905af6ed6e94828922b1e9f0eaeb628
#: ../../howto/custom-template-tags.txt:231
#, fuzzy
msgid ""
"The reason ``is_safe`` is necessary is because there are plenty of normal "
"string operations that will turn a ``SafeData`` object back into a normal "
"``str`` object and, rather than try to catch them all, which would be very "
"difficult, Django repairs the damage after the filter has completed."
msgstr ""
"Причина использования параметра ``is_safe`` состоит в том, что большинство "
"операций со строками превращает объект ``SafeData`` обратно в обычный объект "
"``str`` или ``unicode`` и чтобы не обрабатывать все эти ситуации "
"самостоятельно, что может быть не просто, Django самостоятельно следит за "
"изменениями."

# 17c50f6ada20475d9c9f1b2b7376586d
#: ../../howto/custom-template-tags.txt:236
msgid ""
"For example, suppose you have a filter that adds the string ``xx`` to the "
"end of any input. Since this introduces no dangerous HTML characters to the "
"result (aside from any that were already present), you should mark your "
"filter with ``is_safe``::"
msgstr ""
"Например, у вас есть фильтр, который добавляет ``xx`` к концу переданного "
"значения. Так как он не добавляет небезопасных HTML-символов в результат "
"(кроме тех, которые присутствуют в переданном значении), вы должные пометить "
"его с параметром ``is_safe``::"

# 452e4ed1d04943159508fc34a8d617b7
#: ../../howto/custom-template-tags.txt:245
msgid ""
"When this filter is used in a template where auto-escaping is enabled, "
"Django will escape the output whenever the input is not already marked as "
"\"safe\"."
msgstr ""
"Если фильтр используется в шаблоне с включенным автоматическим "
"экранированием, Django выполнит экранирование результата если входящие "
"данные не были отмечены как \"безопасные\"."

# c6c0b3b009f04591bd06d2ce5517f0ff
#: ../../howto/custom-template-tags.txt:249
msgid ""
"By default, ``is_safe`` is ``False``, and you can omit it from any filters "
"where it isn't required."
msgstr "По умолчанию ``is_safe`` равен ``False``."

# 1b88eb66a40d428682c4df0f8ccfd4ec
#: ../../howto/custom-template-tags.txt:252
msgid ""
"Be careful when deciding if your filter really does leave safe strings as "
"safe. If you're *removing* characters, you might inadvertently leave "
"unbalanced HTML tags or entities in the result. For example, removing a "
"``>`` from the input might turn ``<a>`` into ``<a``, which would need to be "
"escaped on output to avoid causing problems. Similarly, removing a semicolon "
"(``;``) can turn ``&amp;`` into ``&amp``, which is no longer a valid entity "
"and thus needs further escaping. Most cases won't be nearly this tricky, but "
"keep an eye out for any problems like that when reviewing your code."
msgstr ""
"Будьте внимательны определяя безопасен ваш фильтр или нет. Если вы "
"*удаляете* символы, вы можете случайно оставить открытые HTML теги или "
"сущности(entities) в результате. Например, при удалении ``>`` из входящих "
"данных ``<a>`` может превратиться в ``<a``, который должен быть экранирован. "
"Аналогично, удаление точки с запятой (``;``) может превратить ``&amp;`` в "
"``&amp``, что не является правильной HTML-сущностью и должно быть "
"экранировано. Большинство случаев будут не такими сложными, но вы должны "
"быть внимательными."

# 1da73419e1be4ccdbb3f0e174c50fcbf
#: ../../howto/custom-template-tags.txt:262
msgid ""
"Marking a filter ``is_safe`` will coerce the filter's return value to a "
"string.  If your filter should return a boolean or other non-string value, "
"marking it ``is_safe`` will probably have unintended consequences (such as "
"converting a boolean False to the string 'False')."
msgstr ""
"Параметр ``is_safe`` принуждает фильтр вернуть строку.  Если ваш фильтр "
"возвращает булево значение или не строку, использование ``is_safe`` может "
"привести к непредвиденным последствиям (например, конвертирование False в "
"строку 'False')."

# bd90097a1dfd45fc900803c7f981221a
#: ../../howto/custom-template-tags.txt:268
msgid ""
"Alternatively, your filter code can manually take care of any necessary "
"escaping. This is necessary when you're introducing new HTML markup into the "
"result. You want to mark the output as safe from further escaping so that "
"your HTML markup isn't escaped further, so you'll need to handle the input "
"yourself."
msgstr ""
"Фильтр самостоятельно заботится об экранировании результата. Это необходимо "
"если вы добавляете новый HTML в результат. В таком случае результат должен "
"быть помечен как безопасный чтобы избежать последующего экранирования."

# 045f185a696243a9b5fd2898bd7ee593
#: ../../howto/custom-template-tags.txt:274
msgid ""
"To mark the output as a safe string, use :func:`django.utils.safestring."
"mark_safe`."
msgstr ""
"Для этого используйте функцию :func:`django.utils.safestring.mark_safe`."

# d405f12cc26042ea8b52e27665282e86
#: ../../howto/custom-template-tags.txt:277
msgid ""
"Be careful, though. You need to do more than just mark the output as safe. "
"You need to ensure it really *is* safe, and what you do depends on whether "
"auto-escaping is in effect. The idea is to write filters that can operate in "
"templates where auto-escaping is either on or off in order to make things "
"easier for your template authors."
msgstr ""
"Но будьте осторожны. Необходимо не просто пометить результат как безопасный. "
"Вы должны убедиться что результат *действительно* безопасен независимо от "
"того, включено автоматическое экранирование или нет. Идея в том, чтобы "
"фильтр правильно работал как при включенном автоматическом экранировании, "
"так и выключенном."

# dc5af2a846734def9cda752bac84f138
#: ../../howto/custom-template-tags.txt:283
msgid ""
"In order for your filter to know the current auto-escaping state, set the "
"``needs_autoescape`` flag to ``True`` when you register your filter "
"function. (If you don't specify this flag, it defaults to ``False``). This "
"flag tells Django that your filter function wants to be passed an extra "
"keyword argument, called ``autoescape``, that is ``True`` if auto-escaping "
"is in effect and ``False`` otherwise. It is recommended to set the default "
"of the ``autoescape`` parameter to ``True``, so that if you call the "
"function from Python code it will have escaping enabled by default."
msgstr ""
"Для того, чтобы фильтр знал включено ли автоматическое экранирование, "
"передайте параметр ``needs_autoescape`` со значением ``True`` при "
"регистрации функций фильтра. (По умолчанию значение равно ``False``). Этот "
"параметр указывает Django что необходимо передать именованный аргумент "
"``autoescape`` при вызове функции фильтра, который равен ``True``, если "
"включено автоматическое экранирование, иначе ``False``. Рекомендуем по "
"умолчанию указать ``True`` в ``autoescape``, чтобы при вызове функции в "
"коде, экранирование было включено."

# 9824e9971a024eb2b6dc8e357f219e36
#: ../../howto/custom-template-tags.txt:292
msgid ""
"For example, let's write a filter that emphasizes the first character of a "
"string::"
msgstr ""
"Например, давайте создадим фильтр, который выделяет первый символ строки::"

# 35f02a19f156453c9be8d77fa0c59914
#: ../../howto/custom-template-tags.txt:311
msgid ""
"The ``needs_autoescape`` flag and the ``autoescape`` keyword argument mean "
"that our function will know whether automatic escaping is in effect when the "
"filter is called. We use ``autoescape`` to decide whether the input data "
"needs to be passed through ``django.utils.html.conditional_escape`` or not. "
"(In the latter case, we just use the identity function as the \"escape\" "
"function.) The ``conditional_escape()`` function is like ``escape()`` except "
"it only escapes input that is **not** a ``SafeData`` instance. If a "
"``SafeData`` instance is passed to ``conditional_escape()``, the data is "
"returned unchanged."
msgstr ""
"Параметр ``needs_autoescape`` и аргумент ``autoescape`` информируют фильтр о "
"том, было ли включено автоматическое экранирование при вызове фильтра. "
"Аргумент ``autoescape`` указывает необходимо ли использовать ``django.utils."
"html.conditional_escape`` для входящих данных. (В нашем примере мы "
"использовали его для определения функции \"escape\".) Функция "
"``conditional_escape()`` как и ``escape()``, но использует экранирование "
"только для **не** безопасных(``SafeData``) строк. Если передать объект "
"``SafeData`` функция ``conditional_escape()`` вернет его без изменений."

# 18b66f2fe3e34408abde7437fc68b89d
#: ../../howto/custom-template-tags.txt:321
msgid ""
"Finally, in the above example, we remember to mark the result as safe so "
"that our HTML is inserted directly into the template without further "
"escaping."
msgstr ""
"Также мы пометили результат как безопасный и он будет вставлен "
"непосредственно в шаблон без повторного экранирования."

# 0d9d120e71124beda9ed36c3ffb18486
#: ../../howto/custom-template-tags.txt:325
msgid ""
"There's no need to worry about the ``is_safe`` flag in this case (although "
"including it wouldn't hurt anything). Whenever you manually handle the auto-"
"escaping issues and return a safe string, the ``is_safe`` flag won't change "
"anything either way."
msgstr ""
"В этом случае нет необходимости беспокоиться о параметре ``is_safe``. Так "
"как вы самостоятельно учитываете автоматическое экранирование, параметр "
"``is_safe`` ничего не изменит."

# 95661f02584c48689dc234053f8cff45
#: ../../howto/custom-template-tags.txt:330
msgid "Avoiding XSS vulnerabilities when reusing built-in filters"
msgstr "Защита от XSS уязвимостей при использовании встроенных фильтров."

# 828fd787f2ce4ba79c78a3f602432510
#: ../../howto/custom-template-tags.txt:332
msgid ""
"Django's built-in filters have ``autoescape=True`` by default in order to "
"get the proper autoescaping behavior and avoid a cross-site script "
"vulnerability."
msgstr ""
"Фильтры Django используют ``autoescape=True``, чтобы избежать XSS "
"уязвимостей."

#: ../../howto/custom-template-tags.txt:336
msgid ""
"In older versions of Django, be careful when reusing Django's built-in "
"filters as ``autoescape`` defaults to ``None``. You'll need to pass "
"``autoescape=True`` to get autoescaping."
msgstr ""
"В предыдущих версиях Django ``autoescape`` равен ``None`` по умолчанию, "
"будьте осторожны при использовании фильтров в коде. Вам необходимо передать "
"``autoescape=True``, чтобы активировать экранирование."

# 7151b1fed6ec4cee81302f451137a3c9
#: ../../howto/custom-template-tags.txt:340
msgid ""
"For example, if you wanted to write a custom filter called "
"``urlize_and_linebreaks`` that combined the :tfilter:`urlize` and :tfilter:"
"`linebreaksbr` filters, the filter would look like::"
msgstr ""
"Например, если вы хотите написать фильтр ``urlize_and_linebreaks``, который "
"использует фильтры :tfilter:`urlize` и :tfilter:`linebreaksbr`, он будет "
"выглядеть следующим образом::"

# ac5b567df2a945f8907b381c81bb7ef6
#: ../../howto/custom-template-tags.txt:353
msgid "Then:"
msgstr "Тогда:"

# abd642cfcef042969fb459ce996f3eb4
#: ../../howto/custom-template-tags.txt:359
msgid "would be equivalent to:"
msgstr "можно использовать вместо:"

# f36f5a5e28fd4459870e647dc3a96401
#: ../../howto/custom-template-tags.txt:368
msgid "Filters and time zones"
msgstr "Фильтры и временные зоны"

# 29193eefb4f348238142b7cfb5d5a0d7
#: ../../howto/custom-template-tags.txt:370
msgid ""
"If you write a custom filter that operates on :class:`~datetime.datetime` "
"objects, you'll usually register it with the ``expects_localtime`` flag set "
"to ``True``::"
msgstr ""
"Если вы создаете фильтр, который обрабатывает объекты :class:`~datetime."
"datetime`, скорее всего вы будете использовать параметр "
"``expects_localtime`` со значением ``True``::"

# a45bfcd869bc4bd6b7f05b98d98964f8
#: ../../howto/custom-template-tags.txt:381
msgid ""
"When this flag is set, if the first argument to your filter is a time zone "
"aware datetime, Django will convert it to the current time zone before "
"passing it to your filter when appropriate, according to :ref:`rules for "
"time zones conversions in templates <time-zones-in-templates>`."
msgstr ""
"Если этот флаг установлен и первый аргумент вашего фильтра является "
"значением времени с часовым поясом, Django преобразует это значение в "
"текущий часовой пояс перед тем как передать в фильтр, в соответствии с :ref:"
"`правилами преобразования часовых поясов в шаблонах <time-zones-in-"
"templates>`."

# ed13ea738ccc4a51ab48a43bf33c5c25
#: ../../howto/custom-template-tags.txt:389
msgid "Writing custom template tags"
msgstr "Создание собственного шаблонного тега"

#: ../../howto/custom-template-tags.txt:391
msgid ""
"Tags are more complex than filters, because tags can do anything. Django "
"provides a number of shortcuts that make writing most types of tags easier. "
"First we'll explore those shortcuts, then explain how to write a tag from "
"scratch for those cases when the shortcuts aren't powerful enough."
msgstr ""
"Теги сложнее чем фильтры, они позволяют делать что угодно. Django "
"предоставляет инструменты, которые упрощают создания различных тегов. Первым "
"делом мы изучим их, затем узнаем как создать тег с нуля."

# c71d3fbbe17c4aefaf1de73acbe39160
#: ../../howto/custom-template-tags.txt:399
msgid "Simple tags"
msgstr "Простые теги"

# 8c35e7287a6d4d12950c659f823a34d9
#: ../../howto/custom-template-tags.txt:403
msgid ""
"Many template tags take a number of arguments -- strings or template "
"variables -- and return a result after doing some processing based solely on "
"the input arguments and some external information. For example, a "
"``current_time`` tag might accept a format string and return the time as a "
"string formatted accordingly."
msgstr ""
"Большинство тегов принимают определенное количество аргументов -- строки или "
"переменные шаблона -- и возвращают строку после обработки аргументов. "
"Например, тег ``current_time`` принимает строку с форматом и возвращает "
"время строкой в этом формате."

# 9d5621098df8427fa87cd60f68f80b85
#: ../../howto/custom-template-tags.txt:409
msgid ""
"To ease the creation of these types of tags, Django provides a helper "
"function, ``simple_tag``. This function, which is a method of ``django."
"template.Library``, takes a function that accepts any number of arguments, "
"wraps it in a ``render`` function and the other necessary bits mentioned "
"above and registers it with the template system."
msgstr ""
"Для создания подобных тегов, Django предоставляет функцию ``simple_tag``. "
"Эта функция, которая является методом ``django.template.Library``, принимает "
"функцию принимающую любое количество аргументов, оборачивает функцией "
"``render`` и регистрирует в системе шаблонов."

# 6b3e303ef65b4eb4ad21e9536c98f37b
# 5e75b0df73e74e3fa49141eb69c8e5ea
#: ../../howto/custom-template-tags.txt:415
msgid "Our ``current_time`` function could thus be written like this::"
msgstr "Функцию ``current_time`` можно переписать следующим образом::"

# c6de500bd826498ebd666df11cc966a3
#: ../../howto/custom-template-tags.txt:426
msgid "A few things to note about the ``simple_tag`` helper function:"
msgstr "Несколько вещей которые следует помнить о функции ``simple_tag``:"

# f795315efa1e400db96b4ccf63ba2b85
#: ../../howto/custom-template-tags.txt:428
msgid ""
"Checking for the required number of arguments, etc., has already been done "
"by the time our function is called, so we don't need to do that."
msgstr ""
"Проверка количества обязательных аргументов и др. выполняется до вызова "
"функции, вам не нужно этого делать."

# 8fd1abf6d182464d876142976ae65916
#: ../../howto/custom-template-tags.txt:430
msgid ""
"The quotes around the argument (if any) have already been stripped away, so "
"we just receive a plain string."
msgstr ""
"Кавычки вокруг строк уже удалены, аргумент будет содержать готовую строку."

# 876366724cb546fda452edf059c39ba4
#: ../../howto/custom-template-tags.txt:432
msgid ""
"If the argument was a template variable, our function is passed the current "
"value of the variable, not the variable itself."
msgstr ""
"Если аргумент является переменной шаблона, наша функция получит ее значение."

#: ../../howto/custom-template-tags.txt:435
msgid ""
"Unlike other tag utilities, ``simple_tag`` passes its output through :func:"
"`~django.utils.html.conditional_escape` if the template context is in "
"autoescape mode, to ensure correct HTML and protect you from XSS "
"vulnerabilities."
msgstr ""
"В отличии от других утилит тегов, ``simple_tag`` обрабатывает результат "
"функцией :func:`~django.utils.html.conditional_escape`, если контекст "
"шаблона в режиме автоматического экранирования, чтобы убедиться в "
"правильности HTML и защитить вас от XSS атак."

#: ../../howto/custom-template-tags.txt:440
msgid ""
"If additional escaping is not desired, you will need to use :func:`~django."
"utils.safestring.mark_safe` if you are absolutely sure that your code does "
"not contain XSS vulnerabilities. For building small HTML snippets, use of :"
"func:`~django.utils.html.format_html` instead of ``mark_safe()`` is strongly "
"recommended."
msgstr ""
"Если экранирование не нужно, вы можете использовать функцию :func:`~django."
"utils.safestring.mark_safe`, если вы абсолютно уверены, что ваш код не "
"содержит XSS уязвимостей. Для создание небольших кусков HTML настоятельно "
"рекомендуется использовать :func:`~django.utils.html.format_html` вместо "
"``mark_safe()``."

# 491b913f40d44336a2c90cc5a2455ef1
# 14007f9accef408cb432b1e3f28e47fc
#: ../../howto/custom-template-tags.txt:446
msgid ""
"If your template tag needs to access the current context, you can use the "
"``takes_context`` argument when registering your tag::"
msgstr ""
"Если тегу необходим текущий контекст, используйте параметр ``takes_context`` "
"при регистрации тега::"

# 55dda13766674bb2805c87533cb77ace
#: ../../howto/custom-template-tags.txt:454
msgid "Note that the first argument *must* be called ``context``."
msgstr "Заметим, что первый параметр *должен* называться ``context``."

# 62cede74965d4780a4d64de8c23527b7
# efee9a4cdca341cf9078447e86225e81
#: ../../howto/custom-template-tags.txt:456
msgid ""
"For more information on how the ``takes_context`` option works, see the "
"section on :ref:`inclusion tags<howto-custom-template-tags-inclusion-tags>`."
msgstr ""
"Подробности о параметре ``takes_context`` смотрите в разделе о :ref:"
"`включающих тегах<howto-custom-template-tags-inclusion-tags>`."

# 4692c882548143b3b6f0ddfd06d4e28f
#: ../../howto/custom-template-tags.txt:459
msgid "If you need to rename your tag, you can provide a custom name for it::"
msgstr "Если вам нужно изменить название тега, передайте его параметром::"

# f037c0b12f574d6483006557156f0114
#: ../../howto/custom-template-tags.txt:467
msgid ""
"``simple_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr ""
"Теги, зарегистрированные через ``simple_tag`` могут принимать любое "
"количество позиционных или именованных аргументов. Например::"

# 8b37e2fdf88147b08b4627b32cb8a575
# 3ebf874084b34138b91a6c0b8043c77c
# 3d92934bca0548a9882d0a956d872368
#: ../../howto/custom-template-tags.txt:477
#: ../../howto/custom-template-tags.txt:623
msgid ""
"Then in the template any number of arguments, separated by spaces, may be "
"passed to the template tag. Like in Python, the values for keyword arguments "
"are set using the equal sign (\"``=``\") and must be provided after the "
"positional arguments. For example:"
msgstr ""
"Теперь в тег можно передать любое количество позиционных аргументов, "
"разделенных пробелами. Как и в Python, значения для именованных аргументов "
"можно указать, используя знак \"``=``\" после именованных аргументов. "
"Например:"

# 8c4118eb745246b3be25c9ea9a3c5b2d
#: ../../howto/custom-template-tags.txt:486
msgid ""
"It's possible to store the tag results in a template variable rather than "
"directly outputting it. This is done by using the ``as`` argument followed "
"by the variable name. Doing so enables you to output the content yourself "
"where you see fit:"
msgstr ""
"Вы можете добавить результат в переменную шаблона, используя аргумент ``as`` "
"и название переменной, и использовать его при необходимости:"

# 856106180f614029ab1c95c3540357c6
#: ../../howto/custom-template-tags.txt:499
msgid "Inclusion tags"
msgstr "Включающие теги"

# f70ef51ecaa8497ca38817c99f1063af
#: ../../howto/custom-template-tags.txt:503
msgid ""
"Another common type of template tag is the type that displays some data by "
"rendering *another* template. For example, Django's admin interface uses "
"custom template tags to display the buttons along the bottom of the \"add/"
"change\" form pages. Those buttons always look the same, but the link "
"targets change depending on the object being edited -- so they're a perfect "
"case for using a small template that is filled with details from the current "
"object. (In the admin's case, this is the ``submit_row`` tag.)"
msgstr ""
"Еще один тип тегов -- это теги, которые выполняют *другой* шаблон и "
"показывают результат. Например, интерфейс администратора Django использует "
"включающий тег для отображения кнопок под формой на страницах добавления/"
"редактирования объектов. Эти кнопки выглядят всегда одинаково, но ссылки "
"зависят от текущего объекта -- небольшой шаблон, который выполняется с "
"данными из текущего объекта, удобно использовать в данном случае. (В "
"приложении администратора это тег ``submit_row``.)"

# 86913ed25a944878947b3620ed511930
#: ../../howto/custom-template-tags.txt:511
msgid "These sorts of tags are called \"inclusion tags\"."
msgstr "Такие теги называются \"включающие теги\"."

# 2bc5d0cd19c94b578763b32daf43e26c
#: ../../howto/custom-template-tags.txt:513
msgid ""
"Writing inclusion tags is probably best demonstrated by example. Let's write "
"a tag that outputs a list of choices for a given ``Poll`` object, such as "
"was created in the :ref:`tutorials <creating-models>`. We'll use the tag "
"like this:"
msgstr ""
"Лучше пояснить на примере. Давайте создадим тег, который выводит список "
"вариантов ответов для объекта модели ``Poll``, которая использовалась в :ref:"
"`учебнике <creating-models>`. Мы будем использовать его следующим образом:"

# ba998a55e44145228c977840f06672f3
#: ../../howto/custom-template-tags.txt:521
msgid "...and the output will be something like this:"
msgstr "...результат будет выглядеть приблизительно следующим образом:"

# 140aafc29037447f9c9650ae549d7b84
#: ../../howto/custom-template-tags.txt:531
msgid ""
"First, define the function that takes the argument and produces a dictionary "
"of data for the result. The important point here is we only need to return a "
"dictionary, not anything more complex. This will be used as a template "
"context for the template fragment. Example::"
msgstr ""
"Первым делом, создадим функцию, которая принимает аргумент и возвращает "
"словарь с данными. Заметим, что все что нам нужно, это вернуть словарь и "
"ничего более сложного. Он будет использоваться как контекст для включаемого "
"фрагмента шаблона. Например::"

# 2918d76556744f9d8ff9d39bac249643
#: ../../howto/custom-template-tags.txt:540
msgid ""
"Next, create the template used to render the tag's output. This template is "
"a fixed feature of the tag: the tag writer specifies it, not the template "
"designer. Following our example, the template is very simple:"
msgstr ""
"Теперь создадим шаблон, который будет использоваться для генерации "
"результата. Этот шаблон полностью относится к тегу: создатель тега "
"определяет его, не создатель шаблонов(template designer). Для нашего примера "
"шаблон будет очень простым:"

# 0b744f766ff4456280b209877a7d61ec
#: ../../howto/custom-template-tags.txt:552
msgid ""
"Now, create and register the inclusion tag by calling the "
"``inclusion_tag()`` method on a ``Library`` object. Following our example, "
"if the above template is in a file called ``results.html`` in a directory "
"that's searched by the template loader, we'd register the tag like this::"
msgstr ""
"Теперь создадим и зарегистрируем тег, используя метод ``inclusion_tag()`` "
"объекта ``Library``. Для нашего примера, если шаблон тега называется "
"``results.html``, мы зарегистрируем тег следующим образом::"

# 63ca6c54974e42bd97cb7f0ef5d32a1b
#: ../../howto/custom-template-tags.txt:562
msgid ""
"Alternatively it is possible to register the inclusion tag using a :class:"
"`django.template.Template` instance::"
msgstr ""
"Также можно зарегистрировать включающий тег используя экземпляр :class:"
"`django.template.Template`::"

# 80515636eeaf4065a44b946dc2866c68
#: ../../howto/custom-template-tags.txt:569
msgid "...when first creating the function."
msgstr "...при создании функции."

# 39537f4e14fa4e59bb01c93d6feb15f0
#: ../../howto/custom-template-tags.txt:571
msgid ""
"Sometimes, your inclusion tags might require a large number of arguments, "
"making it a pain for template authors to pass in all the arguments and "
"remember their order. To solve this, Django provides a ``takes_context`` "
"option for inclusion tags. If you specify ``takes_context`` in creating a "
"template tag, the tag will have no required arguments, and the underlying "
"Python function will have one argument -- the template context as of when "
"the tag was called."
msgstr ""
"В некоторых случаях тег может требовать большого количества параметров. "
"Может быть проблематично запомнить все параметры и их порядок. Чтобы решить "
"эту проблему Django предоставляет параметр ``takes_context`` для включающего "
"тега. Если указать ``takes_context`` при создании тега, тег не будет "
"содержать обязательные аргументы, а функция Python будет принимать один "
"аргумент -- контекст текущего шаблона."

# 07c7030096704f0c9e1404ddcb83acfa
#: ../../howto/custom-template-tags.txt:578
msgid ""
"For example, say you're writing an inclusion tag that will always be used in "
"a context that contains ``home_link`` and ``home_title`` variables that "
"point back to the main page. Here's what the Python function would look "
"like::"
msgstr ""
"Например, предположим вы создаете тег, который будет использоваться в "
"шаблонах с контекстом всегда содержащим переменные ``home_link`` и "
"``home_title``. Вот как может выглядеть такой тег::"

# 55dda13766674bb2805c87533cb77ace
#: ../../howto/custom-template-tags.txt:589
msgid ""
"Note that the first parameter to the function *must* be called ``context``."
msgstr "Заметим, что первый параметр *должен* называться ``context``."

# af3445b39dec47c196e431a48c8efddd
#: ../../howto/custom-template-tags.txt:591
msgid ""
"In that ``register.inclusion_tag()`` line, we specified "
"``takes_context=True`` and the name of the template. Here's what the "
"template ``link.html`` might look like:"
msgstr ""
"При вызове ``register.inclusion_tag()`` мы указали ``takes_context=True`` и "
"название включаемого шаблона. Вот как может выглядеть шаблон ``link.html``:"

# 48dd19b096f54177b90ae036290fdf2f
#: ../../howto/custom-template-tags.txt:599
msgid ""
"Then, any time you want to use that custom tag, load its library and call it "
"without any arguments, like so:"
msgstr ""
"Для использования тега необходимо загрузить библиотеку тегов и вызвать тег "
"без аргументов:"

# 70a6a81d504540098595d8a3237b589b
#: ../../howto/custom-template-tags.txt:606
msgid ""
"Note that when you're using ``takes_context=True``, there's no need to pass "
"arguments to the template tag. It automatically gets access to the context."
msgstr ""
"Заметим, что при использовании ``takes_context=True`` необязательно "
"передавать аргументы. Тег будет иметь доступ ко всему контексту шаблона."

# 7a2564baa6ee40119151961febd54476
#: ../../howto/custom-template-tags.txt:609
msgid ""
"The ``takes_context`` parameter defaults to ``False``. When it's set to "
"``True``, the tag is passed the context object, as in this example. That's "
"the only difference between this case and the previous ``inclusion_tag`` "
"example."
msgstr ""
"Параметр ``takes_context`` по умолчанию равен ``False``. Если он равен "
"``True``, в тег будет передан объект контекста."

# c809b792600e416ba9f23b34dbaaba4f
#: ../../howto/custom-template-tags.txt:613
msgid ""
"``inclusion_tag`` functions may accept any number of positional or keyword "
"arguments. For example::"
msgstr ""
"``inclusion_tag`` может принимать любое количество позиционных и именованных "
"аргументов. Например::"

# ed13ea738ccc4a51ab48a43bf33c5c25
#: ../../howto/custom-template-tags.txt:633
msgid "Advanced custom template tags"
msgstr "Создание собственного шаблонного тега"

#: ../../howto/custom-template-tags.txt:635
msgid ""
"Sometimes the basic features for custom template tag creation aren't enough. "
"Don't worry, Django gives you complete access to the internals required to "
"build a template tag from the ground up."
msgstr ""
"Иногда не достаточно базовых инструментов для создания тегов. Не волнуйтесь, "
"Django предоставляет полный доступ к внутренностям шаблонизатора, что "
"позволяет создать свой тег с нуля."

# b87a21637ded4b70acc2f21208f86249
#: ../../howto/custom-template-tags.txt:640
msgid "A quick overview"
msgstr "Краткий обзор"

# 58757bb008c34480ac92a1a141c9cbb4
#: ../../howto/custom-template-tags.txt:642
msgid ""
"The template system works in a two-step process: compiling and rendering. To "
"define a custom template tag, you specify how the compilation works and how "
"the rendering works."
msgstr ""
"Система шаблонов работает в два этапа: компиляция и выполнение. Создавая "
"собственный тег вы определяете как выполняется компиляция и выполнение тега."

# 1a486f0d89904bc89e6fca0d62e9663c
#: ../../howto/custom-template-tags.txt:646
msgid ""
"When Django compiles a template, it splits the raw template text into "
"''nodes''. Each node is an instance of ``django.template.Node`` and has a "
"``render()`` method. A compiled template is, simply, a list of ``Node`` "
"objects. When you call ``render()`` on a compiled template object, the "
"template calls ``render()`` on each ``Node`` in its node list, with the "
"given context. The results are all concatenated together to form the output "
"of the template."
msgstr ""
"Когда Django компилирует шаблон, содержимое шаблона разбивается на \"узлы"
"\" (nodes). Каждый узел это экземпляр ``django.template.Node`` с методом "
"``render()``. Откомпилированный шаблон это просто список объектов ``Node``. "
"Когда вы вызываете метод ``render()`` откомпилированного объекта шаблона, "
"шаблон просто вызывает ``render()`` для каждого объекта ``Node`` в списке "
"узлов с переданным контекстом. Результаты объединяются для получения "
"окончательного результата."

# e41c6a1ea0cb4ba9b49077a79d9c034e
#: ../../howto/custom-template-tags.txt:653
msgid ""
"Thus, to define a custom template tag, you specify how the raw template tag "
"is converted into a ``Node`` (the compilation function), and what the node's "
"``render()`` method does."
msgstr ""
"Таким образом, создавая собственный тег, вы указываете как \"сырой\" тег "
"шаблона конвертируется в объект ``Node`` (функцию компиляции) и что делает "
"метод ``render()``."

# f10badb64ec04b6180fd9674e3b75ca2
#: ../../howto/custom-template-tags.txt:658
msgid "Writing the compilation function"
msgstr "Создание функции компиляции"

# 2046b9243e2f4748a80b8cf7176a1afe
#: ../../howto/custom-template-tags.txt:660
msgid ""
"For each template tag the template parser encounters, it calls a Python "
"function with the tag contents and the parser object itself. This function "
"is responsible for returning a ``Node`` instance based on the contents of "
"the tag."
msgstr ""
"Для каждого тега, с которым сталкивается парсер шаблона, вызывается его "
"функция Python с содержимым тега и объектом парсера. Эта функция должна "
"вернуть экземпляр ``Node``."

# 1c890c3335aa4adab2728573128ac6ee
#: ../../howto/custom-template-tags.txt:664
msgid ""
"For example, let's write a full implementation of our simple template tag, "
"``{% current_time %}``, that displays the current date/time, formatted "
"according to a parameter given in the tag, in :func:`~time.strftime` syntax. "
"It's a good idea to decide the tag syntax before anything else. In our case, "
"let's say the tag should be used like this:"
msgstr ""
"Например, давайте создадим тег, ``{% current_time %}``, который отображает "
"текущую дату и время, отформатированные в соответствии с переданным "
"параметром с синтаксисом аналогичным :func:`~time.strftime`. Первым делом "
"следует определиться с синтаксисом тега. В нашем случае тег будет "
"использоваться следующим образом:"

# 504b0a0b72674fe18173711cafe94eb0
#: ../../howto/custom-template-tags.txt:674
msgid ""
"The parser for this function should grab the parameter and create a ``Node`` "
"object::"
msgstr "Парсер  функции должен получить параметр и вернуть объект ``Node``::"

# 237aade3aed940678a3e47fef339ee91
# fdcef6fb605c432d827d4ad1eb40eefb
#: ../../howto/custom-template-tags.txt:693
#: ../../howto/custom-template-tags.txt:745
msgid "Notes:"
msgstr "Заметки:"

# a2397f5ab88a4289b5c1d2ad5fdee1d9
#: ../../howto/custom-template-tags.txt:695
msgid ""
"``parser`` is the template parser object. We don't need it in this example."
msgstr "``parser`` -- парсер шаблона. Он нам не нужен в данном примере."

# af29359ec5f4402a9a6d09d0ec9d7013
#: ../../howto/custom-template-tags.txt:698
msgid ""
"``token.contents`` is a string of the raw contents of the tag. In our "
"example, it's ``'current_time \"%Y-%m-%d %I:%M %p\"'``."
msgstr ""
"``token.contents`` -- содержимое тега. В нашем примере это ``'current_time "
"\"%Y-%m-%d %I:%M %p\"'``."

# 9fee43ace8d5419d8eae5d75a013b530
#: ../../howto/custom-template-tags.txt:701
msgid ""
"The ``token.split_contents()`` method separates the arguments on spaces "
"while keeping quoted strings together. The more straightforward ``token."
"contents.split()`` wouldn't be as robust, as it would naively split on *all* "
"spaces, including those within quoted strings. It's a good idea to always "
"use ``token.split_contents()``."
msgstr ""
"Метод ``token.split_contents()`` разбивает аргументы разделенные пробелами "
"при это не разбивая строки выделенные кавычками. Более простой метод ``token."
"contents.split()`` может быть не таким полезным и надежным так как разбивает "
"по *всем* пробелам, включая пробелы в кавычках. Лучше всегда использовать "
"``token.split_contents()``."

# 264654e7079148028219b9c356bcd947
#: ../../howto/custom-template-tags.txt:707
msgid ""
"This function is responsible for raising ``django.template."
"TemplateSyntaxError``, with helpful messages, for any syntax error."
msgstr ""
"Эта функция может вызвать исключение ``django.template.TemplateSyntaxError`` "
"в случае синтаксической ошибки при использовании вашего тега."

# 65a76edea16b4c6a9504c399d822e4c6
#: ../../howto/custom-template-tags.txt:711
msgid ""
"The ``TemplateSyntaxError`` exceptions use the ``tag_name`` variable. Don't "
"hard-code the tag's name in your error messages, because that couples the "
"tag's name to your function. ``token.contents.split()[0]`` will ''always'' "
"be the name of your tag -- even when the tag has no arguments."
msgstr ""
"Исключение ``TemplateSyntaxError`` использует переменную ``tag_name``. Не "
"вписывайте название тега в сообщение ошибки, потому что это привязывает "
"название тега к функции. ``token.contents.split()[0]`` ''всегда'' содержит "
"название тега -- даже если тег не содержит аргументы."

# 14537338da3c478599f5eff000a3ac8b
#: ../../howto/custom-template-tags.txt:717
msgid ""
"The function returns a ``CurrentTimeNode`` with everything the node needs to "
"know about this tag. In this case, it just passes the argument -- ``\"%Y-%m-"
"%d %I:%M %p\"``. The leading and trailing quotes from the template tag are "
"removed in ``format_string[1:-1]``."
msgstr ""
"Функция возвращает экземпляр ``CurrentTimeNode`` передавая в конструктор "
"необходимую информацию с тега. В нашем примере передается ``\"%Y-%m-%d %I:%M "
"%p\"``. Кавычки удаляются с помощью ``format_string[1:-1]``."

# a6a6dc4e855b451cacadbcbff7e1bc36
#: ../../howto/custom-template-tags.txt:722
msgid ""
"The parsing is very low-level. The Django developers have experimented with "
"writing small frameworks on top of this parsing system, using techniques "
"such as EBNF grammars, but those experiments made the template engine too "
"slow. It's low-level because that's fastest."
msgstr ""
"Парсер -- очень низкоуровневый. Разработчики Django экспериментировали с "
"созданием различных микро-фреймверков поверх системы парсинга, используя "
"техники, такие как грамматика `EBNF <http://ru.wikipedia.org/wiki/"
"%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_"
"%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_"
"%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0>`_, но эти эксперименты делали "
"систему шаблонов медленной. Парсер низкоуровневый, так как это делает его "
"быстрым."

# 3954eb744a55453f8ea949912cdf41fc
#: ../../howto/custom-template-tags.txt:728
msgid "Writing the renderer"
msgstr "Реализация выполнения тега"

# 1fbbba9f2bf14c16919625a858afad8e
#: ../../howto/custom-template-tags.txt:730
msgid ""
"The second step in writing custom tags is to define a ``Node`` subclass that "
"has a ``render()`` method."
msgstr "Следующим этапом мы создаем подкласс ``Node`` с методом ``render()``."

# 2cb75ea299204fcd9f6d5d8ee72948df
#: ../../howto/custom-template-tags.txt:733
msgid "Continuing the above example, we need to define ``CurrentTimeNode``::"
msgstr "В продолжение нашего примера создадим класс ``CurrentTimeNode``::"

# 7a0a0d37a6524b7fa487ca85c7e0f048
#: ../../howto/custom-template-tags.txt:747
msgid ""
"``__init__()`` gets the ``format_string`` from ``do_current_time()``. Always "
"pass any options/parameters/arguments to a ``Node`` via its ``__init__()``."
msgstr ""
"``__init__()`` принимает аргумент ``format_string`` из "
"``do_current_time()``. Всегда передавайте параметры в ``Node`` через "
"``__init__()``."

# 941c7c7628a64736b53c94c861f65a9c
#: ../../howto/custom-template-tags.txt:751
msgid "The ``render()`` method is where the work actually happens."
msgstr "Метод ``render()`` выполняет основную работу."

# 5d46462f3b3c42b78ae09c8576969c23
#: ../../howto/custom-template-tags.txt:753
msgid ""
"``render()`` should generally fail silently, particularly in a production "
"environment. In some cases however, particularly if ``context.template."
"engine.debug`` is ``True``, this method may raise an exception to make "
"debugging easier. For example, several core tags raise ``django.template."
"TemplateSyntaxError`` if they receive the wrong number or type of arguments."
msgstr ""
"``render()`` не должен вызывать исключений, особенно на боевом сервере. "
"Однако, в некоторых случаях, особенно при :setting:`TEMPLATE_DEBUG` равном "
"``True``, метод может вызывать исключения для упрощения отладки. Например, "
"некоторые встроенные теги вызывают ``django.template.TemplateSyntaxError``, "
"если передать неверное количество или тип аргументов."

# 708ab95f7c0043069f672a1718ba9ef8
#: ../../howto/custom-template-tags.txt:760
msgid ""
"Ultimately, this decoupling of compilation and rendering results in an "
"efficient template system, because a template can render multiple contexts "
"without having to be parsed multiple times."
msgstr ""
"Разделение компиляции и выполнения эффективно так как позволяет выполнить "
"шаблон с несколькими контекстами без надобности выполнять парсинг каждый раз."

# 6b2aaaf7b3984c6c83c1c3fabbe6bab3
#: ../../howto/custom-template-tags.txt:767
msgid "Auto-escaping considerations"
msgstr "Работа с автоматическим экранированием"

# 056eec36b011435cb2f080c06191dc37
#: ../../howto/custom-template-tags.txt:769
msgid ""
"The output from template tags is **not** automatically run through the auto-"
"escaping filters (with the exception of :meth:`~django.template.Library."
"simple_tag` as described above). However, there are still a couple of things "
"you should keep in mind when writing a template tag."
msgstr ""
"Вывод тега **не** экранируется(за исключением :meth:`~django.template."
"Library.simple_tag`). Однако, есть несколько вещей которые следует помнить."

# fe359f349db14bfc8da7c36e70ba6ea3
#: ../../howto/custom-template-tags.txt:775
msgid ""
"If the ``render()`` function of your template stores the result in a context "
"variable (rather than returning the result in a string), it should take care "
"to call ``mark_safe()`` if appropriate. When the variable is ultimately "
"rendered, it will be affected by the auto-escape setting in effect at the "
"time, so content that should be safe from further escaping needs to be "
"marked as such."
msgstr ""
"Если метод ``render()`` добавляет переменную в контекст (вместо того, чтобы "
"вернуть строку), он должен пометить ее как безопасную используя функцию "
"``mark_safe()``, если это необходимо. В конечном итоге к переменной будет "
"применяться автоматическое экранирование при выводе в шаблоне, так что "
"необходимо пометить ее как безопасную чтобы избежать повторного "
"экранирования значения."

# 068213c734be49ca90143b6eaa74f35e
#: ../../howto/custom-template-tags.txt:782
msgid ""
"Also, if your template tag creates a new context for performing some sub-"
"rendering, set the auto-escape attribute to the current context's value. The "
"``__init__`` method for the ``Context`` class takes a parameter called "
"``autoescape`` that you can use for this purpose. For example::"
msgstr ""
"Если тег создает новый контекст, необходимо установить параметр "
"автоматического экранирования со значением текущего контекста. Метод "
"``__init__`` класса ``Context`` принимает аргумент ``autoescape``, который "
"вы можете использовать. Например::"

# df06f7d8b6ed4d11af9d36327084abad
#: ../../howto/custom-template-tags.txt:794
msgid ""
"This is not a very common situation, but it's useful if you're rendering a "
"template yourself. For example::"
msgstr ""
"Это не совсем обычная ситуация, но может быть полезно если вы самостоятельно "
"выполняете шаблон. Например::"

# da8c6c46b81e4e839f56df4dcc1ceabd
#: ../../howto/custom-template-tags.txt:801
msgid ""
"If we had neglected to pass in the current ``context.autoescape`` value to "
"our new ``Context`` in this example, the results would have *always* been "
"automatically escaped, which may not be the desired behavior if the template "
"tag is used inside a :ttag:`{% autoescape off %}<autoescape>` block."
msgstr ""
"Если бы мы не передали значение ``context.autoescape`` в новый ``Context``, "
"результат *всегда* экранировался бы, что может быть неуместным при "
"использовании тега в блоке :ttag:`{% autoescape off %}<autoescape>`."

# b46f5a83424b425482f2c948cb6cf1fb
#: ../../howto/custom-template-tags.txt:809
msgid "Thread-safety considerations"
msgstr "Учитываем потокобезопасность"

# a155746f3e0a4b7396c5b42abbde232d
#: ../../howto/custom-template-tags.txt:811
msgid ""
"Once a node is parsed, its ``render`` method may be called any number of "
"times. Since Django is sometimes run in multi-threaded environments, a "
"single node may be simultaneously rendering with different contexts in "
"response to two separate requests. Therefore, it's important to make sure "
"your template tags are thread safe."
msgstr ""
"После парсинга тега и создания узла его метод ``render`` может быть вызван "
"любое количество раз. Так как Django может выполняться в мультипоточном "
"окружении, один узел может выполняться с несколькими контекстами для "
"различных запросов. По этом важно удостовериться что ваши шаблонные теги "
"являются потокобезопасными."

# cb9e90f191c04635b6290ef60de3acc0
#: ../../howto/custom-template-tags.txt:817
msgid ""
"To make sure your template tags are thread safe, you should never store "
"state information on the node itself. For example, Django provides a "
"builtin :ttag:`cycle` template tag that cycles among a list of given strings "
"each time it's rendered:"
msgstr ""
"Чтобы ваш шаблонный тег был потокобезопасный, вы не должны сохранять "
"информацию о состоянии в узле. Например, Django предоставляет тег :ttag:"
"`cycle`, который переключается между аргументами при каждом вызове:"

# daff7756304d44e7bfd9e2c53b4f0c9f
#: ../../howto/custom-template-tags.txt:830
msgid ""
"A naive implementation of ``CycleNode`` might look something like this::"
msgstr "Реализация ``CycleNode`` могла бы выглядеть следующим образом::"

# abcc2d99ee1241e89920c4b63c1f733f
#: ../../howto/custom-template-tags.txt:842
msgid ""
"But, suppose we have two templates rendering the template snippet from above "
"at the same time:"
msgstr ""
"Однако, предположим что одновременно выполняется два экземпляра шаблона "
"представленного выше:"

# d08f0f47486d49f68786aae583679abb
#: ../../howto/custom-template-tags.txt:845
msgid ""
"Thread 1 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr ""
"Поток 1 выполняет первую итерацию по циклу, ``CycleNode.render()`` "
"возвращает 'row1'"

# 434d9e02007e4f76b0824a95da9644bf
#: ../../howto/custom-template-tags.txt:847
msgid ""
"Thread 2 performs its first loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr ""
"Поток 2 выполняет первую итерацию по циклу, ``CycleNode.render()`` "
"возвращает 'row2'"

# 45fbed42fde649e78d87484214b636bf
#: ../../howto/custom-template-tags.txt:849
msgid ""
"Thread 1 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row1'"
msgstr ""
"Поток 1 выполняет вторую итерацию по циклу, ``CycleNode.render()`` "
"возвращает 'row1'"

# 1f129836ce474697a113494eaefcbc4e
#: ../../howto/custom-template-tags.txt:851
msgid ""
"Thread 2 performs its second loop iteration, ``CycleNode.render()`` returns "
"'row2'"
msgstr ""
"Поток 2 выполняет вторую итерацию по циклу, ``CycleNode.render()`` "
"возвращает 'row2'"

# c2250343053b4189961bd3f79d6c388f
#: ../../howto/custom-template-tags.txt:854
msgid ""
"The CycleNode is iterating, but it's iterating globally. As far as Thread 1 "
"and Thread 2 are concerned, it's always returning the same value. This is "
"obviously not what we want!"
msgstr ""
"CycleNode работает, но итерация происходит глобально. Так как Поток 1 и "
"Поток 2 связаны, они используют одни значения. Это точно не то, что вам "
"нужно!"

# 7dc83b01196145a4afc208bc9f783934
#: ../../howto/custom-template-tags.txt:858
msgid ""
"To address this problem, Django provides a ``render_context`` that's "
"associated with the ``context`` of the template that is currently being "
"rendered. The ``render_context`` behaves like a Python dictionary, and "
"should be used to store ``Node`` state between invocations of the ``render`` "
"method."
msgstr ""
"Для решения этой проблемы Django предоставляет ``render_context`` в "
"контексте текущего шаблона. ``render_context`` работает как и словарь в "
"Python и должен использоваться для хранения состояния узлов между вызовами "
"метода ``render``."

# a9b1b9ca29394423b286251ba4479ee5
#: ../../howto/custom-template-tags.txt:863
msgid ""
"Let's refactor our ``CycleNode`` implementation to use the "
"``render_context``::"
msgstr ""
"Давайте перепишем ``CycleNode`` чтобы использовать ``render_context``::"

# 7e929c40d53c4b989ec09d368a01b36b
#: ../../howto/custom-template-tags.txt:875
msgid ""
"Note that it's perfectly safe to store global information that will not "
"change throughout the life of the ``Node`` as an attribute. In the case of "
"``CycleNode``, the ``cyclevars`` argument doesn't change after the ``Node`` "
"is instantiated, so we don't need to put it in the ``render_context``. But "
"state information that is specific to the template that is currently being "
"rendered, like the current iteration of the ``CycleNode``, should be stored "
"in the ``render_context``."
msgstr ""
"Заметим, что вполне безопасно сохранять в атрибутах объекта ``Node`` "
"информацию, которая не изменяется. В случае ``CycleNode``, параметр "
"``cyclevars`` не изменяется после создания экземпляра ``Node``, и нет "
"необходимости хранить его в ``render_context``. Но информация, которая "
"относится к конкретному шаблону, например текущая итерация узла "
"``CycleNode``, должна сохраняться в ``render_context``."

# cb6e5b7e78d14b6ba23ef41aa74d19aa
#: ../../howto/custom-template-tags.txt:884
msgid ""
"Notice how we used ``self`` to scope the ``CycleNode`` specific information "
"within the ``render_context``. There may be multiple ``CycleNodes`` in a "
"given template, so we need to be careful not to clobber another node's state "
"information. The easiest way to do this is to always use ``self`` as the key "
"into ``render_context``. If you're keeping track of several state variables, "
"make ``render_context[self]`` a dictionary."
msgstr ""
"Обратите внимание как мы используем ``self`` для привязки состояния к "
"текущему узлу в ``render_context``. В шаблоне может быть несколько "
"``CycleNode``, и важно не нарушить состояние других узлов. Самый просто "
"способ это использовать ``self`` в качестве ключа в ``render_context``. Если "
"вам необходимо хранить несколько переменных, используйте в "
"``render_context[self]`` словарь."

# 635efbbfd9a7445d9587f4f7747ba003
#: ../../howto/custom-template-tags.txt:892
msgid "Registering the tag"
msgstr "Регистрация тега"

# 551303317a7e466d916424759068775a
#: ../../howto/custom-template-tags.txt:894
msgid ""
"Finally, register the tag with your module's ``Library`` instance, as "
"explained in :ref:`writing custom template filters<howto-writing-custom-"
"template-tags>` above. Example::"
msgstr ""
"Теперь зарегистрируем тег в экземпляре ``Library`` вашего модуля, как "
"описано :ref:`выше<howto-writing-custom-template-tags>`. Например::"

# 44733858e6bf4ba6a33645cb08211dd9
#: ../../howto/custom-template-tags.txt:900
msgid "The ``tag()`` method takes two arguments:"
msgstr "Метод ``tag()`` принимает два аргумента:"

# 828a1e73a2564955b12544a246f18b53
#: ../../howto/custom-template-tags.txt:902
msgid ""
"The name of the template tag -- a string. If this is left out, the name of "
"the compilation function will be used."
msgstr ""
"Название шаблонного тега -- строкой. Если параметр не указан, используется "
"название функции."

# 113f5020cb694fe68a741c0f42cbac7a
#: ../../howto/custom-template-tags.txt:907
msgid ""
"As with filter registration, it is also possible to use this as a decorator::"
msgstr "Как и для регистрации фильтра, можно использовать как декоратор::"

# 6c8371a9c11046d1a1088c1c176ce3d4
#: ../../howto/custom-template-tags.txt:917
msgid ""
"If you leave off the ``name`` argument, as in the second example above, "
"Django will use the function's name as the tag name."
msgstr ""
"Если не указать параметр ``name``, как во втором примере, Django будет "
"использовать название функции в качестве названия тега."

# cb0b4a24982a4d658f3c083ee79b1ecf
#: ../../howto/custom-template-tags.txt:921
msgid "Passing template variables to the tag"
msgstr "Передача переменных шаблона в тег"

# cf36f683ca0448558610542164c09786
#: ../../howto/custom-template-tags.txt:923
msgid ""
"Although you can pass any number of arguments to a template tag using "
"``token.split_contents()``, the arguments are all unpacked as string "
"literals. A little more work is required in order to pass dynamic content (a "
"template variable) to a template tag as an argument."
msgstr ""
"Хоть вы и можете передать любое количество аргументов в шаблонный тег "
"используя ``token.split_contents()``, все аргументы передаются как строка. "
"Чтобы передать значение переменной шаблона, необходимо немного усложнить код."

# 6b50eca1c2c946deb4949cfbef64b7d4
#: ../../howto/custom-template-tags.txt:928
msgid ""
"While the previous examples have formatted the current time into a string "
"and returned the string, suppose you wanted to pass in a :class:`~django.db."
"models.DateTimeField` from an object and have the template tag format that "
"date-time:"
msgstr ""
"Тег из примера выше форматирует текущее время и возвращает строку. "
"Предположим вы хотите передать объект :class:`~django.db.models."
"DateTimeField` и отформатировать это значение:"

# 1b1c826df9044670a5e01a705cbd668b
#: ../../howto/custom-template-tags.txt:937
msgid "Initially, ``token.split_contents()`` will return three values:"
msgstr "``token.split_contents()`` вернет три значения:"

# a1930d17347a4e9b9d152e47092a23a6
#: ../../howto/custom-template-tags.txt:939
msgid "The tag name ``format_time``."
msgstr "Название тега ``format_time``."

# d2b1a32e78a54664b2797b2952153840
#: ../../howto/custom-template-tags.txt:940
msgid ""
"The string ``'blog_entry.date_updated'`` (without the surrounding quotes)."
msgstr "Строку ``'blog_entry.date_updated'`` (без кавычек)."

# 44c310f632b14b4b90b73b38ed8013c8
#: ../../howto/custom-template-tags.txt:942
msgid ""
"The formatting string ``'\"%Y-%m-%d %I:%M %p\"'``. The return value from "
"``split_contents()`` will include the leading and trailing quotes for string "
"literals like this."
msgstr ""
"Строку форматирования ``'\"%Y-%m-%d %I:%M %p\"'``. Значение из "
"``split_contents()`` будет содержать кавычки для таких переменных."

# 644bb640c790480aa20c52d453209807
#: ../../howto/custom-template-tags.txt:946
msgid "Now your tag should begin to look like this::"
msgstr "Теперь ваш тег будет выглядеть следующим образом::"

# 29508a57ba874d2d90e73af96f0f3cc6
#: ../../howto/custom-template-tags.txt:964
msgid ""
"You also have to change the renderer to retrieve the actual contents of the "
"``date_updated`` property of the ``blog_entry`` object.  This can be "
"accomplished by using the ``Variable()`` class in ``django.template``."
msgstr ""
"Теперь вам следует изменить метод ``render`` узла чтобы получить значение "
"атрибута ``date_updated`` объекта ``blog_entry``.  Это может быть выполнено "
"с использованием класса ``Variable()`` из ``django.template``."

# dd09df09e4ab45d08bbd1d5ebccdd06f
#: ../../howto/custom-template-tags.txt:968
msgid ""
"To use the ``Variable`` class, simply instantiate it with the name of the "
"variable to be resolved, and then call ``variable.resolve(context)``. So, "
"for example::"
msgstr ""
"Чтобы использовать класс ``Variable``, создайте экземпляр указав название "
"переменной, потом вызовите ``variable.resolve(context)``. Например::"

# be594d6e020c48f4bfcda50dc7b174ca
#: ../../howto/custom-template-tags.txt:984
msgid ""
"Variable resolution will throw a ``VariableDoesNotExist`` exception if it "
"cannot resolve the string passed to it in the current context of the page."
msgstr ""
"Будет вызвано исключение ``VariableDoesNotExist`` если невозможно найти "
"значение переменной в текущем контексте."

# a467c09456b643418e9e0f37a2d09532
#: ../../howto/custom-template-tags.txt:988
msgid "Setting a variable in the context"
msgstr "Добавление переменной в контекст"

# 2ce8c4df50644d5f95cc1e0e969cea9e
#: ../../howto/custom-template-tags.txt:990
msgid ""
"The above examples simply output a value. Generally, it's more flexible if "
"your template tags set template variables instead of outputting values. That "
"way, template authors can reuse the values that your template tags create."
msgstr ""
"Предыдущие примеры тегов просто выводят значение. Более гибкий способ - это "
"добавить значение в переменную контекста вместо вывода результата. Таким "
"образом автор шаблона может использовать результат выполнения тега несколько "
"раз."

# a5ec2f00c2544359b10cc84749f9c5a3
#: ../../howto/custom-template-tags.txt:994
msgid ""
"To set a variable in the context, just use dictionary assignment on the "
"context object in the ``render()`` method. Here's an updated version of "
"``CurrentTimeNode`` that sets a template variable ``current_time`` instead "
"of outputting it::"
msgstr ""
"Чтобы добавить переменную в контекст, просто добавьте значение в контекст "
"как в словарь в методе ``render()``. Вот обновленная версия "
"``CurrentTimeNode``, которая устанавливает переменную ``current_time`` "
"вместо вывода результата::"

# 9bc76d5aaafd4780bbe065b6afebad8f
#: ../../howto/custom-template-tags.txt:1009
msgid ""
"Note that ``render()`` returns the empty string. ``render()`` should always "
"return string output. If all the template tag does is set a variable, "
"``render()`` should return the empty string."
msgstr ""
"Заметим, что ``render()`` возвращает пустую строку. ``render()`` всегда "
"должен возвращать строку. Если все, что делает тег, это добавление "
"переменной в контекст, метод ``render()`` должен вернуть пустую строку."

# ebad61b12e814c97a451d0fcbd247aab
#: ../../howto/custom-template-tags.txt:1013
msgid "Here's how you'd use this new version of the tag:"
msgstr "Вот как вы можете использовать новую версию тега:"

# a467c09456b643418e9e0f37a2d09532
#: ../../howto/custom-template-tags.txt:1019
msgid "Variable scope in context"
msgstr "Область видимости переменной в контексте"

# 06531cf5f8cf4d42a476ffb303d4909f
#: ../../howto/custom-template-tags.txt:1021
msgid ""
"Any variable set in the context will only be available in the same ``block`` "
"of the template in which it was assigned. This behavior is intentional; it "
"provides a scope for variables so that they don't conflict with context in "
"other blocks."
msgstr ""
"Любая переменная, добавленная в контекст будет доступна только в "
"блоке(``block``) шаблона, в котором она была добавлена. Так сделано "
"намерено, чтобы переменные не конфликтовали с контекстом другого блока."

# af2b919fd09f499b8be9c5239e256fb6
#: ../../howto/custom-template-tags.txt:1026
msgid ""
"But, there's a problem with ``CurrentTimeNode2``: The variable name "
"``current_time`` is hard-coded. This means you'll need to make sure your "
"template doesn't use ``{{ current_time }}`` anywhere else, because the ``{% "
"current_time %}`` will blindly overwrite that variable's value. A cleaner "
"solution is to make the template tag specify the name of the output "
"variable, like so:"
msgstr ""
"Но есть одна проблема в ``CurrentTimeNode2``: название переменной "
"``current_time`` \"вшито\" в тег. Это означает, что вы должны убедиться, что "
"переменная ``{{ current_time }}`` не используется в шаблоне, потому что ``{% "
"current_time %}`` перезапишет ее. Правильное решение -- позволить указывать "
"название переменной при вызове тега:"

# 3093c1af0111471dab1f3049767142a5
#: ../../howto/custom-template-tags.txt:1038
msgid ""
"To do that, you'll need to refactor both the compilation function and "
"``Node`` class, like so::"
msgstr ""
"Чтобы это сделать вам нужно изменить код функции компиляции и подкласса "
"``Node``::"

# ed22884d2c024407bcaee7e59d227627
#: ../../howto/custom-template-tags.txt:1070
msgid ""
"The difference here is that ``do_current_time()`` grabs the format string "
"and the variable name, passing both to ``CurrentTimeNode3``."
msgstr ""
"Разница в том, что ``do_current_time()`` получает формат строки и название "
"переменной и передает в конструктор ``CurrentTimeNode3``."

# e72c95eadd7a49dbb860a5065efd9346
#: ../../howto/custom-template-tags.txt:1073
msgid ""
"Finally, if you only need to have a simple syntax for your custom context-"
"updating template tag, consider using the :meth:`~django.template.Library."
"simple_tag` shortcut, which supports assigning the tag results to a template "
"variable."
msgstr ""

# 0864842205cf44f0a9411a42ab7a6f8c
#: ../../howto/custom-template-tags.txt:1079
msgid "Parsing until another block tag"
msgstr "Создание блочного тега"

# bb85f78297ea42dd93b0d3e0addae196
#: ../../howto/custom-template-tags.txt:1081
msgid ""
"Template tags can work in tandem. For instance, the standard :ttag:`{% "
"comment %}<comment>` tag hides everything until ``{% endcomment %}``. To "
"create a template tag such as this, use ``parser.parse()`` in your "
"compilation function."
msgstr ""
"Шаблонные теги могут работать вместе. Например, встроенный тег :ttag:`{% "
"comment %}<comment>` скрывает содержимое до тега ``{% endcomment %}``. Чтобы "
"создать подобный тег, используйте ``parser.parse()`` в функции компиляции "
"тега."

# d12c8ba7ad8448ed9f0cf96403a41b0c
#: ../../howto/custom-template-tags.txt:1086
msgid "Here's how a simplified ``{% comment %}`` tag might be implemented::"
msgstr "Вот простая реализация тега ``{% comment %}``::"

# 6d47f0d512d94a30a3727ef5fd54ffce
#: ../../howto/custom-template-tags.txt:1098
msgid ""
"The actual implementation of :ttag:`{% comment %}<comment>` is slightly "
"different in that it allows broken template tags to appear between ``{% "
"comment %}`` and ``{% endcomment %}``. It does so by calling ``parser."
"skip_past('endcomment')`` instead of ``parser.parse(('endcomment',))`` "
"followed by ``parser.delete_first_token()``, thus avoiding the generation of "
"a node list."
msgstr ""
"Реализация :ttag:`{% comment %}<comment>` немного отличается от нашего "
"примера, позволяя использовать неправильные теги между ``{% comment %}`` и "
"``{% endcomment %}``. Для этого используется ``parser."
"skip_past('endcomment')`` вместо ``parser.parse(('endcomment',))`` перед "
"``parser.delete_first_token()``, такой вариант не генерирует список узлов."

# af2b9e4acc4b4a76a633290792a75149
#: ../../howto/custom-template-tags.txt:1105
msgid ""
"``parser.parse()`` takes a tuple of names of block tags ''to parse until''. "
"It returns an instance of ``django.template.NodeList``, which is a list of "
"all ``Node`` objects that the parser encountered ''before'' it encountered "
"any of the tags named in the tuple."
msgstr ""
"``parser.parse()`` принимает кортеж названий тегов для \"парсинга, пока они "
"не встретятся\". Функция вернет объект ``django.template.NodeList``, который "
"является списком объектов ``Node`` встреченных ''до'' любого из тегов "
"указанных в кортеже."

# 82fda08a59c04be6b8728f5a4ef57943
#: ../../howto/custom-template-tags.txt:1110
msgid ""
"In ``\"nodelist = parser.parse(('endcomment',))\"`` in the above example, "
"``nodelist`` is a list of all nodes between the ``{% comment %}`` and ``{% "
"endcomment %}``, not counting ``{% comment %}`` and ``{% endcomment %}`` "
"themselves."
msgstr ""
"В ``\"nodelist = parser.parse(('endcomment',))\"`` из нашего примера, "
"``nodelist`` -- это список всех узлов встреченных между ``{% comment %}`` и "
"``{% endcomment %}``, не включая ``{% comment %}`` и ``{% endcomment %}``."

# a515afe5dc7647a8a8fb5f212d24301d
#: ../../howto/custom-template-tags.txt:1115
msgid ""
"After ``parser.parse()`` is called, the parser hasn't yet \"consumed\" the "
"``{% endcomment %}`` tag, so the code needs to explicitly call ``parser."
"delete_first_token()``."
msgstr ""
"После вызова ``parser.parse()`` парсер не \"обрабатывает\" тег ``{% "
"endcomment %}``, поэтому необходимо вызвать ``parser.delete_first_token()``."

# 2f600b0ed320466c8ff0d45e76535205
#: ../../howto/custom-template-tags.txt:1119
msgid ""
"``CommentNode.render()`` simply returns an empty string. Anything between "
"``{% comment %}`` and ``{% endcomment %}`` is ignored."
msgstr ""
"``CommentNode.render()`` просто возвращает пустую строку. Все между ``{% "
"comment %}`` и ``{% endcomment %}`` игнорируется."

# c0f02e8db35846e0abc8f81aca553102
#: ../../howto/custom-template-tags.txt:1123
msgid "Parsing until another block tag, and saving contents"
msgstr "Обработка блочного тега с сохранением содержимого"

# 5104a8fd8f814d9b94bbb761a29168f1
#: ../../howto/custom-template-tags.txt:1125
msgid ""
"In the previous example, ``do_comment()`` discarded everything between ``{% "
"comment %}`` and ``{% endcomment %}``. Instead of doing that, it's possible "
"to do something with the code between block tags."
msgstr ""
"В примере выше, ``do_comment()`` игнорирует содержимое между ``{% comment %}"
"`` и ``{% endcomment %}``. Вместо этого можно выполнить какие-либо операции "
"над содержимым блочного тега."

# c802603e6d084028ad6b09acb60867bf
#: ../../howto/custom-template-tags.txt:1129
msgid ""
"For example, here's a custom template tag, ``{% upper %}``, that capitalizes "
"everything between itself and ``{% endupper %}``."
msgstr ""
"Например, у нас есть тег ``{% upper %}``, который преобразует содержимое до "
"тега ``{% endupper %}`` в верхний регистр."

# 8c8791cda74942ab9e4b7221831ae9d0
#: ../../howto/custom-template-tags.txt:1132
msgid "Usage:"
msgstr "Пример использования:"

# 39b888de02654eb6af5c3652b2143f21
#: ../../howto/custom-template-tags.txt:1138
msgid ""
"As in the previous example, we'll use ``parser.parse()``. But this time, we "
"pass the resulting ``nodelist`` to the ``Node``::"
msgstr ""
"Как и в предыдущем примере мы будем использовать ``parser.parse()``. Но в "
"этот раз полученный ``nodelist`` передадим в ``Node``::"

# 083d504d1e674b3f893c364868913f02
#: ../../howto/custom-template-tags.txt:1153
msgid ""
"The only new concept here is the ``self.nodelist.render(context)`` in "
"``UpperNode.render()``."
msgstr ""
"Новым здесь является вызов ``self.nodelist.render(context)`` в ``UpperNode."
"render()``."

# e5979651d15b4dabad2dc4e371b24e76
#: ../../howto/custom-template-tags.txt:1156
msgid ""
"For more examples of complex rendering, see the source code of :ttag:`{% for "
"%}<for>` in ``django/template/defaulttags.py`` and :ttag:`{% if %}<if>` in "
"``django/template/smartif.py``."
msgstr ""
"Более сложные примеры ищите в исходном коде реализации :ttag:`{% for %}"
"<for>` в ``django/template/defaulttags.py`` и :ttag:`{% if %}<if>` в "
"``django/template/smartif.py``."

# 0b11deea0b4244769146666bc73e4dd9
#~ msgid "Assignment tags"
#~ msgstr "Присваивающий тег"

#~ msgid ""
#~ "``simple_tag`` can now store results in a template variable and should be "
#~ "used instead."
#~ msgstr ""
#~ "``simple_tag`` теперь может сохранять результат в переменной шаблона."

# 801aa2bf145d49e2821e86b6418f90d6
#~ msgid ""
#~ "To ease the creation of tags setting a variable in the context, Django "
#~ "provides a helper function, ``assignment_tag``. This function works the "
#~ "same way as :meth:`~django.template.Library.simple_tag` except that it "
#~ "stores the tag's result in a specified context variable instead of "
#~ "directly outputting it."
#~ msgstr ""
#~ "Для простого создания тегов, которые добавляют переменную в контекст, "
#~ "Django предоставляет функцию ``assignment_tag``. Эта функция работает так "
#~ "же, как и :meth:`~django.template.Library.simple_tag`, за исключением, "
#~ "что она добавляет результат в контекст, а не возвращает его."

# 6b3e303ef65b4eb4ad21e9536c98f37b
# 5e75b0df73e74e3fa49141eb69c8e5ea
#~ msgid ""
#~ "Our earlier ``current_time`` function could thus be written like this::"
#~ msgstr "Функцию ``current_time`` можно переписать следующим образом::"

# 8c4118eb745246b3be25c9ea9a3c5b2d
#~ msgid ""
#~ "You may then store the result in a template variable using the ``as`` "
#~ "argument followed by the variable name, and output it yourself where you "
#~ "see fit:"
#~ msgstr ""
#~ "Вы можете добавить результат в переменную шаблона, используя аргумент "
#~ "``as`` и название переменной, и использовать его при необходимости:"

#~ msgid ""
#~ "Auto-escaping for ``simple_tag`` as described in the previous two "
#~ "paragraphs was added."
#~ msgstr "Было добавлено автоматическое экранирование для ``simple_tag``."

# 56b6dd0602324e8cbb200945f7f061af
#~ msgid ""
#~ "**Strings marked as \"needing escaping\"** are *always* escaped on "
#~ "output, regardless of whether they are in an :ttag:`autoescape` block or "
#~ "not. These strings are only escaped once, however, even if auto-escaping "
#~ "applies."
#~ msgstr ""
#~ "**Строки с пометкой \"требуют экранирования\"** -- *всегда* экранируются "
#~ "при выводе, независимо от того находятся они в блоке :ttag:`autoescape` "
#~ "или нет. Такие строки экранируются только один раз, независимо от того, "
#~ "включено автоматическое экранирование или нет."

# d1a4f2e8fc2c483698615373e1d2308f
#~ msgid ""
#~ "Internally, these strings are of type ``EscapeBytes`` or ``EscapeText``. "
#~ "Generally you don't have to worry about these; they exist for the "
#~ "implementation of the :tfilter:`escape` filter."
#~ msgstr ""
#~ "Внутренне эти строки представлены типами ``EscapeBytes`` или "
#~ "``EscapeText``. Вам не обязательно это знать, можно просто использовать "
#~ "фильтр :tfilter:`escape`."

#~ msgid ""
#~ "The ``template`` attribute of ``Context`` objects was added in Django "
#~ "1.8. :meth:`context.template.engine.get_template <django.template.Engine."
#~ "get_template>` must be used instead of :func:`django.template.loader."
#~ "get_template` because the latter now returns a wrapper whose ``render`` "
#~ "method doesn't accept a :class:`~django.template.Context`."
#~ msgstr ""
#~ "В Django 1.8 был добавлен атрибут ``template`` объектам ``Context``. "
#~ "Вместо :func:`django.template.loader.get_template` следует использовать :"
#~ "meth:`context.template.engine.get_template <django.template.Engine."
#~ "get_template>`, потому что первый возвращает обертку с методом "
#~ "``render``, который не принимает :class:`~django.template.Context`."

# dd61713ccf6d4cc2a9dc2074164a057b
#~ msgid ""
#~ "Custom template tags and filters must live inside a Django app. If they "
#~ "relate to an existing app it makes sense to bundle them there; otherwise, "
#~ "you should create a new app to hold them."
#~ msgstr ""
#~ "Собственные теги и фильтры шаблонов должны определяться в приложении "
#~ "Django. Если они логически связаны с каким-то приложением, есть смысл "
#~ "добавить их в это приложение, иначе создайте новое приложение."

# 5d0ac2caecd8431cadc1557c66a0ab1f
#~ msgid ""
#~ "``assignment_tag`` functions may accept any number of positional or "
#~ "keyword arguments. For example::"
#~ msgstr ""
#~ "``assignment_tag`` может принимать любое количество позиционных и "
#~ "именованных аргументов. Например::"

# cbd0ae84453e474d969c48aed77551f3
#~ msgid "Tags are more complex than filters, because tags can do anything."
#~ msgstr "Теги сложнее фильтров, так как они могут делать, что угодно."

# 3b708e803a304a47b0b157e113e0d912
# 12b4218b09634ef2a4c1c26c37bbce94
#~ msgid "The decorator syntax also works:"
#~ msgstr "Можно использовать как декоратор:"

# 3550a96a7b114a49adab9a15ae61e9fc
# f81c8e75e5904683a4da1a3b9a221774
#~ msgid "Or, using decorator syntax:"
#~ msgstr "Или:"

# d212fb15044242eba621a1d83f5cdd35
#~ msgid "As always, decorator syntax works as well, so we could have written:"
#~ msgstr "Можно использовать и как декоратор:"

# f0cce9afae1d48b89c0d3b5a8f158b6a
#~ msgid ""
#~ "Filter functions should always return something. They shouldn't raise "
#~ "exceptions. They should fail silently. In case of error, they should "
#~ "return either the original input or an empty string -- whichever makes "
#~ "more sense."
#~ msgstr ""
#~ "Функция фильтра всегда должна возвращать значение. Она не должна вызывать "
#~ "исключение. Исключения должны перехватываться. В случае ошибки фильтр "
#~ "должен вернуть оригинальное значение или пустую строку."

# 3e6711a33054466e88da60820836980d
#~ msgid ""
#~ "``is_safe`` and ``needs_autoescape`` used to be attributes of the filter "
#~ "function; this syntax is deprecated."
#~ msgstr ""
#~ "``is_safe`` и ``needs_autoescape`` раньше использовались как атрибуты "
#~ "функции, такой подход устарел."

# 3f3157cd62274486aa19e8f0e7eab101
#~ msgid ""
#~ "``render()`` should never raise ``TemplateSyntaxError`` or any other "
#~ "exception. It should fail silently, just as template filters should."
#~ msgstr ""
#~ "``render()`` не должен вызывать исключение ``TemplateSyntaxError`` или "
#~ "любое другое. Все ошибки должны игнорироваться как и в фильтре."
