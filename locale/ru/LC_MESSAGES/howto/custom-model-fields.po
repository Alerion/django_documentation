# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015, 2016, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-03 16:48+0300\n"
"PO-Revision-Date: 2017-11-29 16:05+0200\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# eabd345927e84a968480dbd99090574a
#: ../../howto/custom-model-fields.txt:3
msgid "Writing custom model fields"
msgstr "Создание собственных полей для модели"

# a007a94b8b6f49b29bfa4c14850a7c43
#: ../../howto/custom-model-fields.txt:8
msgid "Introduction"
msgstr "Предисловие"

# 522b5aafe8194b0b8e2f4e7b9fc58254
#: ../../howto/custom-model-fields.txt:10
msgid ""
"The :doc:`model reference </topics/db/models>` documentation explains how to "
"use Django's standard field classes -- :class:`~django.db.models."
"CharField`, :class:`~django.db.models.DateField`, etc. For many purposes, "
"those classes are all you'll need. Sometimes, though, the Django version "
"won't meet your precise requirements, or you'll want to use a field that is "
"entirely different from those shipped with Django."
msgstr ""
":doc:`Раздел о моделях </topics/db/models>` описывает, как использовать "
"стандартные поля модели Django -- :class:`~django.db.models.CharField`, :"
"class:`~django.db.models.DateField`, и т.д. В большинстве случаев эти классы "
"- все что вам будет нужно. Однако в некоторых случаях предоставленные Django "
"поля модели не предоставляют необходимый функционал."

# 99520afcb0e24d82bf90b6bfe22654ab
#: ../../howto/custom-model-fields.txt:17
msgid ""
"Django's built-in field types don't cover every possible database column "
"type -- only the common types, such as ``VARCHAR`` and ``INTEGER``. For more "
"obscure column types, such as geographic polygons or even user-created types "
"such as `PostgreSQL custom types`_, you can define your own Django ``Field`` "
"subclasses."
msgstr ""
"Встроенные поля не покрывают все возможные типы полей базы данных -- только "
"стандартные типы, такие как ``VARCHAR`` и ``INTEGER``. Для остальных типов "
"полей, такие как хранящие географические полигоны или  `собственные типы "
"полей в PostgreSQL <http://www.postgresql.org/docs/8.2/interactive/sql-"
"createtype.html>`_, вы можете создать собственный подкласс для ``Field``."

# 24e1f6beda054a7b8f5f9cefeb859451
#: ../../howto/custom-model-fields.txt:24
msgid ""
"Alternatively, you may have a complex Python object that can somehow be "
"serialized to fit into a standard database column type. This is another case "
"where a ``Field`` subclass will help you use your object with your models."
msgstr ""
"Также вы можете создать поле для хранения сложного Python объекта в "
"стандартном поле. Это другая проблема, которую помогает решить подкласс "
"``Field``."

# 5f96e84cae69475ca5768a1b5c928cf0
#: ../../howto/custom-model-fields.txt:29
msgid "Our example object"
msgstr "Описание примера"

# 6b2d150c06fb4be7809dcc29f333c510
#: ../../howto/custom-model-fields.txt:31
msgid ""
"Creating custom fields requires a bit of attention to detail. To make things "
"easier to follow, we'll use a consistent example throughout this document: "
"wrapping a Python object representing the deal of cards in a hand of "
"Bridge_. Don't worry, you don't have to know how to play Bridge to follow "
"this example. You only need to know that 52 cards are dealt out equally to "
"four players, who are traditionally called *north*, *east*, *south* and "
"*west*.  Our class looks something like this::"
msgstr ""
"Создание собственного поля требует внимания к деталям. Для простоты "
"понимания мы будем использовать один и тот же пример в этом разделе: объект, "
"который содержит состояние карт на руках для карточной игры  `Бридж <http://"
"ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B8%D0%B4%D0%B6>`_. Не беспокойтесь, "
"вам не обязательно знать правила этой игры. Все что вам необходимо знать -- "
"52 делятся поровну между четырьмя игроками, которых традиционно называют "
"*north*, *east*, *south* и *west*.  Наш класс выглядит следующим образом::"

# d4b7ec96594d443796183251974adef8
#: ../../howto/custom-model-fields.txt:53
msgid ""
"This is just an ordinary Python class, with nothing Django-specific about "
"it. We'd like to be able to do things like this in our models (we assume the "
"``hand`` attribute on the model is an instance of ``Hand``)::"
msgstr ""
"Это простой класс Python, ничего Django-специфического. Мы хотим "
"использовать нашу модель следующим образом (предполагается, что атрибут "
"модели ``hand`` это объект ``Hand``)::"

# 4080e601506345e697dc023e2c40fc28
#: ../../howto/custom-model-fields.txt:64
msgid ""
"We assign to and retrieve from the ``hand`` attribute in our model just like "
"any other Python class. The trick is to tell Django how to handle saving and "
"loading such an object."
msgstr ""
"Получение и назначение значений атрибута ``hand`` нашей модели аналогично "
"любому другому классу в Python. Хитрость заключается в том, чтобы научить "
"Django сохранять и загружать наш объект."

# 8e4f20ee1fb04de9b38aee4a333fec78
#: ../../howto/custom-model-fields.txt:68
msgid ""
"In order to use the ``Hand`` class in our models, we **do not** have to "
"change this class at all. This is ideal, because it means you can easily "
"write model support for existing classes where you cannot change the source "
"code."
msgstr ""
"Для использования класса ``Hand`` в наших моделях, мы **не должны** изменять "
"этот класс. Таким образом можно использовать в моделях существующие классы, "
"которые мы не можем изменить."

# 79e09c752a5d4b1f8f2c56f49b2b2d04
#: ../../howto/custom-model-fields.txt:73
msgid ""
"You might only be wanting to take advantage of custom database column types "
"and deal with the data as standard Python types in your models; strings, or "
"floats, for example. This case is similar to our ``Hand`` example and we'll "
"note any differences as we go along."
msgstr ""
"В некоторых случаях вы захотите использовать возможности определенных типов "
"полей базы данных, но использовать стандартные типы Python: строки, числа и "
"др. Этот случай похож на наш пример с классом ``Hand`` и мы укажем на все "
"отличия."

# 20907799496f4c058f13944e9a03e4ad
#: ../../howto/custom-model-fields.txt:79
msgid "Background theory"
msgstr "Теория"

# aa87348cf30245d98dcb5ac5144a078d
#: ../../howto/custom-model-fields.txt:82
msgid "Database storage"
msgstr "Хранение в базе данных"

# a48e085a8a704b8ea8f267b621c4dffb
#: ../../howto/custom-model-fields.txt:84
msgid ""
"The simplest way to think of a model field is that it provides a way to take "
"a normal Python object -- string, boolean, ``datetime``, or something more "
"complex like ``Hand`` -- and convert it to and from a format that is useful "
"when dealing with the database (and serialization, but, as we'll see later, "
"that falls out fairly naturally once you have the database side under "
"control)."
msgstr ""
"Основное предназначение поля модели -- это преобразование объекта Python "
"(строка, булево значение, ``datetime``, или что-либо более сложное, как "
"``Hand``) в формат удобный для хранения в базе данных и обратно (и "
"сериализация, но, как мы увидим далее,  это решается естественным способом "
"при решении проблем преобразования данных для базы данных)."

# a17543dc40ec4166adcbf74d9536b2f9
#: ../../howto/custom-model-fields.txt:90
msgid ""
"Fields in a model must somehow be converted to fit into an existing database "
"column type. Different databases provide different sets of valid column "
"types, but the rule is still the same: those are the only types you have to "
"work with. Anything you want to store in the database must fit into one of "
"those types."
msgstr ""
"Значение поля модели должно быть преобразовано в один из доступных типов "
"полей базы данных. Различные базы данных предоставляют различные типы полей, "
"но правило остается одно: вы можете работать только с этими типами. Все, что "
"вы хотите сохранить в базе данных, должно быть преобразовано в один из "
"доступных типов данных."

# 8e1b0d8de7284f20b4e41774ead788fc
#: ../../howto/custom-model-fields.txt:96
msgid ""
"Normally, you're either writing a Django field to match a particular "
"database column type, or there's a fairly straightforward way to convert "
"your data to, say, a string."
msgstr ""
"Скорее всего, вы создаете поле модели для использования типа поля конкретной "
"базы данных, или же преобразуете данные, предположим, в строку."

# d7ac1d9af268401195b01445d57875b3
#: ../../howto/custom-model-fields.txt:100
msgid ""
"For our ``Hand`` example, we could convert the card data to a string of 104 "
"characters by concatenating all the cards together in a pre-determined order "
"-- say, all the *north* cards first, then the *east*, *south* and *west* "
"cards. So ``Hand`` objects can be saved to text or character columns in the "
"database."
msgstr ""
"Для нашего примера с ``Hand``, мы можем преобразовать данные о картах в "
"строку из 104 символов соединив все карты вместе в определенном порядке -- "
"скажем, сначала все карты *north*, затем карты *east*, *south* и *west*. "
"Таким образом объект ``Hand`` будет сохранен в текстовом поле базы данных."

# 4a39936217ea4e5683f3f6a457e3a128
#: ../../howto/custom-model-fields.txt:106
msgid "What does a field class do?"
msgstr "Что делает класс поля?"

# 8877ca589a4040ba8406976e5a819967
#: ../../howto/custom-model-fields.txt:108
msgid ""
"All of Django's fields (and when we say *fields* in this document, we always "
"mean model fields and not :doc:`form fields </ref/forms/fields>`) are "
"subclasses of :class:`django.db.models.Field`. Most of the information that "
"Django records about a field is common to all fields -- name, help text, "
"uniqueness and so forth. Storing all that information is handled by "
"``Field``. We'll get into the precise details of what ``Field`` can do later "
"on; for now, suffice it to say that everything descends from ``Field`` and "
"then customizes key pieces of the class behavior."
msgstr ""
"Все поля в Django(и когда мы говорим *поля* в этом разделе, мы всегда "
"подразумеваем поля модели, а не :doc:`поля формы </ref/forms/fields>`) "
"являются подклассами :class:`django.db.models.Field`. Большинство информации "
"о поле, которую хранит Django, общая для всех типов полей -- название, "
"описание, уникальность и др. Вся эта информация хранится в ``Field``. Мы "
"рассмотрим возможности ``Field`` чуть позже, сейчас же запомним, что все "
"поля наследуются от ``Field`` и переопределяют поведение этого класса."

# c5434e0868214f88a525fe840d5473ad
#: ../../howto/custom-model-fields.txt:117
msgid ""
"It's important to realize that a Django field class is not what is stored in "
"your model attributes. The model attributes contain normal Python objects. "
"The field classes you define in a model are actually stored in the ``Meta`` "
"class when the model class is created (the precise details of how this is "
"done are unimportant here). This is because the field classes aren't "
"necessary when you're just creating and modifying attributes. Instead, they "
"provide the machinery for converting between the attribute value and what is "
"stored in the database or sent to the :doc:`serializer </topics/"
"serialization>`."
msgstr ""
"Важно понять, что класс поля -- это не то, что хранится в атрибуте модели. "
"Атрибуты модели содержат объекты Python. Классы полей, которые вы указали в "
"модели, на самом деле сохраняются в классе ``Meta`` при создании класса "
"модели. Вот почему мы не используем классы полей при редактировании "
"атрибутов экземпляра модели, их задача преобразовывать значение атрибутов в "
"данные сохраняемые в базе данных или передаваемые в :doc:`сериализатор </"
"topics/serialization>`."

# d3c008f1816a4d0bb2868882de18ef60
#: ../../howto/custom-model-fields.txt:126
msgid ""
"Keep this in mind when creating your own custom fields. The Django ``Field`` "
"subclass you write provides the machinery for converting between your Python "
"instances and the database/serializer values in various ways (there are "
"differences between storing a value and using a value for lookups, for "
"example). If this sounds a bit tricky, don't worry -- it will become clearer "
"in the examples below. Just remember that you will often end up creating two "
"classes when you want a custom field:"
msgstr ""
"Будьте внимательны при создании собственного поля. Подкласс ``Field``  "
"предоставляет несколько способов преобразования объектов Python в значение "
"для базы/сериализации (например, сохраняемое значение и значение для фильтра "
"по полю отличаются). Не волнуйтесь если звучит слишком сложно -- мы во всем "
"разберемся на примере чуть ниже. Просто запомните, что скорее всего вам "
"придется создавать два класса:"

# 6a5e465e308d49a8b8a223984b3b070a
#: ../../howto/custom-model-fields.txt:134
msgid ""
"The first class is the Python object that your users will manipulate. They "
"will assign it to the model attribute, they will read from it for displaying "
"purposes, things like that. This is the ``Hand`` class in our example."
msgstr ""
"Первый класс будет использоваться пользователями. Экземпляр этого класса "
"будет использоваться для отображения, работы с данными, при изменении "
"значения поля модели. В нашем примере это класс ``Hand``."

# 823328d62eff49c5946f07821a5421e4
#: ../../howto/custom-model-fields.txt:139
msgid ""
"The second class is the ``Field`` subclass. This is the class that knows how "
"to convert your first class back and forth between its permanent storage "
"form and the Python form."
msgstr ""
"Второй класс -- это подкласс ``Field``. Это класс, который отвечает за "
"преобразование вашего первого класса в значение для хранения в базе данных и "
"обратно в объект Python."

# 1399371549a64822a0c17804b5b6a1e7
#: ../../howto/custom-model-fields.txt:144
msgid "Writing a field subclass"
msgstr "Создание подкласса поля"

# 0a5b595071ce4e279b9c07db82b6180f
#: ../../howto/custom-model-fields.txt:146
msgid ""
"When planning your :class:`~django.db.models.Field` subclass, first give "
"some thought to which existing :class:`~django.db.models.Field` class your "
"new field is most similar to. Can you subclass an existing Django field and "
"save yourself some work? If not, you should subclass the :class:`~django.db."
"models.Field` class, from which everything is descended."
msgstr ""
"При создании подкласса :class:`~django.db.models.Field`, сначала подумайте, "
"не похож ли он на уже существующее поле. Можете ли унаследоваться от "
"существующего поля Django и сэкономить этим свое время? Если нет, создавайте "
"подкласс :class:`~django.db.models.Field`."

# 633019c5cc4e4bb3817d22adf0987a45
#: ../../howto/custom-model-fields.txt:152
msgid ""
"Initializing your new field is a matter of separating out any arguments that "
"are specific to your case from the common arguments and passing the latter "
"to the ``__init__()`` method of :class:`~django.db.models.Field` (or your "
"parent class)."
msgstr ""
"При создании конструктора важно разделить аргументы специфические для вашего "
"поля и те, которые следует передать в метод ``__init__()`` :class:`~django."
"db.models.Field`(или вашего родительского класса)."

# 60eaa5efcae74a40be5dedd056de124a
#: ../../howto/custom-model-fields.txt:157
msgid ""
"In our example, we'll call our field ``HandField``. (It's a good idea to "
"call your :class:`~django.db.models.Field` subclass ``<Something>Field``, so "
"it's easily identifiable as a :class:`~django.db.models.Field` subclass.) It "
"doesn't behave like any existing field, so we'll subclass directly from :"
"class:`~django.db.models.Field`::"
msgstr ""
"Назовем наше поле ``HandField``. (Хорошая практика называть подклассы :class:"
"`~django.db.models.Field` как ``<Something>Field``, таким образом легко "
"определить, какой класс является подклассом :class:`~django.db.models."
"Field`.) Оно не похоже ни на одно встроенное в Django поле, поэтому мы "
"создаем подкласс :class:`~django.db.models.Field`::"

# ee25de1a435d47b7a13fe7777294101a
#: ../../howto/custom-model-fields.txt:173
msgid ""
"Our ``HandField`` accepts most of the standard field options (see the list "
"below), but we ensure it has a fixed length, since it only needs to hold 52 "
"card values plus their suits; 104 characters in total."
msgstr ""
"``HandField`` принимает большинство стандартных аргументов (смотрите список "
"ниже), но мы явно указываем длину поля так как нам необходимо хранить только "
"значения 52 карт и их принадлежность, всего 104 символа."

# 46e3867dbaa14b4994371029d5a610ae
#: ../../howto/custom-model-fields.txt:179
msgid ""
"Many of Django's model fields accept options that they don't do anything "
"with. For example, you can pass both :attr:`~django.db.models.Field."
"editable` and :attr:`~django.db.models.DateField.auto_now` to a :class:"
"`django.db.models.DateField` and it will simply ignore the :attr:`~django.db."
"models.Field.editable` parameter (:attr:`~django.db.models.DateField."
"auto_now` being set implies ``editable=False``). No error is raised in this "
"case."
msgstr ""
"Большинство полей модели в Django принимают параметры, которые они совсем не "
"используют. Например, вы можете передать :attr:`~django.db.models.Field."
"editable` и :attr:`~django.db.models.DateField.auto_now` в :class:`django.db."
"models.DateField`, аргумент :attr:`~django.db.models.Field.editable` будет "
"проигнорирован (:attr:`~django.db.models.DateField.auto_now`устанавливает  "
"``editable=False``). Вы не получите ошибку."

# 95d3dc3c7ca24d0c86ce1d51b0b60dc9
#: ../../howto/custom-model-fields.txt:188
msgid ""
"This behavior simplifies the field classes, because they don't need to check "
"for options that aren't necessary. They just pass all the options to the "
"parent class and then don't use them later on. It's up to you whether you "
"want your fields to be more strict about the options they select, or to use "
"the simpler, more permissive behavior of the current fields."
msgstr ""
"Такое поведение упрощает классы полей, так как они не должны проверять все "
"аргументы. Они просто передают их в родительский класс и больше не "
"используют. Вы можете использовать более строгие правила и проверять все "
"входящие аргументы или же использовать более простой и гибкий путь, как это "
"делают встроенные классы."

# 71ac7654819a4e2aa0a4d957d36d6956
#: ../../howto/custom-model-fields.txt:194
msgid "The ``Field.__init__()`` method takes the following parameters:"
msgstr "Метод ``Field.__init__()`` принимает следующие параметры:"

# 62b668405af647f7ad7f00f2242b30a5
#: ../../howto/custom-model-fields.txt:196
msgid ":attr:`~django.db.models.Field.verbose_name`"
msgstr ":attr:`~django.db.models.Field.verbose_name`"

# e6b7a7b49b7a4294aa1ebfafaf0bc581
#: ../../howto/custom-model-fields.txt:197
msgid "``name``"
msgstr "``name``"

# e9a44d3f4a35471cbe34b22487476570
#: ../../howto/custom-model-fields.txt:198
msgid ":attr:`~django.db.models.Field.primary_key`"
msgstr ":attr:`~django.db.models.Field.primary_key`"

# ffa8b81c5a65428b968bbd24ac211d71
#: ../../howto/custom-model-fields.txt:199
msgid ":attr:`~django.db.models.CharField.max_length`"
msgstr ":attr:`~django.db.models.CharField.max_length`"

# cc91254f8c694e2e887c448c4d3cc527
#: ../../howto/custom-model-fields.txt:200
msgid ":attr:`~django.db.models.Field.unique`"
msgstr ":attr:`~django.db.models.Field.unique`"

# b7cb2217a109413787f604fe98867b53
#: ../../howto/custom-model-fields.txt:201
msgid ":attr:`~django.db.models.Field.blank`"
msgstr ":attr:`~django.db.models.Field.blank`"

# 37000e70038e49b49318b6cccb87f9e1
#: ../../howto/custom-model-fields.txt:202
msgid ":attr:`~django.db.models.Field.null`"
msgstr ":attr:`~django.db.models.Field.null`"

# 52825cda20fa428dbef53aad36be706c
#: ../../howto/custom-model-fields.txt:203
msgid ":attr:`~django.db.models.Field.db_index`"
msgstr ":attr:`~django.db.models.Field.db_index`"

# bc77cf2f14f348bebaf7a78040577433
#: ../../howto/custom-model-fields.txt:204
msgid ""
"``rel``: Used for related fields (like :class:`ForeignKey`). For advanced "
"use only."
msgstr ""
"``rel``: Используется для внешних ключей (таких как :class:`ForeignKey`). "
"Для опытных пользователей."

# 5c341f7c1ac94d3c9a4ce32720845c54
#: ../../howto/custom-model-fields.txt:206
msgid ":attr:`~django.db.models.Field.default`"
msgstr ":attr:`~django.db.models.Field.default`"

# 44c42789e6be4c9c9930e86ba87a3409
#: ../../howto/custom-model-fields.txt:207
msgid ":attr:`~django.db.models.Field.editable`"
msgstr ":attr:`~django.db.models.Field.editable`"

# e1a38cdddc034e67bb7349c49db69a90
#: ../../howto/custom-model-fields.txt:208
msgid ""
"``serialize``: If ``False``, the field will not be serialized when the model "
"is passed to Django's :doc:`serializers </topics/serialization>`. Defaults "
"to ``True``."
msgstr ""
"``serialize``: При ``False``, поле не будет сериализовано при передачи "
"модели в :doc:`сериализатор Django </topics/serialization>`. По умолчанию "
"``True``."

# 07708d78936d4fd88c2fef99fd801ef2
#: ../../howto/custom-model-fields.txt:211
msgid ":attr:`~django.db.models.Field.unique_for_date`"
msgstr ":attr:`~django.db.models.Field.unique_for_date`"

# ce785aab0c5b4caeb41ec24915805102
#: ../../howto/custom-model-fields.txt:212
msgid ":attr:`~django.db.models.Field.unique_for_month`"
msgstr ":attr:`~django.db.models.Field.unique_for_month`"

# c1b3801f44154635ac187f6d8211cff2
#: ../../howto/custom-model-fields.txt:213
msgid ":attr:`~django.db.models.Field.unique_for_year`"
msgstr ":attr:`~django.db.models.Field.unique_for_year`"

# 7475f439af5549cbbd3a491be4327114
#: ../../howto/custom-model-fields.txt:214
msgid ":attr:`~django.db.models.Field.choices`"
msgstr ":attr:`~django.db.models.Field.choices`"

# 4e611b44bb984267a5ff36afa056a5a0
#: ../../howto/custom-model-fields.txt:215
msgid ":attr:`~django.db.models.Field.help_text`"
msgstr ":attr:`~django.db.models.Field.help_text`"

# dcd40b7bd3d243fda9eacf342b63ddbe
#: ../../howto/custom-model-fields.txt:216
msgid ":attr:`~django.db.models.Field.db_column`"
msgstr ":attr:`~django.db.models.Field.db_column`"

# 60193b76ff7c4cd8a6f2690375374003
#: ../../howto/custom-model-fields.txt:217
msgid ""
":attr:`~django.db.models.Field.db_tablespace`: Only for index creation, if "
"the backend supports :doc:`tablespaces </topics/db/tablespaces>`. You can "
"usually ignore this option."
msgstr ""
":attr:`~django.db.models.Field.db_tablespace`: Используется только при "
"создании индекса, если база данных поддерживает :doc:`табличное пространство "
"</topics/db/tablespaces>`. В большинстве случаев вы можете проигнорировать "
"этот параметр."

# 7df1821fed754b31bf12d77f0a477630
#: ../../howto/custom-model-fields.txt:220
msgid ""
":attr:`~django.db.models.Field.auto_created`: ``True`` if the field was "
"automatically created, as for the :class:`~django.db.models.OneToOneField` "
"used by model inheritance. For advanced use only."
msgstr ""
":attr:`~django.db.models.Field.auto_created`: True, если поле создается "
"автоматически, например, используется полем  :class:`~django.db.models."
"OneToOneField`. Для опытных пользователей."

# 506f24cd21c441a3a3ada5bce901bc72
#: ../../howto/custom-model-fields.txt:224
msgid ""
"All of the options without an explanation in the above list have the same "
"meaning they do for normal Django fields. See the :doc:`field documentation "
"</ref/models/fields>` for examples and details."
msgstr ""
"Аргументы без описания аналогичны соответствующим аргументам стандартных "
"полей, смотрите :doc:`раздел о полях модели </ref/models/fields>` for "
"examples and details."

# 301de0041f354df38fe57fe7bfe9e8b5
#: ../../howto/custom-model-fields.txt:231
msgid "Field deconstruction"
msgstr "Деконструкция поля"

# 3a4f8cbcfc0d4ad59510d28364ba721c
#: ../../howto/custom-model-fields.txt:233
msgid ""
"The counterpoint to writing your ``__init__()`` method is writing the "
"``deconstruct()`` method. This method tells Django how to take an instance "
"of your new field and reduce it to a serialized form - in particular, what "
"arguments to pass to ``__init__()`` to re-create it."
msgstr ""
"Метод ``deconstruct()`` является дополнением к методу ``__init__()``. Этот "
"метод указывает Django как сериализировать экземпляр поля, а точнее -- какие "
"аргументы передать в ``__init__()`` чтобы воссоздать его."

# 6fb1f8d916e84fe0bce54a681b82e812
#: ../../howto/custom-model-fields.txt:238
msgid ""
"If you haven't added any extra options on top of the field you inherited "
"from, then there's no need to write a new ``deconstruct()`` method. If, "
"however, you're changing the arguments passed in ``__init__()`` (like we are "
"in ``HandField``), you'll need to supplement the values being passed."
msgstr ""
"Если вы не добавляли аргументы в дочерний класс встроенного поля, вам не "
"нужно переопределять метод ``deconstruct()``. Однако, если вы изменили "
"аргументы ``__init__()`` (как мы сделали это в поле ``HandField``), вам "
"необходимо добавить их."

# 83562f2b7d5347009fc9afadfd7c5821
#: ../../howto/custom-model-fields.txt:243
msgid ""
"The contract of ``deconstruct()`` is simple; it returns a tuple of four "
"items: the field's attribute name, the full import path of the field class, "
"the positional arguments (as a list), and the keyword arguments (as a dict). "
"Note this is different from the ``deconstruct()`` method :ref:`for custom "
"classes <custom-deconstruct-method>` which returns a tuple of three things."
msgstr ""
"Формат ответа ``deconstruct()`` простой. Он должен возвращать кортеж из "
"четырех элементов: имя атрибута поля, полный путь импорта класса поля, "
"позиционные аргументы (списком) и именованные аргументы (словарем). Обратите "
"внимание, это отличается от метода ``deconstruct()`` для :ref:`собственного "
"класса <custom-deconstruct-method>`, которые должен вернуть кортеж из трех "
"элементов."

# 50b9eb146f44425683ad9b042f76e3c8
#: ../../howto/custom-model-fields.txt:249
msgid ""
"As a custom field author, you don't need to care about the first two values; "
"the base ``Field`` class has all the code to work out the field's attribute "
"name and import path. You do, however, have to care about the positional and "
"keyword arguments, as these are likely the things you are changing."
msgstr ""
"Создавая свое поле, вам не стоит беспокоится о первых двух значениях, "
"базовый класс ``Field`` сам определит их. Вам необходимо указать позиционные "
"и именованные аргументы, скорее всего именно их вы и будете переопределять в "
"своем поле."

# ed3f47ea1f2349d38d8a431221b70425
#: ../../howto/custom-model-fields.txt:254
msgid ""
"For example, in our ``HandField`` class we're always forcibly setting "
"max_length in ``__init__()``. The ``deconstruct()`` method on the base "
"``Field`` class will see this and try to return it in the keyword arguments; "
"thus, we can drop it from the keyword arguments for readability::"
msgstr ""
"Например, в нашем классе ``HandField`` мы определяем ``max_length`` в "
"``__init__()``. Метод ``deconstruct()`` базового класса ``Field`` вернет его "
"в именованных аргументах. Но мы можем удалить его для читабельности::"

# 169ab452ae7244f5b2caf90ff45e19c1
#: ../../howto/custom-model-fields.txt:272
msgid ""
"If you add a new keyword argument, you need to write code to put its value "
"into ``kwargs`` yourself::"
msgstr ""
"Если вы добавили именованный аргумент, вам следует вернуть его в ``kwargs``::"

# 402cd9125c034853a3e5727b4b63e998
#: ../../howto/custom-model-fields.txt:291
msgid ""
"More complex examples are beyond the scope of this document, but remember - "
"for any configuration of your Field instance, ``deconstruct()`` must return "
"arguments that you can pass to ``__init__`` to reconstruct that state."
msgstr ""
"Более сложные примеры выходят за рамки этой документации, но помните - для "
"любой конфигурации поля, ``deconstruct()`` должен вернуть аргументы, которые "
"можно передать в ``__init__``, чтобы воссоздать экземпляр поля."

# 02ba493eedf5431da8e5795b79fde004
#: ../../howto/custom-model-fields.txt:295
msgid ""
"Pay extra attention if you set new default values for arguments in the "
"``Field`` superclass; you want to make sure they're always included, rather "
"than disappearing if they take on the old default value."
msgstr ""
"Обратите внимание на новые значения по умолчанию для аргументов ``Field``. "
"Вы захотите чтобы они сохранились, а не перезаписались старыми значениями по "
"умолчанию."

# 72c84b7f1ba747269636a2cc35eefe78
#: ../../howto/custom-model-fields.txt:299
msgid ""
"In addition, try to avoid returning values as positional arguments; where "
"possible, return values as keyword arguments for maximum future "
"compatibility. Of course, if you change the names of things more often than "
"their position in the constructor's argument list, you might prefer "
"positional, but bear in mind that people will be reconstructing your field "
"from the serialized version for quite a while (possibly years), depending "
"how long your migrations live for."
msgstr ""
"Также, старайтесь не возвращать позиционные аргументы, при возможности "
"используйте именованные для максимальной совместимости в будущем. Конечно, "
"если вы меняете названия аргументов чаще, чем их порядок, вам лучше "
"использовать позиционные аргументы. Но не забываете, что люди будут "
"воссоздавать ваше поле из сериализованного состояния в течении достаточно "
"долгого периода (возможно годами), в зависимости от того, как долго будут "
"существовать миграции."

# afd85743fbc745c691549a2478ae5015
#: ../../howto/custom-model-fields.txt:306
msgid ""
"You can see the results of deconstruction by looking in migrations that "
"include the field, and you can test deconstruction in unit tests by just "
"deconstructing and reconstructing the field::"
msgstr ""
"Вы можете посмотреть результат деконструкции в миграции, которая включает "
"поле. Вы можете проверить деконструкцию в тестах просто воссоздавая поле:"

# 1399371549a64822a0c17804b5b6a1e7
#: ../../howto/custom-model-fields.txt:315
msgid "Changing a custom field's base class"
msgstr "Изменение базового класса собственного поля"

#: ../../howto/custom-model-fields.txt:317
msgid ""
"You can't change the base class of a custom field because Django won't "
"detect the change and make a migration for it. For example, if you start "
"with::"
msgstr ""
"Вы не можете изменить базовый класс собственного поля т.к. Django не сможет "
"определить эти изменения и не создаст миграцию. Например, у вас было поле::"

#: ../../howto/custom-model-fields.txt:323
msgid ""
"and then decide that you want to use ``TextField`` instead, you can't change "
"the subclass like this::"
msgstr ""
"затем вы решили использовать ``TextField``, вы не можете просто изменить "
"класс::"

#: ../../howto/custom-model-fields.txt:329
msgid ""
"Instead, you must create a new custom field class and update your models to "
"reference it::"
msgstr ""
"Вам следует создать новый класс поля и использовать его в вашей модели::"

#: ../../howto/custom-model-fields.txt:338
msgid ""
"As discussed in :ref:`removing fields <migrations-removing-model-fields>`, "
"you must retain the original ``CustomCharField`` class as long as you have "
"migrations that reference it."
msgstr ""
"Как уже упоминалось об :ref:`удалении полей <migrations-removing-model-"
"fields>`, вы должны хранить начальный класс ``CustomCharField`` пока проект "
"содержит миграции, которые ссылаются на этот класс."

# a6d906ba2d50431ead5827cabd984ce1
#: ../../howto/custom-model-fields.txt:343
msgid "Documenting your custom field"
msgstr "Документирование собственного поля"

# d2981188b931450e8b0bc810eaeeda7b
#: ../../howto/custom-model-fields.txt:345
msgid ""
"As always, you should document your field type, so users will know what it "
"is. In addition to providing a docstring for it, which is useful for "
"developers, you can also allow users of the admin app to see a short "
"description of the field type via the :doc:`django.contrib.admindocs </ref/"
"contrib/admin/admindocs>` application. To do this simply provide descriptive "
"text in a :attr:`~Field.description` class attribute of your custom field. "
"In the above example, the description displayed by the ``admindocs`` "
"application for a ``HandField`` will be 'A hand of cards (bridge style)'."
msgstr ""
"Конечно же вам необходимо задокументировать ваше поле, чтобы пользователи "
"знали как его использовать. В дополнение к docstring, который удобен для "
"разработчиков, вы можете предоставить описание поля, которое будет "
"отображаться в разделе документации в интерфейсе администратора, созданном "
"с :doc:`django.contrib.admindocs </ref/contrib/admin/admindocs>`. Для этого "
"укажите описание в атрибуте :attr:`~Field.description` класса поля. В нашем "
"примере описание поля ``HandField`` в приложении ``admindocs`` будет - 'A "
"hand of cards (bridge style)'."

# e6b87c75fd95402d8838de29a379cddd
#: ../../howto/custom-model-fields.txt:354
msgid ""
"In the :mod:`django.contrib.admindocs` display, the field description is "
"interpolated with ``field.__dict__`` which allows the description to "
"incorporate arguments of the field. For example, the description for :class:"
"`~django.db.models.CharField` is::"
msgstr ""
"На страницах :mod:`django.contrib.admindocs` описание поля включает ``field."
"__dict__``, что позволяет включить описание аргументов. Например, описание :"
"class:`~django.db.models.CharField` выглядит следующим образом::"

# 46ca5032629e464d9326ff01a97edd02
#: ../../howto/custom-model-fields.txt:362
msgid "Useful methods"
msgstr "Полезные методы"

# 427d3fabea8645bc87646e6b7cce2659
#: ../../howto/custom-model-fields.txt:364
msgid ""
"Once you've created your :class:`~django.db.models.Field` subclass, you "
"might consider overriding a few standard methods, depending on your field's "
"behavior. The list of methods below is in approximately decreasing order of "
"importance, so start from the top."
msgstr ""
"После того как вы создали свой подкласс :class:`~django.db.models.Field`, "
"можно переходить к переопределению методов, которые определяют поведение "
"вашего поля. Методы описанные ниже идут в порядке убывания важности."

# 661e0b6c078f4db39535c2d48d48fe9d
#: ../../howto/custom-model-fields.txt:372
msgid "Custom database types"
msgstr "Типы полей базы данных"

# a79545d83fa941b5a944b4b34c0ac782
#: ../../howto/custom-model-fields.txt:374
msgid ""
"Say you've created a PostgreSQL custom type called ``mytype``. You can "
"subclass ``Field`` and implement the :meth:`~Field.db_type` method, like so::"
msgstr ""
"Предположим вы создали собственный тип поля для PostgreSQL - ``mytype``. Вы "
"можете использовать его в Django, унаследовав ``Field`` и добавив следующий "
"метод :meth:`~Field.db_type`::"

# bc30994495ae4f249496156af1b9feb7
#: ../../howto/custom-model-fields.txt:383
msgid ""
"Once you have ``MytypeField``, you can use it in any model, just like any "
"other ``Field`` type::"
msgstr ""
"Создав ``MytypeField`` вы можете использовать его в моделях так же, как и "
"другие подтипы ``Field``::"

# 25b06f62895f45bc9ba30b1e33e073d7
#: ../../howto/custom-model-fields.txt:390
msgid ""
"If you aim to build a database-agnostic application, you should account for "
"differences in database column types. For example, the date/time column type "
"in PostgreSQL is called ``timestamp``, while the same column in MySQL is "
"called ``datetime``. The simplest way to handle this in a :meth:`~Field."
"db_type` method is to check the ``connection.settings_dict['ENGINE']`` "
"attribute."
msgstr ""
"Если вы создаете приложение независимое от используемой базы данных, "
"учитывайте, что разные базы данных используют различные типа полей. "
"Например, поле даты/времени в PostgreSQL называется ``timestamp``, а в MySQL "
"-- ``datetime``. Самый простой способ: проверять значение `connection."
"settings_dict['ENGINE']`` в методе :meth:`~Field.db_type`."

# 8aa51dada69c46d69cb5a430450ca4f8
# 23f1c9910512473e852f8cd1d6ab5b98
# a5f20ed046d34070bee573fe53500653
# 497f47a638de4e2395c3e37ff9210a9a
#: ../../howto/custom-model-fields.txt:396
#: ../../howto/custom-model-fields.txt:544
#: ../../howto/custom-model-fields.txt:655
msgid "For example::"
msgstr "Например::"

# 68182603cd4b47659e5b92c2e3cd09be
#: ../../howto/custom-model-fields.txt:405
msgid ""
"The :meth:`~Field.db_type` and :meth:`~Field.rel_db_type` methods are called "
"by Django when the framework constructs the ``CREATE TABLE`` statements for "
"your application -- that is, when you first create your tables. The methods "
"are also called when constructing a ``WHERE`` clause that includes the model "
"field -- that is, when you retrieve data using QuerySet methods like "
"``get()``, ``filter()``, and ``exclude()`` and have the model field as an "
"argument. They are not called at any other time, so it can afford to execute "
"slightly complex code, such as the ``connection.settings_dict`` check in the "
"above example."
msgstr ""
"Методы :meth:`~Field.db_type` и :meth:`~Field.rel_db_type` используются "
"Django при создании ``CREATE TABLE`` запросов -- когда вы создаете таблицы в "
"базе данных для приложения. Также при создании условий в ``WHERE``, которые "
"используют поле -- это когда вы используете методы QuerySet для получения "
"данных, такие как ``get()``, ``filter()`` или ``exclude()``, и используете "
"ваше поле в качестве аргумента. Больше нигде этот метод не используется, вы "
"можете использовать достаточно сложный код, как проверка ``connection."
"settings_dict`` в примере выше."

# e51328f1b23c4a03b2f85ab47aa36c6e
#: ../../howto/custom-model-fields.txt:414
msgid ""
"Some database column types accept parameters, such as ``CHAR(25)``, where "
"the parameter ``25`` represents the maximum column length. In cases like "
"these, it's more flexible if the parameter is specified in the model rather "
"than being hard-coded in the ``db_type()`` method. For example, it wouldn't "
"make much sense to have a ``CharMaxlength25Field``, shown here::"
msgstr ""
"Некоторые типы полей принимают параметры, например ``CHAR(25)``, где ``25`` "
"указывают максимальный размер колонки. В этом случае лучше указывать "
"параметр в модели, чем хардкодить в методе ``db_type()``. Например, глупо "
"создавать поле ``CharMaxlength25Field``::"

# 5b4ac47ef08a4dcb98ee538b4cb3a2eb
#: ../../howto/custom-model-fields.txt:430
msgid ""
"The better way of doing this would be to make the parameter specifiable at "
"run time -- i.e., when the class is instantiated. To do that, just implement "
"``Field.__init__()``, like so::"
msgstr ""
"Лучше позволить указывать параметр при определении поля -- то есть при "
"создании класса модели. Для этого переопределите метод ``Field.__init__()``::"

# 9b74368a917448a18e3eeed21c4e2c60
#: ../../howto/custom-model-fields.txt:448
msgid ""
"Finally, if your column requires truly complex SQL setup, return ``None`` "
"from :meth:`.db_type`. This will cause Django's SQL creation code to skip "
"over this field. You are then responsible for creating the column in the "
"right table in some other way, of course, but this gives you a way to tell "
"Django to get out of the way."
msgstr ""
"В конце концов, если поле требует действительно сложный SQL код при "
"создании, верните ``None`` в методе :meth:`.db_type`. В этом случае Django "
"пропустит создание этого поля в базе данных. Вам придется создать поле каким "
"либо другим способом."

#: ../../howto/custom-model-fields.txt:454
msgid ""
"The :meth:`~Field.rel_db_type` method is called by fields such as "
"``ForeignKey`` and ``OneToOneField`` that point to another field to "
"determine their database column data types. For example, if you have an "
"``UnsignedAutoField``, you also need the foreign keys that point to that "
"field to use the same data type::"
msgstr ""
"Метод :meth:`~Field.rel_db_type` вызывается полями ``ForeignKey`` и "
"``OneToOneField``, которые указывают на другие поля, чтобы узнать тип поля в "
"базе данных. Например, у вас есть поле ``UnsignedAutoField``, и вам "
"необходимо, чтобы поле, которое ссылаются на ваше поле, использовали такой "
"же тип поля::"

# 392329bf4bf647d1a5766d2bb15082ae
#: ../../howto/custom-model-fields.txt:470
msgid "Converting values to Python objects"
msgstr "Преобразование значений базы данных в объекты Python"

# 62902371d5c047df8cb06b4caff4d195
#: ../../howto/custom-model-fields.txt:472
msgid ""
"If your custom :class:`~Field` class deals with data structures that are "
"more complex than strings, dates, integers, or floats, then you may need to "
"override :meth:`~Field.from_db_value` and :meth:`~Field.to_python`."
msgstr ""
"Если ваш подкласс :class:`~Field` работает со структурами более сложными, "
"чем строка, дата и число, вам следует переопределить :meth:`~Field."
"from_db_value` и :meth:`~Field.to_python`."

#: ../../howto/custom-model-fields.txt:476
msgid ""
"If present for the field subclass, ``from_db_value()`` will be called in all "
"circumstances when the data is loaded from the database, including in "
"aggregates and :meth:`~django.db.models.query.QuerySet.values` calls."
msgstr ""
"Если поле содержит метод ``from_db_value()``, он будет вызываться при всех "
"операциях загрузки данных с базы данных, включая агрегации и вызовы :meth:"
"`~django.db.models.query.QuerySet.values`."

#: ../../howto/custom-model-fields.txt:480
msgid ""
"``to_python()`` is called by deserialization and during the :meth:`~django."
"db.models.Model.clean` method used from forms."
msgstr ""
"``to_python()`` вызывается при десериализации и при вызове метода :meth:"
"`~django.db.models.Model.clean` в формах."

#: ../../howto/custom-model-fields.txt:483
msgid ""
"As a general rule, ``to_python()`` should deal gracefully with any of the "
"following arguments:"
msgstr ""
"Метод ``to_python()`` должен корректно обрабатывать следующие типы значения:"

# fb1688a134a8429186ab2f5d6e19c39b
#: ../../howto/custom-model-fields.txt:486
msgid ""
"An instance of the correct type (e.g., ``Hand`` in our ongoing example)."
msgstr "Объект нужного типа (например, ``Hand`` в нашем примере)."

#: ../../howto/custom-model-fields.txt:488
msgid "A string"
msgstr "Строка"

#: ../../howto/custom-model-fields.txt:490
msgid "``None`` (if the field allows ``null=True``)"
msgstr "``None`` (если поле содержит ``null=True``)"

# 128ac3c4ef9f4c509e5a97db8a6580dd
#: ../../howto/custom-model-fields.txt:492
msgid ""
"In our ``HandField`` class, we're storing the data as a VARCHAR field in the "
"database, so we need to be able to process strings and ``None`` in the "
"``from_db_value()``. In ``to_python()``, we need to also handle ``Hand`` "
"instances::"
msgstr ""
"В нашем ``HandField`` мы сохраняем значение в поле VARCHAR, и в "
"``from_db_value()`` должны обрабатывать строки и ``None``. В ``to_python()`` "
"также объекты ``Hand``::"

# 64eb9981da4d496899a39112fca3c038
#: ../../howto/custom-model-fields.txt:529
msgid ""
"Notice that we always return a ``Hand`` instance from these methods. That's "
"the Python object type we want to store in the model's attribute."
msgstr ""
"Помните, что мы всегда возвращаем объект ``Hand`` из этого метода. Это "
"объект Python, который мы хотим сохранить в модели."

# 64eb9981da4d496899a39112fca3c038
#: ../../howto/custom-model-fields.txt:532
msgid ""
"For ``to_python()``, if anything goes wrong during value conversion, you "
"should raise a :exc:`~django.core.exceptions.ValidationError` exception."
msgstr ""
"Если ``to_python()`` не может выполнить преобразование значения, вызовите "
"исключение :exc:`~django.core.exceptions.ValidationError`."

# ff46ada6ed6e44189c67f6468a4b74a2
#: ../../howto/custom-model-fields.txt:538
msgid "Converting Python objects to query values"
msgstr "Преобразование объектов Python в значения в запросе"

# 3e12b0eb672d4deb9a6486256105458d
#: ../../howto/custom-model-fields.txt:540
msgid ""
"Since using a database requires conversion in both ways, if you override :"
"meth:`~Field.to_python` you also have to override :meth:`~Field."
"get_prep_value` to convert Python objects back to query values."
msgstr ""
"Т.к. использование базы данных требует преобразования значения в оба "
"ннаправления, если вы переопределили :meth:`~Field.to_python` ва следует "
"переопределить и :meth:`~Field.get_prep_value` чтобы преобразовать объект "
"Python обратно в значение для запроса."

# a397183f2a3846c9a337cb553a673b4b
#: ../../howto/custom-model-fields.txt:555
msgid ""
"If your custom field uses the ``CHAR``, ``VARCHAR`` or ``TEXT`` types for "
"MySQL, you must make sure that :meth:`.get_prep_value` always returns a "
"string type. MySQL performs flexible and unexpected matching when a query is "
"performed on these types and the provided value is an integer, which can "
"cause queries to include unexpected objects in their results. This problem "
"cannot occur if you always return a string type from :meth:`.get_prep_value`."
msgstr ""
"Если ваше поле использует типы ``CHAR``, ``VARCHAR`` или ``TEXT`` MySQL, "
"метод :meth:`.get_prep_value` всегда должен возвращать строку. MySQL "
"выполняет довольно непредсказуемое сравнение типов, если передать число, что "
"может привести к неожиданными результатам запроса. Этой проблемы можно "
"избежать возвращая всегда строку из :meth:`.get_prep_value`."

# 8ba0bfd71aec49d1b1daf418fc42048c
#: ../../howto/custom-model-fields.txt:566
msgid "Converting query values to database values"
msgstr "Преобразование значения из запроса в значение базы данных"

# 6b5e19155be44592afe363746b5b5700
#: ../../howto/custom-model-fields.txt:568
msgid ""
"Some data types (for example, dates) need to be in a specific format before "
"they can be used by a database backend. :meth:`~Field.get_db_prep_value` is "
"the method where those conversions should be made. The specific connection "
"that will be used for the query is passed as the ``connection`` parameter. "
"This allows you to use backend-specific conversion logic if it is required."
msgstr ""
"Некоторые типы данных (например, даты) должны быть в определенном формате "
"при передаче в бэкенд базы данных. Эти преобразования должны быть выполнены "
"в :meth:`~Field.get_db_prep_value`. Объект подключения к базе данных "
"передается в аргументе ``connection``. Это позволяет выполнить "
"преобразование, которое зависит от используемой базы данных."

# 87a8b8ad7bef425d894ee56163694adf
#: ../../howto/custom-model-fields.txt:575
msgid ""
"For example, Django uses the following method for its :class:`BinaryField`::"
msgstr "Например, Django использует следующий метод для :class:`BinaryField`::"

# b52a3550e07745939e771fb04d1942a4
#: ../../howto/custom-model-fields.txt:584
msgid ""
"In case your custom field needs a special conversion when being saved that "
"is not the same as the conversion used for normal query parameters, you can "
"override :meth:`~Field.get_db_prep_save`."
msgstr ""
"Если ваше поле требует дополнительного преобразования данных при сохранении, "
"переопределите для этого метод :meth:`~Field.get_db_prep_save`."

# db2735ee6c5e49e0ad629c29909e6e24
#: ../../howto/custom-model-fields.txt:591
msgid "Preprocessing values before saving"
msgstr "Обработка данных перед сохранением"

# 61dfdcaabb7c4ef1a5660ccb988f3ea5
#: ../../howto/custom-model-fields.txt:593
msgid ""
"If you want to preprocess the value just before saving, you can use :meth:"
"`~Field.pre_save`. For example, Django's :class:`~django.db.models."
"DateTimeField` uses this method to set the attribute correctly in the case "
"of :attr:`~django.db.models.DateField.auto_now` or :attr:`~django.db.models."
"DateField.auto_now_add`."
msgstr ""
"Вы должны переопределить метод :meth:`~Field.pre_save`, если хотите изменить "
"значение перед сохранением. Например, поле :class:`~django.db.models."
"DateTimeField` использует этот метод для установки значения при :attr:"
"`~django.db.models.DateField.auto_now` или :attr:`~django.db.models."
"DateField.auto_now_add`."

# 8f60b55bd14d4601aa58894eab66f940
#: ../../howto/custom-model-fields.txt:599
msgid ""
"If you do override this method, you must return the value of the attribute "
"at the end. You should also update the model's attribute if you make any "
"changes to the value so that code holding references to the model will "
"always see the correct value."
msgstr ""
"Если вы переопределяете этот метод, необходимо вернуть значение атрибута в "
"конце. Вы также должны обновить атрибут модели, если изменяли значение."

# df6f403d3b3a4ee6b73582b24f05ebe8
#: ../../howto/custom-model-fields.txt:607
msgid "Specifying the form field for a model field"
msgstr "Определение поля формы для поля модели"

# 1f89646571c447e99da83665a8fd1116
#: ../../howto/custom-model-fields.txt:609
msgid ""
"To customize the form field used by :class:`~django.forms.ModelForm`, you "
"can override :meth:`~Field.formfield`."
msgstr ""
"Чтобы переопределить поле формы, которое будет использоваться :class:"
"`~django.forms.ModelForm`, вы можете переопределить :meth:`~Field.formfield`."

# 8639b9a27a89445686fb692f239158c8
#: ../../howto/custom-model-fields.txt:612
msgid ""
"The form field class can be specified via the ``form_class`` and "
"``choices_form_class`` arguments; the latter is used if the field has "
"choices specified, the former otherwise. If these arguments are not "
"provided, :class:`~django.forms.CharField` or :class:`~django.forms."
"TypedChoiceField` will be used."
msgstr ""
"Класс поля формы можно указать аргументами ``form_class`` и "
"``choices_form_class``(используется, если для поля указан список возможных "
"значений). Если аргументы не указаны, будут использоваться :class:`~django."
"forms.CharField` или :class:`~django.forms.TypedChoiceField`."

# bd3cdf42948e4dbdbbe1e3993458618b
#: ../../howto/custom-model-fields.txt:618
msgid ""
"All of the ``kwargs`` dictionary is passed directly to the form field's "
"``__init__()`` method. Normally, all you need to do is set up a good default "
"for the ``form_class`` (and maybe ``choices_form_class``) argument and then "
"delegate further handling to the parent class. This might require you to "
"write a custom form field (and even a form widget). See the :doc:`forms "
"documentation </topics/forms/index>` for information about this."
msgstr ""
"Словарь ``kwargs`` передается в конструктор ``__init__()`` поля формы. "
"Скорее всего вам понадобится определить необходимые аргументы для "
"``form_class``(и возможно ``choices_form_class``) и передать дальнейшую "
"обработку в метод родительского класса. Возможно вам понадобиться создать "
"собственный тип поля формы (и возможно даже свой виджет). Смотрите :doc:"
"`раздел о формах </topics/forms/index>`."

# 4a4a40129fbb4ab39c78fb257d6e660f
#: ../../howto/custom-model-fields.txt:625
msgid ""
"Continuing our ongoing example, we can write the :meth:`~Field.formfield` "
"method as::"
msgstr ""
"Продолжая наш пример, мы можем создать следующий метод :meth:`~Field."
"formfield`::"

# 586fbac7e61043c2b220931533b4f206
#: ../../howto/custom-model-fields.txt:638
msgid ""
"This assumes we've imported a ``MyFormField`` field class (which has its own "
"default widget). This document doesn't cover the details of writing custom "
"form fields."
msgstr ""
"Подразумевается, что мы уже импортировали класс поля ``MyFormField`` "
"(который содержит свой собственный виджет). Этот раздел не описывает "
"создание собственного поля формы."

# e97eeb36bb364cb18f852c1417a7533b
#: ../../howto/custom-model-fields.txt:648
msgid "Emulating built-in field types"
msgstr "Эмуляция встроенных полей"

# 8c90c86b7b9445cc8086c4d54bb83876
#: ../../howto/custom-model-fields.txt:650
msgid ""
"If you have created a :meth:`.db_type` method, you don't need to worry "
"about :meth:`.get_internal_type` -- it won't be used much. Sometimes, "
"though, your database storage is similar in type to some other field, so you "
"can use that other field's logic to create the right column."
msgstr ""
"Если вы определили метод :meth:`.db_type`, нет необходимости использовать :"
"meth:`.get_internal_type` -- он не будет использоваться. Иногда одни типы "
"полей работают так же, как и другие на уровне базы данных, в таких случаях "
"вы можете использовать этот метод."

# bf17777d08b447969f5bb8041619ff3e
#: ../../howto/custom-model-fields.txt:663
msgid ""
"No matter which database backend we are using, this will mean that :djadmin:"
"`migrate` and other SQL commands create the right column type for storing a "
"string."
msgstr ""
"Без разницы какую базу данных мы используем, :djadmin:`migrate` и другие SQL "
"выберут правильный тип поля в базе данных."

# 654cbaa57af549aab02f5989e3009a7f
#: ../../howto/custom-model-fields.txt:667
msgid ""
"If :meth:`.get_internal_type` returns a string that is not known to Django "
"for the database backend you are using -- that is, it doesn't appear in "
"``django.db.backends.<db_name>.base.DatabaseWrapper.data_types`` -- the "
"string will still be used by the serializer, but the default :meth:`~Field."
"db_type` method will return ``None``. See the documentation of :meth:`~Field."
"db_type` for reasons why this might be useful. Putting a descriptive string "
"in as the type of the field for the serializer is a useful idea if you're "
"ever going to be using the serializer output in some other place, outside of "
"Django."
msgstr ""
"Если :meth:`.get_internal_type` возвращает строку, которая неизвестна "
"Django  -- то есть отсутствует в ``django.db.backends.<db_name>.base."
"DatabaseWrapper.data_types`` -- она все равно будет использована "
"сериализатором, но метод :meth:`~Field.db_type` по умолчанию вернет "
"``None``. Смотрите описание :meth:`~Field.db_type` чтобы понять, в каких "
"случаях это может быть полезно. Возвращение строки, описывающей поле для "
"сериализатора, может быть полезным, если вы собираетесь использовать "
"результат сериализации не только в Django."

# f2cdcc2f9bf8422ea4541dd7f27a9f9f
#: ../../howto/custom-model-fields.txt:679
msgid "Converting field data for serialization"
msgstr "Преобразование значения поля для сериалайзера"

# 5523584c5f2840c59822800acda92cb5
#: ../../howto/custom-model-fields.txt:681
#, fuzzy
msgid ""
"To customize how the values are serialized by a serializer, you can "
"override :meth:`~Field.value_to_string`. Using :meth:`~Field."
"value_from_object` is the best way to get the field's value prior to "
"serialization. For example, since ``HandField`` uses strings for its data "
"storage anyway, we can reuse some existing conversion code::"
msgstr ""
"Чтобы указать как значения сериализуются сериализатором, переопределите "
"метод :meth:`~Field.value_to_string`. Вызов ``value_from_object()`` -- "
"лучший способ получить значение для сериализатора. Например, так как "
"``HandField`` использует строку для хранения в базе данных, мы можем "
"использовать существующий код::"

# f25603485907460f8a3346be9af89499
#: ../../howto/custom-model-fields.txt:695
msgid "Some general advice"
msgstr "Несколько советов"

# 987da81e73dd455ba9af1e395bca31f8
#: ../../howto/custom-model-fields.txt:697
msgid ""
"Writing a custom field can be a tricky process, particularly if you're doing "
"complex conversions between your Python types and your database and "
"serialization formats. Here are a couple of tips to make things go more "
"smoothly:"
msgstr ""
"Создание собственного поля может быть непростой задачей, особенно при "
"сложном преобразовании данных в объекты Python, значения для базы данных и "
"сериализатора. Вот несколько советов как упросить эту задачу:"

# c52acd8bee464a568e366a7941baa69d
#: ../../howto/custom-model-fields.txt:702
msgid ""
"Look at the existing Django fields (in :file:`django/db/models/fields/"
"__init__.py`) for inspiration. Try to find a field that's similar to what "
"you want and extend it a little bit, instead of creating an entirely new "
"field from scratch."
msgstr ""
"Посмотрите на существующие поля в Django (в :file:`django/db/models/fields/"
"__init__.py`). Постарайтесь найти поле, похожее на то, что вам необходимо, "
"это лучше, чем создавать свое поле с нуля."

# 5a6eb4ff2b524ae9b60578f7c033bfcf
#: ../../howto/custom-model-fields.txt:707
msgid ""
"Put a ``__str__()`` method on the class you're wrapping up as a field. There "
"are a lot of places where the default behavior of the field code is to call "
"``str()`` on the value. (In our examples in this document, ``value`` would "
"be a ``Hand`` instance, not a ``HandField``). So if your ``__str__()`` "
"method automatically converts to the string form of your Python object, you "
"can save yourself a lot of work."
msgstr ""
"Добавьте метод ``__str__()`` в класс, который вы используете для значений "
"вашего поля. Во многих случаях используется функция ``str()`` при обработке "
"значений. (В нашем примере, ``value`` будет объект ``Hand``, не "
"``HandField``). Если метод ``__str__()`` преобразует объект Python в строку, "
"это сохранит вам много времени."

# 2cd137f2faa6491ab1134fc3a8cc1016
#: ../../howto/custom-model-fields.txt:715
msgid "Writing a ``FileField`` subclass"
msgstr "Создание подкласса ``FileField``"

# 905bed0faa17403789212baff5fd99c4
#: ../../howto/custom-model-fields.txt:717
msgid ""
"In addition to the above methods, fields that deal with files have a few "
"other special requirements which must be taken into account. The majority of "
"the mechanics provided by ``FileField``, such as controlling database "
"storage and retrieval, can remain unchanged, leaving subclasses to deal with "
"the challenge of supporting a particular type of file."
msgstr ""
"В дополнение к вышеописанным методам, поля, которые работают с файлами, "
"требуют дополнительной работы. Основной функционал ``FileField``, такой как "
"сохранение и получения данных в БД, можно оставить без изменений, определив "
"лишь операции, необходимые для работы с различными типами файлов."

# 2807550b394243708642034b5c5355fc
#: ../../howto/custom-model-fields.txt:723
msgid ""
"Django provides a ``File`` class, which is used as a proxy to the file's "
"contents and operations. This can be subclassed to customize how the file is "
"accessed, and what methods are available. It lives at ``django.db.models."
"fields.files``, and its default behavior is explained in the :doc:`file "
"documentation </ref/files/file>`."
msgstr ""
"Django предоставляет класс ``File``, который используется как прокси при "
"работе с файлами. Можно унаследоваться от него и переопределить работу с "
"файлом. Он находится в ``django.db.models.fields.files`` и описан в :doc:"
"`разделе о файлах </ref/files/file>`."

# da5e6b64339a4a38afeed856ab69bd5f
#: ../../howto/custom-model-fields.txt:729
msgid ""
"Once a subclass of ``File`` is created, the new ``FileField`` subclass must "
"be told to use it. To do so, simply assign the new ``File`` subclass to the "
"special ``attr_class`` attribute of the ``FileField`` subclass."
msgstr ""
"После создания подкласса ``File`` новый подкласс ``FileField`` может "
"использовать его. Просто укажите подкласс ``File`` в атрибуте ``attr_class`` "
"подкласса ``FileField``."

# 16bf8d57b75e48e99a87bb7a21dd210d
#: ../../howto/custom-model-fields.txt:734
msgid "A few suggestions"
msgstr "Несколько советов"

# 8c76cdf3f4014c608e2fe4b205ff2e01
#: ../../howto/custom-model-fields.txt:736
msgid ""
"In addition to the above details, there are a few guidelines which can "
"greatly improve the efficiency and readability of the field's code."
msgstr ""
"В дополнение ко всему сказанному выше, вот несколько советов, которые "
"помогут улучшить ваш код."

# b5e0923f41364300a290ef25ad78fb3b
#: ../../howto/custom-model-fields.txt:739
msgid ""
"The source for Django's own ``ImageField`` (in ``django/db/models/fields/"
"files.py``) is a great example of how to subclass ``FileField`` to support a "
"particular type of file, as it incorporates all of the techniques described "
"above."
msgstr ""
"Пример встроенного в Django поля ``ImageField`` (в ``django/db/models/fields/"
"files.py``) - хороший пример переопределения ``FileField``, изучите его."

# 85b2b8f7c50e4ab59e349c9fbc0adac7
#: ../../howto/custom-model-fields.txt:744
msgid ""
"Cache file attributes wherever possible. Since files may be stored in remote "
"storage systems, retrieving them may cost extra time, or even money, that "
"isn't always necessary. Once a file is retrieved to obtain some data about "
"its content, cache as much of that data as possible to reduce the number of "
"times the file must be retrieved on subsequent calls for that information."
msgstr ""
"Кэшируйте объект файла при любой возможности. Так как файлы могут хранится "
"во внешнем хранилище, получение их может потребовать дополнительного времени "
"и даже денег. После получения файла закэшируйте как можно большую его часть, "
"чтобы сократить количество операций необходимых для его последующего чтения."

#~ msgid ""
#~ "Historically, Django provided a metaclass called ``SubfieldBase`` which "
#~ "always called :meth:`~Field.to_python` on assignment. This did not play "
#~ "nicely with custom database transformations, aggregation, or values "
#~ "queries, so it has been replaced with :meth:`~Field.from_db_value`."
#~ msgstr ""
#~ "Исторически Django предоставляет метакласс ``SubfieldBase``, который "
#~ "вызывает :meth:`~Field.to_python` при каждом указании значения поля. "
#~ "Такой подход не очень хорошо работал с преобразованиями на уровне базы "
#~ "данных, агрегациями, или получением данных через :meth:`~django.db.models."
#~ "query.QuerySet.values`, и был заменен методом :meth:`~Field."
#~ "from_db_value`."

# cea3a2a4ece84401aefd943d92962dc3
#~ msgid "Preparing values for use in database lookups"
#~ msgstr "Подготовка значений при поиске в базе данных"

# c0a7147674d344e4ab9a847e81523ee8
#~ msgid ""
#~ "As with value conversions, preparing a value for database lookups is a "
#~ "two phase process."
#~ msgstr ""
#~ "Как и преобразование значения поля, преобразование значения для "
#~ "поиска(WHERE) в базе данных выполняется в две фазы."

# 35cdbdd1a70f4d5293fa850a4366b2b3
#~ msgid ""
#~ ":meth:`.get_prep_lookup` performs the first phase of lookup preparation: "
#~ "type conversion and data validation."
#~ msgstr ""
#~ ":meth:`.get_prep_lookup` выполняет первую фазу подготовки параметров "
#~ "фильтрации: преобразование типа и проверку данных."

# 043b1310ceed441e8080752cc141b753
#~ msgid ""
#~ "Prepares the ``value`` for passing to the database when used in a lookup "
#~ "(a ``WHERE`` constraint in SQL). The ``lookup_type`` parameter will be "
#~ "one of the valid Django filter lookups: ``exact``, ``iexact``, "
#~ "``contains``, ``icontains``, ``gt``, ``gte``, ``lt``, ``lte``, ``in``, "
#~ "``startswith``, ``istartswith``, ``endswith``, ``iendswith``, ``range``, "
#~ "``year``, ``month``, ``day``, ``isnull``, ``search``, ``regex``, and "
#~ "``iregex``."
#~ msgstr ""
#~ "Подготавливает ``value`` для передачи в фильтр запроса (``WHERE`` в SQL). "
#~ "``lookup_type`` содержит один из фильтров Django: ``exact``, ``iexact``, "
#~ "``contains``, ``icontains``, ``gt``, ``gte``, ``lt``, ``lte``, ``in``, "
#~ "``startswith``, ``istartswith``, ``endswith``, ``iendswith``, ``range``, "
#~ "``year``, ``month``, ``day``, ``isnull``, ``search``, ``regex`` и "
#~ "``iregex``."

# 9c8467ff816949b9a35c9fb4e88d1e7e
#~ msgid ""
#~ "If you are using :doc:`custom lookups </howto/custom-lookups>`, the "
#~ "``lookup_type`` can be any ``lookup_name`` used by the project's custom "
#~ "lookups."
#~ msgstr ""
#~ "Если вы используете :doc:`собственные фильтры </howto/custom-lookups>`, "
#~ "``lookup_type`` может быть любой ``lookup_name``, который используется "
#~ "дополнительными фильтрами."

# a8fe7eae9a934a55a0b179d4dd85573f
#~ msgid ""
#~ "Your method must be prepared to handle all of these ``lookup_type`` "
#~ "values and should raise either a ``ValueError`` if the ``value`` is of "
#~ "the wrong sort (a list when you were expecting an object, for example) or "
#~ "a ``TypeError`` if your field does not support that type of lookup. For "
#~ "many fields, you can get by with handling the lookup types that need "
#~ "special handling for your field and pass the rest to the :meth:`~Field."
#~ "get_db_prep_lookup` method of the parent class."
#~ msgstr ""
#~ "Ваш метод должен учитывать все возможные значения ``lookup_type`` и "
#~ "вызвать исключение ``ValueError``, если ``value`` содержит неверное "
#~ "значение (например, список, в то время, когда вы ожидаете объект) или "
#~ "``TypeError``, если ваше поле не поддерживает данный тип фильтра. Для "
#~ "большинства полей вы можете добавить обработку определенных фильтров, для "
#~ "всех остальных использовать метод :meth:`~Field.get_db_prep_lookup` "
#~ "родительского класса."

# 1a5ef9b9277f47b8a5fbf0848fd3f895
#~ msgid ""
#~ "If you needed to implement :meth:`.get_db_prep_save`, you will usually "
#~ "need to implement :meth:`.get_prep_lookup`. If you don't, :meth:`."
#~ "get_prep_value` will be called by the default implementation, to manage "
#~ "``exact``, ``gt``, ``gte``, ``lt``, ``lte``, ``in`` and ``range`` lookups."
#~ msgstr ""
#~ "Если вы переопределяете :meth:`.get_db_prep_save`, скорее всего вам "
#~ "необходимо переопределить и метод :meth:`.get_prep_lookup`. Если этого не "
#~ "сделать, будет использовать реализация :meth:`.get_prep_value` по "
#~ "умолчанию для обработки фильтров ``exact``, ``gt``, ``gte``, ``lt``, "
#~ "``lte``, ``in`` и ``range``."

# 176453595b224b209cff718d77b33b5e
#~ msgid ""
#~ "You may also want to implement this method to limit the lookup types that "
#~ "could be used with your custom field type."
#~ msgstr ""
#~ "Вы можете использовать это метод, чтобы ограничить типы фильтров, "
#~ "используемых с вашим полем."

# ad20a1d2d712482ba5b7e4c1d2a11e57
#~ msgid ""
#~ "Note that, for ``\"range\"`` and ``\"in\"`` lookups, ``get_prep_lookup`` "
#~ "will receive a list of objects (presumably of the right type) and will "
#~ "need to convert them to a list of things of the right type for passing to "
#~ "the database. Most of the time, you can reuse ``get_prep_value()``, or at "
#~ "least factor out some common pieces."
#~ msgstr ""
#~ "Заметьте, что для ``\"range\"`` и ``\"in\"`` метод ``get_prep_lookup`` "
#~ "принимает список объектов (предположительно правильного типа) и должен "
#~ "вернуть список параметров для запроса. В большинстве случаев вы можете "
#~ "использовать ``get_prep_value()`` для объектов списка."

# 0a8a4f91d3f643bbb223ce31844d084e
#~ msgid ""
#~ "For example, the following code implements ``get_prep_lookup`` to limit "
#~ "the accepted lookup types to ``exact`` and ``in``::"
#~ msgstr ""
#~ "Например, следующий код реализует метод ``get_prep_lookup``, ограничивая "
#~ "используемые фильтры до ``exact`` и ``in``::"

# 78fc9157c3cd442f9c7433b8c403e768
#~ msgid ""
#~ "For performing database-specific data conversions required by a lookup, "
#~ "you can override :meth:`~Field.get_db_prep_lookup`."
#~ msgstr ""
#~ "Если вам нужны дополнительные преобразования значения при использовании "
#~ "его в запросе, вы можете переопределить метод :meth:`~Field."
#~ "get_db_prep_lookup`."

# a7c0b4b1afeb4913bc56375a904a2547
#~ msgid ""
#~ "``deconstruct()`` is part of the migrations framework in Django 1.7 and "
#~ "above. If you have custom fields from previous versions they will need "
#~ "this method added before you can use them with migrations."
#~ msgstr ""
#~ "``deconstruct()`` -- часть приложения миграций в Django 1.7 и выше. Если "
#~ "вы используете поля из предыдущих версий, вам необходимо добавить этот "
#~ "метод перед тем, как использовать их в миграциях."

# ccdf18966b884e47b527e53527b87219
#~ msgid "The ``SubfieldBase`` metaclass"
#~ msgstr "Метакласс ``SubfieldBase``"

# a511197a6d0547c1915e9f8c17de1ac4
#~ msgid ""
#~ "As we indicated in the introduction_, field subclasses are often needed "
#~ "for two reasons: either to take advantage of a custom database column "
#~ "type, or to handle complex Python types. Obviously, a combination of the "
#~ "two is also possible. If you're only working with custom database column "
#~ "types and your model fields appear in Python as standard Python types "
#~ "direct from the database backend, you don't need to worry about this "
#~ "section."
#~ msgstr ""
#~ "Как уже упоминалось в Предисловии, собственные поля используются в двух "
#~ "случаях: для использования типа поля для определенной базы данных и для "
#~ "работы со сложными объектами Python. Если вам необходимо работать с "
#~ "определенным типом поля в базе данных и использовать встроенные типы "
#~ "данных Python, вы можете пропустить этот раздел."

# bc5f8023a399477994fb27774ce3496b
#~ msgid ""
#~ "If you're handling custom Python types, such as our ``Hand`` class, we "
#~ "need to make sure that when Django initializes an instance of our model "
#~ "and assigns a database value to our custom field attribute, we convert "
#~ "that value into the appropriate Python object. The details of how this "
#~ "happens internally are a little complex, but the code you need to write "
#~ "in your ``Field`` class is simple: make sure your field subclass uses a "
#~ "special metaclass:"
#~ msgstr ""
#~ "Если мы используем собственный тип Python, такой как наш класс ``Hand``, "
#~ "мы должны убедиться, что Django при создании экземпляра модели и "
#~ "добавления значения из базы данных в атрибут поля, преобразует значение в "
#~ "правильный объект Python. Полное описание этого процесса сложное для "
#~ "понимания, но код, который вам необходимо написать в классе поля, "
#~ "простой: убедитесь, что ваш подкласс использует специальный метакласс:"

# 8aa51dada69c46d69cb5a430450ca4f8
# 23f1c9910512473e852f8cd1d6ab5b98
# a5f20ed046d34070bee573fe53500653
# 497f47a638de4e2395c3e37ff9210a9a
#~ msgid "For example, on Python 2::"
#~ msgstr "Например, для Python 2::"

# bcc6e848fc334fdcb0ff7398a78709f1
#~ msgid ""
#~ "On Python 3, in lieu of setting the ``__metaclass__`` attribute, add "
#~ "``metaclass`` to the class definition::"
#~ msgstr ""
#~ "В Python 3, вместо атрибута ``__metaclass__`` в определении класса "
#~ "добавьте ``metaclass``::"

# 921e85c73ca54737864b3f65f8a6e30e
#~ msgid ""
#~ "If you want your code to work on Python 2 & 3, you can use :func:`six."
#~ "with_metaclass`::"
#~ msgstr ""
#~ "Если вы хотите, чтобы ваш код работал на Python 2 & 3, можно "
#~ "использовать :func:`six.with_metaclass`::"

# 23c255f0a9414627a2360c9413f5f1a0
#~ msgid ""
#~ "This ensures that the :meth:`.to_python` method will always be called "
#~ "when the attribute is initialized."
#~ msgstr ""
#~ "Теперь мы можем быть уверены, что метод :meth:`.to_python`, описанный "
#~ "ниже, будет всегда вызываться при инициализации атрибута."

# d1121da5c6f141e6b07ea92e1b00e195
#~ msgid "``ModelForm``\\s and custom fields"
#~ msgstr "``ModelForm`` и собственные поля"

# 32eeab5385cb41ffa87372d34f0dd262
#~ msgid ""
#~ "If you use :class:`~django.db.models.SubfieldBase`, :meth:`.to_python` "
#~ "will be called every time an instance of the field is assigned a value "
#~ "(in addition to its usual call when retrieving the value from the "
#~ "database). This means that whenever a value may be assigned to the field, "
#~ "you need to ensure that it will be of the correct datatype, or that you "
#~ "handle any exceptions."
#~ msgstr ""
#~ "Если вы используете :class:`~django.db.models.SubfieldBase`, :meth:`."
#~ "to_python` будет вызываться при присваивании полю значения (в дополнение "
#~ "к вызову, который происходит при получении значения из базы данных). Это "
#~ "означает, что каждый раз при присваивании полю значения, вы должны "
#~ "проверить правильность его типа и обработать все ошибки."

# f1d872d8ba394232b1ae914b36962369
#~ msgid ""
#~ "This is especially important if you use :doc:`ModelForms </topics/forms/"
#~ "modelforms>`. When saving a ModelForm, Django will use form values to "
#~ "instantiate model instances. However, if the cleaned form data can't be "
#~ "used as valid input to the field, the normal form validation process will "
#~ "break."
#~ msgstr ""
#~ "Это особо важно при использовании :doc:`ModelForms </topics/forms/"
#~ "modelforms>`. При сохранении ModelForm, Django использует данные из формы "
#~ "при создании экземпляра модели. Если проверенные данные из формы не могут "
#~ "быть использованы в качестве значения для поля модели, стандартный "
#~ "процесс проверки данных в форме будет нарушен."

# d47092e197634e85b7ca5d72a27454d1
#~ msgid ""
#~ "Therefore, you must ensure that the form field used to represent your "
#~ "custom field performs whatever input validation and data cleaning is "
#~ "necessary to convert user-provided form input into a ``to_python()``-"
#~ "compatible model field value. This may require writing a custom form "
#~ "field, and/or implementing the :meth:`.formfield` method on your field to "
#~ "return a form field class whose ``to_python()`` returns the correct "
#~ "datatype."
#~ msgstr ""
#~ "Поэтому вы должны убедиться, что поле формы, которое отображает ваше поле "
#~ "модели, выполняет все необходимые проверки данных и преобразует их в тип "
#~ "аналогичный используемому методом `to_python()` вашего поля модели. Для "
#~ "этого, возможно, вам придется создать собственный класс поля формы и/или "
#~ "переопределить метод :meth:`.formfield` поля модели, чтобы метод "
#~ "`to_python()` класса поля формы возвращал данные правильного типа."

# cca370d5dc4548d5b1338470d4e1d5a4
#~ msgid "A string (e.g., from a deserializer)."
#~ msgstr "Строка (например, при десериализации)."

# 00f3339e4406498dbfe43b39dfff53c0
#~ msgid "Whatever the database returns for the column type you're using."
#~ msgstr "Значение, возвращаемое базой данных."

# 20dff6ea3d2d4b61908acca320f58bcb
#~ msgid ""
#~ "**Remember:** If your custom field needs the :meth:`~Field.to_python` "
#~ "method to be called when it is created, you should be using `The "
#~ "SubfieldBase metaclass`_ mentioned earlier. Otherwise :meth:`~Field."
#~ "to_python` won't be called automatically."
#~ msgstr ""
#~ "**Помните:** если вашему полю необходим вызов :meth:`~Field.to_python` "
#~ "при создании, используйте вышеупомянутый `метакласс The SubfieldBase`_ "
#~ "(FIXME). Иначе метод :meth:`~Field.to_python` не будет автоматически "
#~ "вызван."

# 97abd394f9164c8584b1865e7ad09236
#~ msgid ""
#~ "If your custom field allows ``null=True``, any field method that takes "
#~ "``value`` as an argument, like :meth:`~Field.to_python` and :meth:`~Field."
#~ "get_prep_value`, should handle the case when ``value`` is ``None``."
#~ msgstr ""
#~ "Если ваше поле позволяет указать ``null=True``, все методы поля, которые "
#~ "принимают ``value``, такие как :meth:`~Field.to_python` и :meth:`~Field."
#~ "get_prep_value`, должны учитывать ситуацию, когда ``value`` равно "
#~ "``None``."

# 49fd3ed7a29b4d80a9846e75e2b141d0
#~ msgid ""
#~ "Returns the database column data type for the :class:`~django.db.models."
#~ "Field`, taking into account the connection object, and the settings "
#~ "associated with it."
#~ msgstr ""
#~ "Возвращает тип поля в базе данных для :class:`~django.db.models.Field`, "
#~ "учитывая настройки подключения и параметры поля."

# a8e078688ed5477587db4f0b3f994d11
#~ msgid ""
#~ "Converts a value as returned by your database (or a serializer) to a "
#~ "Python object."
#~ msgstr ""
#~ "Преобразует значение, которое вернула база данных (или сериализатор), в "
#~ "объект Python."

# b931e9c1d4bb49a6a5062d432647ec8e
#~ msgid ""
#~ "The default implementation simply returns ``value``, for the common case "
#~ "in which the database backend already returns data in the correct format "
#~ "(as a Python string, for example)."
#~ msgstr ""
#~ "Реализация по умолчанию возвращает ``value`` без изменений, так как в "
#~ "большинстве случаев бэкенд базы данных возвращает значение в нужном "
#~ "формате (например, строка Python string)."

# d760810bf758497297e6f0f4fda9cb7e
#~ msgid ""
#~ "This is the reverse of :meth:`.to_python` when working with the database "
#~ "backends (as opposed to serialization). The ``value`` parameter is the "
#~ "current value of the model's attribute (a field has no reference to its "
#~ "containing model, so it cannot retrieve the value itself), and the method "
#~ "should return data in a format that has been prepared for use as a "
#~ "parameter in a query."
#~ msgstr ""
#~ "Есть метод обратный :meth:`.to_python` при работе с бэкендом базы данных "
#~ "(но не сериализатором). Аргумент ``value`` - это значение атрибута модели "
#~ "(поле не содержит ссылку на модель и не может получить значение "
#~ "самостоятельно), метод должен вернуть данные для подстановки в запрос."

# 9a1f745b1bf14861b1981ed0e4648a93
#~ msgid ""
#~ "This conversion should *not* include any database-specific conversions. "
#~ "If database-specific conversions are required, they should be made in the "
#~ "call to :meth:`.get_db_prep_value`."
#~ msgstr ""
#~ "Это преобразование *не* должно выполнять ничего, что зависит от типа базы "
#~ "данных. Если необходимо преобразование специфическое для какой либо базы "
#~ "данных, его необходимо выполнить в методе :meth:`.get_db_prep_value`."

# 9eeaed2ad0154651a97c6dba7334cc2a
#~ msgid ""
#~ "The ``prepared`` argument describes whether or not the value has already "
#~ "been passed through :meth:`.get_prep_value` conversions. When "
#~ "``prepared`` is False, the default implementation of :meth:`."
#~ "get_db_prep_value` will call :meth:`.get_prep_value` to do initial data "
#~ "conversions before performing any database-specific processing."
#~ msgstr ""
#~ "Аргумент ``prepared`` указывает, было ли значение обработано :meth:`."
#~ "get_prep_value`. При ``prepared`` равном False :meth:`.get_db_prep_value` "
#~ "по умолчанию вызовет :meth:`.get_prep_value` перед дальнейшим "
#~ "преобразованием."

# 4699a2ddc22342bcb5715770e09c2049
#~ msgid ""
#~ "Same as the above, but called when the Field value must be *saved* to the "
#~ "database. As the default implementation just calls :meth:`."
#~ "get_db_prep_value`, you shouldn't need to implement this method unless "
#~ "your custom field needs a special conversion when being saved that is not "
#~ "the same as the conversion used for normal query parameters (which is "
#~ "implemented by :meth:`.get_db_prep_value`)."
#~ msgstr ""
#~ "Аналогичен предыдущему методу, но вызывается когда значение Field "
#~ "*сохраняется* в БД. По умолчанию вызывается метод :meth:`."
#~ "get_db_prep_value`, вы не должны ничего менять, если нет необходимости "
#~ "выполнять дополнительное преобразование значения именно при сохранении, а "
#~ "не каких либо других запросах (что выполняется в :meth:`."
#~ "get_db_prep_value`)."

# 1c5ccaf481f84ebd8b6314f1483a679d
#~ msgid ""
#~ "This method is called just prior to :meth:`.get_db_prep_save` and should "
#~ "return the value of the appropriate attribute from ``model_instance`` for "
#~ "this field. The attribute name is in ``self.attname`` (this is set up by :"
#~ "class:`~django.db.models.Field`). If the model is being saved to the "
#~ "database for the first time, the ``add`` parameter will be ``True``, "
#~ "otherwise it will be ``False``."
#~ msgstr ""
#~ "Этот метод вызывается перед :meth:`.get_db_prep_save` и должен вернуть "
#~ "значение атрибута из ``model_instance`` для этого поля. Название атрибута "
#~ "хранится в ``self.attname`` (устанавливается в :class:`~django.db.models."
#~ "Field`). При сохранении данных в базу данных первый раз, аргумент ``add`` "
#~ "будет равен ``True``, иначе - ``False``."

# e34085db53c840e0b7e8ea87c5e7a70a
#~ msgid ""
#~ "Performs any database-specific data conversions required by a lookup. As "
#~ "with :meth:`.get_db_prep_value`, the specific connection that will be "
#~ "used for the query is passed as the ``connection`` parameter. The "
#~ "``prepared`` argument describes whether the value has already been "
#~ "prepared with :meth:`.get_prep_lookup`."
#~ msgstr ""
#~ "Выполняет преобразование параметров фильтра с учетом типа базы данных. "
#~ "Как и в метод :meth:`.get_db_prep_value` передается аргумент "
#~ "``connection``. Параметр ``prepared`` указывает, было ли значение "
#~ "преобразовано методом :meth:`.get_prep_lookup`."

# 82688290147c463f9ed132ea13f0b6d0
#~ msgid ""
#~ "Returns the default form field to use when this model field is displayed "
#~ "in a form.  This method is called by the :class:`~django.forms.ModelForm` "
#~ "helper."
#~ msgstr ""
#~ "Возвращает поле формы, которое будет использовано при генерации формы для "
#~ "модели. Этот метод используется в :class:`~django.forms.ModelForm`."

# d09bfaa8cde6491b88acbe7b8feecd1f
#~ msgid ""
#~ "Returns a string giving the name of the :class:`~django.db.models.Field` "
#~ "subclass we are emulating at the database level. This is used to "
#~ "determine the type of database column for simple cases."
#~ msgstr ""
#~ "Возвращает название субкласса :class:`~django.db.models.Field`, который "
#~ "мы эмулируем на уровне базы данных. Это позволяет определить тип поля в "
#~ "базе данных для простых случаев."
